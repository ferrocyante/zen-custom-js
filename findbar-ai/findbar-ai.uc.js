// ==UserScript==
// @name            BrowseBot
// @description     Transforms the standard Zen Browser findbar into a modern, floating, AI-powered chat interface.
// @author          BibekBhusal
// ==/UserScript==


(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.BrowseBot = {}));
})(this, (function (exports) { 'use strict';

  const PREFS = {
    ENABLED: "extension.browse-bot.enabled",
    MINIMAL: "extension.browse-bot.minimal",
    PERSIST: "extension.browse-bot.persist-chat",
    DND_ENABLED: "extension.browse-bot.dnd-enabled",
    POSITION: "extension.browse-bot.position",
    DEBUG_MODE: "extension.browse-bot.debug-mode",
    PSEUDO_BG: "extension.pseudo-bg.enabled",
    STREAM_ENABLED: "extension.browse-bot.stream-enabled",

    GOD_MODE: "extension.browse-bot.god-mode",
    CITATIONS_ENABLED: "extension.browse-bot.citations-enabled",
    MAX_TOOL_CALLS: "extension.browse-bot.max-tool-calls",
    CONFORMATION: "extension.browse-bot.conform-before-tool-call",

    CONTEXT_MENU_ENABLED: "extension.browse-bot.context-menu-enabled",
    CONTEXT_MENU_AUTOSEND: "extension.browse-bot.context-menu-autosend",

    LLM_PROVIDER: "extension.browse-bot.llm-provider",
    MISTRAL_API_KEY: "extension.browse-bot.mistral-api-key",
    MISTRAL_MODEL: "extension.browse-bot.mistral-model",
    GEMINI_API_KEY: "extension.browse-bot.gemini-api-key",
    GEMINI_MODEL: "extension.browse-bot.gemini-model",
    OPENAI_API_KEY: "extension.browse-bot.openai-api-key",
    OPENAI_MODEL: "extension.browse-bot.openai-model",
    CLAUDE_API_KEY: "extension.browse-bot.claude-api-key",
    CLAUDE_MODEL: "extension.browse-bot.claude-model",
    GROK_API_KEY: "extension.browse-bot.grok-api-key",
    GROK_MODEL: "extension.browse-bot.grok-model",
    PERPLEXITY_API_KEY: "extension.browse-bot.perplexity-api-key",
    PERPLEXITY_MODEL: "extension.browse-bot.perplexity-model",
    OLLAMA_MODEL: "extension.browse-bot.ollama-model",
    OLLAMA_API_KEY: "extension.browse-bot.ollama-api-key",

    //TODO: Not yet implimented
    COPY_BTN_ENABLED: "extension.browse-bot.copy-btn-enabled",
    MARKDOWN_ENABLED: "extension.browse-bot.markdown-enabled",
    SHOW_TOOL_CALL: "extension.browse-bot.show-tool-call",

    defaultValues: {},

    getPref(key) {
      try {
        const pref = UC_API.Prefs.get(key);
        if (!pref) return PREFS.defaultValues[key];
        if (!pref.exists()) return PREFS.defaultValues[key];
        return pref.value;
      } catch {
        return PREFS.defaultValues[key];
      }
    },

    setPref(prefKey, value) {
      UC_API.Prefs.set(prefKey, value);
    },

    setInitialPrefs() {
      for (const [key, value] of Object.entries(PREFS.defaultValues)) {
        UC_API.Prefs.setIfUnset(key, value);
      }
    },

    get enabled() {
      return this.getPref(this.ENABLED);
    },
    set enabled(value) {
      this.setPref(this.ENABLED, value);
    },

    get minimal() {
      return this.getPref(this.MINIMAL);
    },
    set minimal(value) {
      this.setPref(this.MINIMAL, value);
    },

    get streamEnabled() {
      return this.getPref(this.STREAM_ENABLED);
    },
    set streamEnabled(value) {
      this.setPref(this.STREAM_ENABLED, value);
    },

    set godMode(value) {
      this.setPref(this.GOD_MODE, value);
    },
    get godMode() {
      return this.getPref(this.GOD_MODE);
    },

    get citationsEnabled() {
      return this.getPref(this.CITATIONS_ENABLED);
    },
    set citationsEnabled(value) {
      this.setPref(this.CITATIONS_ENABLED, value);
    },

    get contextMenuEnabled() {
      return this.getPref(this.CONTEXT_MENU_ENABLED);
    },
    set contextMenuEnabled(value) {
      this.setPref(this.CONTEXT_MENU_ENABLED, value);
    },

    get contextMenuAutoSend() {
      return this.getPref(this.CONTEXT_MENU_AUTOSEND);
    },
    set contextMenuAutoSend(value) {
      this.setPref(this.CONTEXT_MENU_AUTOSEND, value);
    },

    get llmProvider() {
      return this.getPref(this.LLM_PROVIDER);
    },
    set llmProvider(value) {
      this.setPref(this.LLM_PROVIDER, value);
    },

    get persistChat() {
      return this.getPref(this.PERSIST);
    },
    set persistChat(value) {
      this.setPref(this.PERSIST, value);
    },

    get pseudoBg() {
      return this.getPref(this.PSEUDO_BG);
    },
    set maxToolCalls(value) {
      this.setPref(this.PSEUDO_BG, value);
    },

    get maxToolCalls() {
      return this.getPref(this.MAX_TOOL_CALLS);
    },
    set maxToolCalls(value) {
      this.setPref(this.MAX_TOOL_CALLS, value);
    },

    get copyBtnEnabled() {
      return this.getPref(this.COPY_BTN_ENABLED);
    },
    set copyBtnEnabled(value) {
      this.setPref(this.COPY_BTN_ENABLED, value);
    },

    get markdownEnabled() {
      return this.getPref(this.MARKDOWN_ENABLED);
    },
    set markdownEnabled(value) {
      this.setPref(this.MARKDOWN_ENABLED, value);
    },

    get conformation() {
      return this.getPref(this.CONFORMATION);
    },
    set conformation(value) {
      this.setPref(this.CONFORMATION, value);
    },

    get showToolCall() {
      return this.getPref(this.SHOW_TOOL_CALL);
    },
    set showToolCall(value) {
      this.setPref(this.SHOW_TOOL_CALL, value);
    },

    get dndEnabled() {
      return this.getPref(this.DND_ENABLED);
    },
    set dndEnabled(value) {
      this.setPref(this.DND_ENABLED, value);
    },

    get position() {
      return this.getPref(this.POSITION);
    },
    set position(value) {
      this.setPref(this.POSITION, value);
    },
  };

  const debugLog = (...args) => {
    if (PREFS.getPref(PREFS.DEBUG_MODE, false)) {
      console.log("BrowseBot :", ...args);
    }
  };

  const debugError = (...args) => {
    if (PREFS.getPref(PREFS.DEBUG_MODE, false)) {
      console.error("BrowseBot :", ...args);
    }
  };

  PREFS.defaultValues = {
    [PREFS.ENABLED]: true,
    [PREFS.MINIMAL]: true,
    [PREFS.GOD_MODE]: false,
    [PREFS.DEBUG_MODE]: false,
    [PREFS.PERSIST]: false,
    [PREFS.STREAM_ENABLED]: true,
    [PREFS.CITATIONS_ENABLED]: false,
    [PREFS.CONTEXT_MENU_ENABLED]: true,
    [PREFS.CONTEXT_MENU_AUTOSEND]: true,
    [PREFS.LLM_PROVIDER]: "gemini",
    [PREFS.MISTRAL_API_KEY]: "",
    [PREFS.MISTRAL_MODEL]: "mistral-medium-latest",
    [PREFS.GEMINI_API_KEY]: "",
    [PREFS.GEMINI_MODEL]: "gemini-2.0-flash",
    [PREFS.OPENAI_API_KEY]: "",
    [PREFS.OPENAI_MODEL]: "gpt-4o",
    [PREFS.CLAUDE_API_KEY]: "",
    [PREFS.CLAUDE_MODEL]: "claude-4-opus",
    [PREFS.GROK_API_KEY]: "",
    [PREFS.GROK_MODEL]: "grok-4",
    [PREFS.PERPLEXITY_API_KEY]: "",
    [PREFS.PERPLEXITY_MODEL]: "sonar",
    [PREFS.OLLAMA_MODEL]: "llama2",
    [PREFS.OLLAMA_API_KEY]: "",
    [PREFS.DND_ENABLED]: true,
    [PREFS.POSITION]: "top-right",
    [PREFS.MAX_TOOL_CALLS]: 5,
    [PREFS.CONFORMATION]: true,
    [PREFS.PSEUDO_BG]: false,
    // [PREFS.COPY_BTN_ENABLED]: true,
    // [PREFS.MARKDOWN_ENABLED]: true,
    // [PREFS.SHOW_TOOL_CALL]: false,
  };

  function frameScript() {
    const getUrlAndTitle = () => {
      return {
        url: content.location.href,
        title: content.document.title,
      };
    };

    const extractRelevantContent = () => {
      const clonedBody = content.document.body.cloneNode(true);
      const elementsToRemove = clonedBody.querySelectorAll(
        "script, style, meta, noscript, iframe, svg, canvas, img, video, audio, object, embed, applet, link, head"
      );
      elementsToRemove.forEach((el) => el.remove());
      return clonedBody.innerHTML;
    };

    const extractTextContent = (trimWhiteSpace = true) => {
      const clonedBody = content.document.body.cloneNode(true);
      const elementsToRemove = clonedBody.querySelectorAll(
        "script, style, meta, noscript, iframe, svg, canvas, input, textarea, select, img, video, audio, object, embed, applet, form, button, link, head"
      );
      elementsToRemove.forEach((el) => el.remove());

      clonedBody.querySelectorAll("br").forEach((br) => {
        br.replaceWith("\n");
      });

      const blockSelector =
        "p, div, li, h1, h2, h3, h4, h5, h6, tr, article, section, header, footer, aside, main, blockquote, pre";
      clonedBody.querySelectorAll(blockSelector).forEach((el) => {
        el.append("\n");
      });

      const textContent = clonedBody.textContent;

      if (trimWhiteSpace) {
        return textContent.replace(/\s+/g, " ").trim();
      }

      return textContent
        .replace(/[ \t\r\f\v]+/g, " ")
        .replace(/ ?\n ?/g, "\n")
        .replace(/\n+/g, "\n")
        .trim();
    };

    async function getYouTubeTranscript() {
      const win = content;
      const doc = content.document;

      async function ensureBodyAvailable() {
        if (doc.body) return;
        await new Promise((resolve) => {
          const check = () => {
            if (doc.body) resolve();
            else win.setTimeout(check, 50);
          };
          check();
        });
      }

      function waitForSelectorWithObserver(selector, timeout = 5000) {
        return new Promise(async (resolve, reject) => {
          try {
            await ensureBodyAvailable();
            const el = doc.querySelector(selector);
            if (el) return resolve(el);

            const observer = new win.MutationObserver(() => {
              const el = doc.querySelector(selector);
              if (el) {
                observer.disconnect();
                resolve(el);
              }
            });

            observer.observe(doc.body, {
              childList: true,
              subtree: true,
            });

            win.setTimeout(() => {
              observer.disconnect();
              reject(new Error(`Timeout waiting for ${selector}`));
            }, timeout);
          } catch (e) {
            reject(new Error(`waitForSelectorWithObserver failed: ${e.message}`));
          }
        });
      }

      try {
        if (!doc.querySelector("ytd-transcript-renderer")) {
          const button = doc.querySelector('button[aria-label="Show transcript"]');
          if (!button)
            throw new Error('"Show transcript" button not found â€” transcript may not be available.');
          button.click();
          await waitForSelectorWithObserver("ytd-transcript-renderer", 5000);
        }

        await waitForSelectorWithObserver("ytd-transcript-segment-renderer .segment-text", 5000);

        const segments = Array.from(
          doc.querySelectorAll("ytd-transcript-segment-renderer .segment-text")
        );
        if (!segments.length) throw new Error("Transcript segments found, but all are empty.");

        const transcript = segments
          .map((el) => el.textContent.trim())
          .filter(Boolean)
          .join("\n");
        return transcript;
      } catch (err) {
        throw err;
      }
    }

    const handlers = {
      GetPageHTMLContent: () => {
        return {
          content: extractRelevantContent(),
          url: getUrlAndTitle().url,
          title: getUrlAndTitle().title,
        };
      },

      GetSelectedText: () => {
        const selection = content.getSelection();
        return {
          selectedText: selection.toString(),
          hasSelection: !selection.isCollapsed,
          ...getUrlAndTitle(),
        };
      },

      GetPageTextContent: ({ trimWhiteSpace }) => {
        return {
          textContent: extractTextContent(trimWhiteSpace),
          ...getUrlAndTitle(),
        };
      },

      ClickElement: ({ selector }) => {
        const element = content.document.querySelector(selector);
        if (!element) {
          throw new Error(`Element with selector "${selector}" not found.`);
        }
        element.click();
        return { result: `Clicked element with selector "${selector}".` };
      },

      FillForm: ({ selector, value }) => {
        const element = content.document.querySelector(selector);
        if (!element) {
          throw new Error(`Element with selector "${selector}" not found.`);
        }
        element.value = value;
        element.dispatchEvent(new Event("input", { bubbles: true }));
        return {
          result: `Filled element with selector "${selector}" with value "${value}".`,
        };
      },

      GetYoutubeTranscript: async () => {
        const transcript = await getYouTubeTranscript();
        return { transcript };
      },
    };

    addMessageListener("FindbarAI:Command", async function (msg) {
      const cmd = msg.data.command;
      const data = msg.data.data || {};
      try {
        const result = await handlers[cmd](data);
        sendAsyncMessage("FindbarAI:Result", { command: cmd, result });
      } catch (e) {
        sendAsyncMessage("FindbarAI:Result", { command: cmd, result: { error: e.message } });
      }
    });
  }

  let currentMessageManager = null;

  const updateMessageManager = () => {
    if (gBrowser && gBrowser.selectedBrowser) {
      const mm = gBrowser.selectedBrowser.messageManager;
      if (mm !== currentMessageManager) {
        currentMessageManager = mm;
        if (!gBrowser.selectedBrowser._findbarAIInjected) {
          const scriptText = `(${frameScript})();`;
          mm.loadFrameScript(
            "data:application/javascript;charset=utf-8," + encodeURIComponent(scriptText),
            false
          );
          gBrowser.selectedBrowser._findbarAIInjected = true;
        }
      }
    }
  };

  const messageManagerAPI = {
    send(cmd, data = {}) {
      updateMessageManager();
      if (!currentMessageManager) {
        debugError("No message manager available.");
        return Promise.reject(new Error("No message manager available."));
      }

      return new Promise((resolve, reject) => {
        const listener = (msg) => {
          if (msg.data.command === cmd) {
            currentMessageManager.removeMessageListener("FindbarAI:Result", listener);
            if (msg.data.result && msg.data.result.error) {
              reject(new Error(msg.data.result.error));
            } else {
              resolve(msg.data.result);
            }
          }
        };
        currentMessageManager.addMessageListener("FindbarAI:Result", listener);
        currentMessageManager.sendAsyncMessage("FindbarAI:Command", { command: cmd, data });
      });
    },

    getUrlAndTitle() {
      return {
        url: gBrowser.currentURI.spec,
        title: gBrowser.selectedBrowser.contentTitle,
      };
    },

    async getHTMLContent() {
      try {
        return await this.send("GetPageHTMLContent");
      } catch (error) {
        debugError("Failed to get page HTML content:", error);
        return {};
      }
    },

    async getSelectedText() {
      try {
        const result = await this.send("GetSelectedText");
        if (!result || !result.hasSelection) {
          return this.getUrlAndTitle();
        }
        return result;
      } catch (error) {
        debugError("Failed to get selected text:", error);
        return this.getUrlAndTitle();
      }
    },

    async getPageTextContent(trimWhiteSpace = true) {
      try {
        return await this.send("GetPageTextContent", { trimWhiteSpace });
      } catch (error) {
        debugError("Failed to get page text content:", error);
        return this.getUrlAndTitle();
      }
    },

    async clickElement(selector) {
      try {
        return await this.send("ClickElement", { selector });
      } catch (error) {
        debugError(`Failed to click element with selector "${selector}":`, error);
        return { error: `Failed to click element with selector "${selector}".` };
      }
    },

    async fillForm(selector, value) {
      try {
        return await this.send("FillForm", { selector, value });
      } catch (error) {
        debugError(`Failed to fill form with selector "${selector}":`, error);
        return { error: `Failed to fill form with selector "${selector}".` };
      }
    },

    async getYoutubeTranscript() {
      try {
        return await this.send("GetYoutubeTranscript");
      } catch (error) {
        debugError("Failed to get youtube transcript:", error);
        return { error: `Failed to get youtube transcript: ${error.message}` };
      }
    },
  };

  // src/errors/ai-sdk-error.ts
  var marker$3 = "vercel.ai.error";
  var symbol$4 = Symbol.for(marker$3);
  var _a$3;
  var _AISDKError$1 = class _AISDKError extends Error {
    /**
     * Creates an AI SDK Error.
     *
     * @param {Object} params - The parameters for creating the error.
     * @param {string} params.name - The name of the error.
     * @param {string} params.message - The error message.
     * @param {unknown} [params.cause] - The underlying cause of the error.
     */
    constructor({
      name: name14,
      message,
      cause
    }) {
      super(message);
      this[_a$3] = true;
      this.name = name14;
      this.cause = cause;
    }
    /**
     * Checks if the given error is an AI SDK Error.
     * @param {unknown} error - The error to check.
     * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
     */
    static isInstance(error) {
      return _AISDKError.hasMarker(error, marker$3);
    }
    static hasMarker(error, marker15) {
      const markerSymbol = Symbol.for(marker15);
      return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
  };
  _a$3 = symbol$4;
  var AISDKError$1 = _AISDKError$1;

  // src/errors/api-call-error.ts
  var name$3 = "AI_APICallError";
  var marker2$3 = `vercel.ai.error.${name$3}`;
  var symbol2$3 = Symbol.for(marker2$3);
  var _a2$3;
  var APICallError$1 = class APICallError extends AISDKError$1 {
    constructor({
      message,
      url,
      requestBodyValues,
      statusCode,
      responseHeaders,
      responseBody,
      cause,
      isRetryable = statusCode != null && (statusCode === 408 || // request timeout
      statusCode === 409 || // conflict
      statusCode === 429 || // too many requests
      statusCode >= 500),
      // server error
      data
    }) {
      super({ name: name$3, message, cause });
      this[_a2$3] = true;
      this.url = url;
      this.requestBodyValues = requestBodyValues;
      this.statusCode = statusCode;
      this.responseHeaders = responseHeaders;
      this.responseBody = responseBody;
      this.isRetryable = isRetryable;
      this.data = data;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker2$3);
    }
  };
  _a2$3 = symbol2$3;

  // src/errors/empty-response-body-error.ts
  var name2$3 = "AI_EmptyResponseBodyError";
  var marker3$2 = `vercel.ai.error.${name2$3}`;
  var symbol3$2 = Symbol.for(marker3$2);
  var _a3$2;
  var EmptyResponseBodyError$1 = class EmptyResponseBodyError extends AISDKError$1 {
    // used in isInstance
    constructor({ message = "Empty response body" } = {}) {
      super({ name: name2$3, message });
      this[_a3$2] = true;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker3$2);
    }
  };
  _a3$2 = symbol3$2;

  // src/errors/get-error-message.ts
  function getErrorMessage$2(error) {
    if (error == null) {
      return "unknown error";
    }
    if (typeof error === "string") {
      return error;
    }
    if (error instanceof Error) {
      return error.message;
    }
    return JSON.stringify(error);
  }

  // src/errors/invalid-argument-error.ts
  var name3$2 = "AI_InvalidArgumentError";
  var marker4$3 = `vercel.ai.error.${name3$2}`;
  var symbol4$3 = Symbol.for(marker4$3);
  var _a4$3;
  var InvalidArgumentError$2 = class InvalidArgumentError extends AISDKError$1 {
    constructor({
      message,
      cause,
      argument
    }) {
      super({ name: name3$2, message, cause });
      this[_a4$3] = true;
      this.argument = argument;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker4$3);
    }
  };
  _a4$3 = symbol4$3;

  // src/errors/invalid-prompt-error.ts
  var name4$2 = "AI_InvalidPromptError";
  var marker5$1 = `vercel.ai.error.${name4$2}`;
  var symbol5$1 = Symbol.for(marker5$1);
  var _a5$1;
  var InvalidPromptError = class extends AISDKError$1 {
    constructor({
      prompt,
      message,
      cause
    }) {
      super({ name: name4$2, message: `Invalid prompt: ${message}`, cause });
      this[_a5$1] = true;
      this.prompt = prompt;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker5$1);
    }
  };
  _a5$1 = symbol5$1;

  // src/errors/invalid-response-data-error.ts
  var name5$1 = "AI_InvalidResponseDataError";
  var marker6$1 = `vercel.ai.error.${name5$1}`;
  var symbol6$1 = Symbol.for(marker6$1);
  var _a6$1;
  var InvalidResponseDataError = class extends AISDKError$1 {
    constructor({
      data,
      message = `Invalid response data: ${JSON.stringify(data)}.`
    }) {
      super({ name: name5$1, message });
      this[_a6$1] = true;
      this.data = data;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker6$1);
    }
  };
  _a6$1 = symbol6$1;

  // src/errors/json-parse-error.ts
  var name6$2 = "AI_JSONParseError";
  var marker7$3 = `vercel.ai.error.${name6$2}`;
  var symbol7$3 = Symbol.for(marker7$3);
  var _a7$3;
  var JSONParseError$1 = class JSONParseError extends AISDKError$1 {
    constructor({ text, cause }) {
      super({
        name: name6$2,
        message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage$2(cause)}`,
        cause
      });
      this[_a7$3] = true;
      this.text = text;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker7$3);
    }
  };
  _a7$3 = symbol7$3;

  // src/errors/load-api-key-error.ts
  var name7$1 = "AI_LoadAPIKeyError";
  var marker8$1 = `vercel.ai.error.${name7$1}`;
  var symbol8$1 = Symbol.for(marker8$1);
  var _a8$1;
  var LoadAPIKeyError = class extends AISDKError$1 {
    // used in isInstance
    constructor({ message }) {
      super({ name: name7$1, message });
      this[_a8$1] = true;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker8$1);
    }
  };
  _a8$1 = symbol8$1;

  // src/errors/no-such-model-error.ts
  var name10$1 = "AI_NoSuchModelError";
  var marker11 = `vercel.ai.error.${name10$1}`;
  var symbol11 = Symbol.for(marker11);
  var _a11;
  var NoSuchModelError = class extends AISDKError$1 {
    constructor({
      errorName = name10$1,
      modelId,
      modelType,
      message = `No such ${modelType}: ${modelId}`
    }) {
      super({ name: errorName, message });
      this[_a11] = true;
      this.modelId = modelId;
      this.modelType = modelType;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker11);
    }
  };
  _a11 = symbol11;

  // src/errors/too-many-embedding-values-for-call-error.ts
  var name11$1 = "AI_TooManyEmbeddingValuesForCallError";
  var marker12$2 = `vercel.ai.error.${name11$1}`;
  var symbol12$2 = Symbol.for(marker12$2);
  var _a12$2;
  var TooManyEmbeddingValuesForCallError$1 = class TooManyEmbeddingValuesForCallError extends AISDKError$1 {
    constructor(options) {
      super({
        name: name11$1,
        message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
      });
      this[_a12$2] = true;
      this.provider = options.provider;
      this.modelId = options.modelId;
      this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
      this.values = options.values;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker12$2);
    }
  };
  _a12$2 = symbol12$2;

  // src/errors/type-validation-error.ts
  var name12$2 = "AI_TypeValidationError";
  var marker13$1 = `vercel.ai.error.${name12$2}`;
  var symbol13$1 = Symbol.for(marker13$1);
  var _a13$1;
  var _TypeValidationError$1 = class _TypeValidationError extends AISDKError$1 {
    constructor({ value, cause }) {
      super({
        name: name12$2,
        message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage$2(cause)}`,
        cause
      });
      this[_a13$1] = true;
      this.value = value;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker13$1);
    }
    /**
     * Wraps an error into a TypeValidationError.
     * If the cause is already a TypeValidationError with the same value, it returns the cause.
     * Otherwise, it creates a new TypeValidationError.
     *
     * @param {Object} params - The parameters for wrapping the error.
     * @param {unknown} params.value - The value that failed validation.
     * @param {unknown} params.cause - The original error or cause of the validation failure.
     * @returns {TypeValidationError} A TypeValidationError instance.
     */
    static wrap({
      value,
      cause
    }) {
      return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });
    }
  };
  _a13$1 = symbol13$1;
  var TypeValidationError$1 = _TypeValidationError$1;

  // src/errors/unsupported-functionality-error.ts
  var name13$1 = "AI_UnsupportedFunctionalityError";
  var marker14$2 = `vercel.ai.error.${name13$1}`;
  var symbol14$2 = Symbol.for(marker14$2);
  var _a14$2;
  var UnsupportedFunctionalityError$1 = class UnsupportedFunctionalityError extends AISDKError$1 {
    constructor({
      functionality,
      message = `'${functionality}' functionality not supported.`
    }) {
      super({ name: name13$1, message });
      this[_a14$2] = true;
      this.functionality = functionality;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker14$2);
    }
  };
  _a14$2 = symbol14$2;

  // src/json-value/is-json.ts
  function isJSONValue(value) {
    if (value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      return true;
    }
    if (Array.isArray(value)) {
      return value.every(isJSONValue);
    }
    if (typeof value === "object") {
      return Object.entries(value).every(
        ([key, val]) => typeof key === "string" && isJSONValue(val)
      );
    }
    return false;
  }
  function isJSONArray(value) {
    return Array.isArray(value) && value.every(isJSONValue);
  }
  function isJSONObject(value) {
    return value != null && typeof value === "object" && Object.entries(value).every(
      ([key, val]) => typeof key === "string" && isJSONValue(val)
    );
  }

  class ParseError extends Error {
    constructor(message, options) {
      super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
  }
  function noop(_arg) {
  }
  function createParser(callbacks) {
    if (typeof callbacks == "function")
      throw new TypeError(
        "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
      );
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
    function feed(newChunk) {
      const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
      for (const line of complete)
        parseLine(line);
      incompleteLine = incomplete, isFirstChunk = false;
    }
    function parseLine(line) {
      if (line === "") {
        dispatchEvent();
        return;
      }
      if (line.startsWith(":")) {
        onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
        return;
      }
      const fieldSeparatorIndex = line.indexOf(":");
      if (fieldSeparatorIndex !== -1) {
        const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
        processField(field, value, line);
        return;
      }
      processField(line, "", line);
    }
    function processField(field, value, line) {
      switch (field) {
        case "event":
          eventType = value;
          break;
        case "data":
          data = `${data}${value}
`;
          break;
        case "id":
          id = value.includes("\0") ? void 0 : value;
          break;
        case "retry":
          /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
            new ParseError(`Invalid \`retry\` value: "${value}"`, {
              type: "invalid-retry",
              value,
              line
            })
          );
          break;
        default:
          onError(
            new ParseError(
              `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
              { type: "unknown-field", field, value, line }
            )
          );
          break;
      }
    }
    function dispatchEvent() {
      data.length > 0 && onEvent({
        id,
        event: eventType || void 0,
        // If the data buffer's last character is a U+000A LINE FEED (LF) character,
        // then remove the last character from the data buffer.
        data: data.endsWith(`
`) ? data.slice(0, -1) : data
      }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
      incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return { feed, reset };
  }
  function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for (; searchIndex < chunk.length; ) {
      const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
      let lineEnd = -1;
      if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
        incompleteLine = chunk.slice(searchIndex);
        break;
      } else {
        const line = chunk.slice(searchIndex, lineEnd);
        lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
      }
    }
    return [lines, incompleteLine];
  }

  class EventSourceParserStream extends TransformStream {
    constructor({ onError, onRetry, onComment } = {}) {
      let parser;
      super({
        start(controller) {
          parser = createParser({
            onEvent: (event) => {
              controller.enqueue(event);
            },
            onError(error) {
              onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
            },
            onRetry,
            onComment
          });
        },
        transform(chunk) {
          parser.feed(chunk);
        }
      });
    }
  }

  /** A special constant with type `never` */
  const NEVER = Object.freeze({
      status: "aborted",
  });
  function $constructor(name, initializer, params) {
      function init(inst, def) {
          var _a;
          Object.defineProperty(inst, "_zod", {
              value: inst._zod ?? {},
              enumerable: false,
          });
          (_a = inst._zod).traits ?? (_a.traits = new Set());
          inst._zod.traits.add(name);
          initializer(inst, def);
          // support prototype modifications
          for (const k in _.prototype) {
              if (!(k in inst))
                  Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
          }
          inst._zod.constr = _;
          inst._zod.def = def;
      }
      // doesn't work if Parent has a constructor with arguments
      const Parent = params?.Parent ?? Object;
      class Definition extends Parent {
      }
      Object.defineProperty(Definition, "name", { value: name });
      function _(def) {
          var _a;
          const inst = params?.Parent ? new Definition() : this;
          init(inst, def);
          (_a = inst._zod).deferred ?? (_a.deferred = []);
          for (const fn of inst._zod.deferred) {
              fn();
          }
          return inst;
      }
      Object.defineProperty(_, "init", { value: init });
      Object.defineProperty(_, Symbol.hasInstance, {
          value: (inst) => {
              if (params?.Parent && inst instanceof params.Parent)
                  return true;
              return inst?._zod?.traits?.has(name);
          },
      });
      Object.defineProperty(_, "name", { value: name });
      return _;
  }
  //////////////////////////////   UTILITIES   ///////////////////////////////////////
  const $brand = Symbol("zod_brand");
  class $ZodAsyncError extends Error {
      constructor() {
          super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
  }
  class $ZodEncodeError extends Error {
      constructor(name) {
          super(`Encountered unidirectional transform during encode: ${name}`);
          this.name = "ZodEncodeError";
      }
  }
  const globalConfig = {};
  function config(newConfig) {
      if (newConfig)
          Object.assign(globalConfig, newConfig);
      return globalConfig;
  }

  // functions
  function assertEqual(val) {
      return val;
  }
  function assertNotEqual(val) {
      return val;
  }
  function assertIs(_arg) { }
  function assertNever(_x) {
      throw new Error();
  }
  function assert(_) { }
  function getEnumValues(entries) {
      const numericValues = Object.values(entries).filter((v) => typeof v === "number");
      const values = Object.entries(entries)
          .filter(([k, _]) => numericValues.indexOf(+k) === -1)
          .map(([_, v]) => v);
      return values;
  }
  function joinValues(array, separator = "|") {
      return array.map((val) => stringifyPrimitive(val)).join(separator);
  }
  function jsonStringifyReplacer(_, value) {
      if (typeof value === "bigint")
          return value.toString();
      return value;
  }
  function cached(getter) {
      return {
          get value() {
              {
                  const value = getter();
                  Object.defineProperty(this, "value", { value });
                  return value;
              }
          },
      };
  }
  function nullish$1(input) {
      return input === null || input === undefined;
  }
  function cleanRegex(source) {
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      return source.slice(start, end);
  }
  function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepString = step.toString();
      let stepDecCount = (stepString.split(".")[1] || "").length;
      if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
          const match = stepString.match(/\d?e-(\d?)/);
          if (match?.[1]) {
              stepDecCount = Number.parseInt(match[1]);
          }
      }
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
      return (valInt % stepInt) / 10 ** decCount;
  }
  const EVALUATING = Symbol("evaluating");
  function defineLazy(object, key, getter) {
      let value = undefined;
      Object.defineProperty(object, key, {
          get() {
              if (value === EVALUATING) {
                  // Circular reference detected, return undefined to break the cycle
                  return undefined;
              }
              if (value === undefined) {
                  value = EVALUATING;
                  value = getter();
              }
              return value;
          },
          set(v) {
              Object.defineProperty(object, key, {
                  value: v,
                  // configurable: true,
              });
              // object[key] = v;
          },
          configurable: true,
      });
  }
  function objectClone(obj) {
      return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
  }
  function assignProp(target, prop, value) {
      Object.defineProperty(target, prop, {
          value,
          writable: true,
          enumerable: true,
          configurable: true,
      });
  }
  function mergeDefs(...defs) {
      const mergedDescriptors = {};
      for (const def of defs) {
          const descriptors = Object.getOwnPropertyDescriptors(def);
          Object.assign(mergedDescriptors, descriptors);
      }
      return Object.defineProperties({}, mergedDescriptors);
  }
  function cloneDef(schema) {
      return mergeDefs(schema._zod.def);
  }
  function getElementAtPath(obj, path) {
      if (!path)
          return obj;
      return path.reduce((acc, key) => acc?.[key], obj);
  }
  function promiseAllObject(promisesObj) {
      const keys = Object.keys(promisesObj);
      const promises = keys.map((key) => promisesObj[key]);
      return Promise.all(promises).then((results) => {
          const resolvedObj = {};
          for (let i = 0; i < keys.length; i++) {
              resolvedObj[keys[i]] = results[i];
          }
          return resolvedObj;
      });
  }
  function randomString(length = 10) {
      const chars = "abcdefghijklmnopqrstuvwxyz";
      let str = "";
      for (let i = 0; i < length; i++) {
          str += chars[Math.floor(Math.random() * chars.length)];
      }
      return str;
  }
  function esc(str) {
      return JSON.stringify(str);
  }
  const captureStackTrace = ("captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => { });
  function isObject(data) {
      return typeof data === "object" && data !== null && !Array.isArray(data);
  }
  const allowsEval = cached(() => {
      // @ts-ignore
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
          return false;
      }
      try {
          const F = Function;
          new F("");
          return true;
      }
      catch (_) {
          return false;
      }
  });
  function isPlainObject(o) {
      if (isObject(o) === false)
          return false;
      // modified constructor
      const ctor = o.constructor;
      if (ctor === undefined)
          return true;
      // modified prototype
      const prot = ctor.prototype;
      if (isObject(prot) === false)
          return false;
      // ctor doesn't have static `isPrototypeOf`
      if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
          return false;
      }
      return true;
  }
  function shallowClone(o) {
      if (isPlainObject(o))
          return { ...o };
      return o;
  }
  function numKeys(data) {
      let keyCount = 0;
      for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
              keyCount++;
          }
      }
      return keyCount;
  }
  const getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
          case "undefined":
              return "undefined";
          case "string":
              return "string";
          case "number":
              return Number.isNaN(data) ? "nan" : "number";
          case "boolean":
              return "boolean";
          case "function":
              return "function";
          case "bigint":
              return "bigint";
          case "symbol":
              return "symbol";
          case "object":
              if (Array.isArray(data)) {
                  return "array";
              }
              if (data === null) {
                  return "null";
              }
              if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                  return "promise";
              }
              if (typeof Map !== "undefined" && data instanceof Map) {
                  return "map";
              }
              if (typeof Set !== "undefined" && data instanceof Set) {
                  return "set";
              }
              if (typeof Date !== "undefined" && data instanceof Date) {
                  return "date";
              }
              // @ts-ignore
              if (typeof File !== "undefined" && data instanceof File) {
                  return "file";
              }
              return "object";
          default:
              throw new Error(`Unknown data type: ${t}`);
      }
  };
  const propertyKeyTypes = new Set(["string", "number", "symbol"]);
  const primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  function escapeRegex(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  // zod-specific utils
  function clone(inst, def, params) {
      const cl = new inst._zod.constr(def ?? inst._zod.def);
      if (!def || params?.parent)
          cl._zod.parent = inst;
      return cl;
  }
  function normalizeParams(_params) {
      const params = _params;
      if (!params)
          return {};
      if (typeof params === "string")
          return { error: () => params };
      if (params?.message !== undefined) {
          if (params?.error !== undefined)
              throw new Error("Cannot specify both `message` and `error` params");
          params.error = params.message;
      }
      delete params.message;
      if (typeof params.error === "string")
          return { ...params, error: () => params.error };
      return params;
  }
  function createTransparentProxy(getter) {
      let target;
      return new Proxy({}, {
          get(_, prop, receiver) {
              target ?? (target = getter());
              return Reflect.get(target, prop, receiver);
          },
          set(_, prop, value, receiver) {
              target ?? (target = getter());
              return Reflect.set(target, prop, value, receiver);
          },
          has(_, prop) {
              target ?? (target = getter());
              return Reflect.has(target, prop);
          },
          deleteProperty(_, prop) {
              target ?? (target = getter());
              return Reflect.deleteProperty(target, prop);
          },
          ownKeys(_) {
              target ?? (target = getter());
              return Reflect.ownKeys(target);
          },
          getOwnPropertyDescriptor(_, prop) {
              target ?? (target = getter());
              return Reflect.getOwnPropertyDescriptor(target, prop);
          },
          defineProperty(_, prop, descriptor) {
              target ?? (target = getter());
              return Reflect.defineProperty(target, prop, descriptor);
          },
      });
  }
  function stringifyPrimitive(value) {
      if (typeof value === "bigint")
          return value.toString() + "n";
      if (typeof value === "string")
          return `"${value}"`;
      return `${value}`;
  }
  function optionalKeys(shape) {
      return Object.keys(shape).filter((k) => {
          return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
      });
  }
  const NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 3.4028234663852886e38],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
  };
  const BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__*/ BigInt("-9223372036854775808"), /* @__PURE__*/ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt("18446744073709551615")],
  };
  function pick(schema, mask) {
      const currDef = schema._zod.def;
      const def = mergeDefs(schema._zod.def, {
          get shape() {
              const newShape = {};
              for (const key in mask) {
                  if (!(key in currDef.shape)) {
                      throw new Error(`Unrecognized key: "${key}"`);
                  }
                  if (!mask[key])
                      continue;
                  newShape[key] = currDef.shape[key];
              }
              assignProp(this, "shape", newShape); // self-caching
              return newShape;
          },
          checks: [],
      });
      return clone(schema, def);
  }
  function omit(schema, mask) {
      const currDef = schema._zod.def;
      const def = mergeDefs(schema._zod.def, {
          get shape() {
              const newShape = { ...schema._zod.def.shape };
              for (const key in mask) {
                  if (!(key in currDef.shape)) {
                      throw new Error(`Unrecognized key: "${key}"`);
                  }
                  if (!mask[key])
                      continue;
                  delete newShape[key];
              }
              assignProp(this, "shape", newShape); // self-caching
              return newShape;
          },
          checks: [],
      });
      return clone(schema, def);
  }
  function extend(schema, shape) {
      if (!isPlainObject(shape)) {
          throw new Error("Invalid input to extend: expected a plain object");
      }
      const checks = schema._zod.def.checks;
      const hasChecks = checks && checks.length > 0;
      if (hasChecks) {
          throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
      }
      const def = mergeDefs(schema._zod.def, {
          get shape() {
              const _shape = { ...schema._zod.def.shape, ...shape };
              assignProp(this, "shape", _shape); // self-caching
              return _shape;
          },
          checks: [],
      });
      return clone(schema, def);
  }
  function safeExtend(schema, shape) {
      if (!isPlainObject(shape)) {
          throw new Error("Invalid input to safeExtend: expected a plain object");
      }
      const def = {
          ...schema._zod.def,
          get shape() {
              const _shape = { ...schema._zod.def.shape, ...shape };
              assignProp(this, "shape", _shape); // self-caching
              return _shape;
          },
          checks: schema._zod.def.checks,
      };
      return clone(schema, def);
  }
  function merge(a, b) {
      const def = mergeDefs(a._zod.def, {
          get shape() {
              const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
              assignProp(this, "shape", _shape); // self-caching
              return _shape;
          },
          get catchall() {
              return b._zod.def.catchall;
          },
          checks: [], // delete existing checks
      });
      return clone(a, def);
  }
  function partial(Class, schema, mask) {
      const def = mergeDefs(schema._zod.def, {
          get shape() {
              const oldShape = schema._zod.def.shape;
              const shape = { ...oldShape };
              if (mask) {
                  for (const key in mask) {
                      if (!(key in oldShape)) {
                          throw new Error(`Unrecognized key: "${key}"`);
                      }
                      if (!mask[key])
                          continue;
                      // if (oldShape[key]!._zod.optin === "optional") continue;
                      shape[key] = Class
                          ? new Class({
                              type: "optional",
                              innerType: oldShape[key],
                          })
                          : oldShape[key];
                  }
              }
              else {
                  for (const key in oldShape) {
                      // if (oldShape[key]!._zod.optin === "optional") continue;
                      shape[key] = Class
                          ? new Class({
                              type: "optional",
                              innerType: oldShape[key],
                          })
                          : oldShape[key];
                  }
              }
              assignProp(this, "shape", shape); // self-caching
              return shape;
          },
          checks: [],
      });
      return clone(schema, def);
  }
  function required(Class, schema, mask) {
      const def = mergeDefs(schema._zod.def, {
          get shape() {
              const oldShape = schema._zod.def.shape;
              const shape = { ...oldShape };
              if (mask) {
                  for (const key in mask) {
                      if (!(key in shape)) {
                          throw new Error(`Unrecognized key: "${key}"`);
                      }
                      if (!mask[key])
                          continue;
                      // overwrite with non-optional
                      shape[key] = new Class({
                          type: "nonoptional",
                          innerType: oldShape[key],
                      });
                  }
              }
              else {
                  for (const key in oldShape) {
                      // overwrite with non-optional
                      shape[key] = new Class({
                          type: "nonoptional",
                          innerType: oldShape[key],
                      });
                  }
              }
              assignProp(this, "shape", shape); // self-caching
              return shape;
          },
          checks: [],
      });
      return clone(schema, def);
  }
  // invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom
  function aborted(x, startIndex = 0) {
      if (x.aborted === true)
          return true;
      for (let i = startIndex; i < x.issues.length; i++) {
          if (x.issues[i]?.continue !== true) {
              return true;
          }
      }
      return false;
  }
  function prefixIssues(path, issues) {
      return issues.map((iss) => {
          var _a;
          (_a = iss).path ?? (_a.path = []);
          iss.path.unshift(path);
          return iss;
      });
  }
  function unwrapMessage(message) {
      return typeof message === "string" ? message : message?.message;
  }
  function finalizeIssue(iss, ctx, config) {
      const full = { ...iss, path: iss.path ?? [] };
      // for backwards compatibility
      if (!iss.message) {
          const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
              unwrapMessage(ctx?.error?.(iss)) ??
              unwrapMessage(config.customError?.(iss)) ??
              unwrapMessage(config.localeError?.(iss)) ??
              "Invalid input";
          full.message = message;
      }
      // delete (full as any).def;
      delete full.inst;
      delete full.continue;
      if (!ctx?.reportInput) {
          delete full.input;
      }
      return full;
  }
  function getSizableOrigin(input) {
      if (input instanceof Set)
          return "set";
      if (input instanceof Map)
          return "map";
      // @ts-ignore
      if (input instanceof File)
          return "file";
      return "unknown";
  }
  function getLengthableOrigin(input) {
      if (Array.isArray(input))
          return "array";
      if (typeof input === "string")
          return "string";
      return "unknown";
  }
  function issue(...args) {
      const [iss, input, inst] = args;
      if (typeof iss === "string") {
          return {
              message: iss,
              code: "custom",
              input,
              inst,
          };
      }
      return { ...iss };
  }
  function cleanEnum(obj) {
      return Object.entries(obj)
          .filter(([k, _]) => {
          // return true if NaN, meaning it's not a number, thus a string key
          return Number.isNaN(Number.parseInt(k, 10));
      })
          .map((el) => el[1]);
  }
  // Codec utility functions
  function base64ToUint8Array(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
  }
  function uint8ArrayToBase64(bytes) {
      let binaryString = "";
      for (let i = 0; i < bytes.length; i++) {
          binaryString += String.fromCharCode(bytes[i]);
      }
      return btoa(binaryString);
  }
  function base64urlToUint8Array(base64url) {
      const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
      const padding = "=".repeat((4 - (base64.length % 4)) % 4);
      return base64ToUint8Array(base64 + padding);
  }
  function uint8ArrayToBase64url(bytes) {
      return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  function hexToUint8Array(hex) {
      const cleanHex = hex.replace(/^0x/, "");
      if (cleanHex.length % 2 !== 0) {
          throw new Error("Invalid hex string length");
      }
      const bytes = new Uint8Array(cleanHex.length / 2);
      for (let i = 0; i < cleanHex.length; i += 2) {
          bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
      }
      return bytes;
  }
  function uint8ArrayToHex(bytes) {
      return Array.from(bytes)
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
  }
  // instanceof
  class Class {
      constructor(..._args) { }
  }

  var util = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BIGINT_FORMAT_RANGES: BIGINT_FORMAT_RANGES,
    Class: Class,
    NUMBER_FORMAT_RANGES: NUMBER_FORMAT_RANGES,
    aborted: aborted,
    allowsEval: allowsEval,
    assert: assert,
    assertEqual: assertEqual,
    assertIs: assertIs,
    assertNever: assertNever,
    assertNotEqual: assertNotEqual,
    assignProp: assignProp,
    base64ToUint8Array: base64ToUint8Array,
    base64urlToUint8Array: base64urlToUint8Array,
    cached: cached,
    captureStackTrace: captureStackTrace,
    cleanEnum: cleanEnum,
    cleanRegex: cleanRegex,
    clone: clone,
    cloneDef: cloneDef,
    createTransparentProxy: createTransparentProxy,
    defineLazy: defineLazy,
    esc: esc,
    escapeRegex: escapeRegex,
    extend: extend,
    finalizeIssue: finalizeIssue,
    floatSafeRemainder: floatSafeRemainder,
    getElementAtPath: getElementAtPath,
    getEnumValues: getEnumValues,
    getLengthableOrigin: getLengthableOrigin,
    getParsedType: getParsedType,
    getSizableOrigin: getSizableOrigin,
    hexToUint8Array: hexToUint8Array,
    isObject: isObject,
    isPlainObject: isPlainObject,
    issue: issue,
    joinValues: joinValues,
    jsonStringifyReplacer: jsonStringifyReplacer,
    merge: merge,
    mergeDefs: mergeDefs,
    normalizeParams: normalizeParams,
    nullish: nullish$1,
    numKeys: numKeys,
    objectClone: objectClone,
    omit: omit,
    optionalKeys: optionalKeys,
    partial: partial,
    pick: pick,
    prefixIssues: prefixIssues,
    primitiveTypes: primitiveTypes,
    promiseAllObject: promiseAllObject,
    propertyKeyTypes: propertyKeyTypes,
    randomString: randomString,
    required: required,
    safeExtend: safeExtend,
    shallowClone: shallowClone,
    stringifyPrimitive: stringifyPrimitive,
    uint8ArrayToBase64: uint8ArrayToBase64,
    uint8ArrayToBase64url: uint8ArrayToBase64url,
    uint8ArrayToHex: uint8ArrayToHex,
    unwrapMessage: unwrapMessage
  });

  const initializer$1 = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
          value: inst._zod,
          enumerable: false,
      });
      Object.defineProperty(inst, "issues", {
          value: def,
          enumerable: false,
      });
      inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
      Object.defineProperty(inst, "toString", {
          value: () => inst.message,
          enumerable: false,
      });
  };
  const $ZodError = $constructor("$ZodError", initializer$1);
  const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
  function flattenError(error, mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of error.issues) {
          if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
          }
          else {
              formErrors.push(mapper(sub));
          }
      }
      return { formErrors, fieldErrors };
  }
  function formatError(error, _mapper) {
      const mapper = _mapper ||
          function (issue) {
              return issue.message;
          };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
          for (const issue of error.issues) {
              if (issue.code === "invalid_union" && issue.errors.length) {
                  issue.errors.map((issues) => processError({ issues }));
              }
              else if (issue.code === "invalid_key") {
                  processError({ issues: issue.issues });
              }
              else if (issue.code === "invalid_element") {
                  processError({ issues: issue.issues });
              }
              else if (issue.path.length === 0) {
                  fieldErrors._errors.push(mapper(issue));
              }
              else {
                  let curr = fieldErrors;
                  let i = 0;
                  while (i < issue.path.length) {
                      const el = issue.path[i];
                      const terminal = i === issue.path.length - 1;
                      if (!terminal) {
                          curr[el] = curr[el] || { _errors: [] };
                      }
                      else {
                          curr[el] = curr[el] || { _errors: [] };
                          curr[el]._errors.push(mapper(issue));
                      }
                      curr = curr[el];
                      i++;
                  }
              }
          }
      };
      processError(error);
      return fieldErrors;
  }
  function treeifyError(error, _mapper) {
      const mapper = _mapper ||
          function (issue) {
              return issue.message;
          };
      const result = { errors: [] };
      const processError = (error, path = []) => {
          var _a, _b;
          for (const issue of error.issues) {
              if (issue.code === "invalid_union" && issue.errors.length) {
                  // regular union error
                  issue.errors.map((issues) => processError({ issues }, issue.path));
              }
              else if (issue.code === "invalid_key") {
                  processError({ issues: issue.issues }, issue.path);
              }
              else if (issue.code === "invalid_element") {
                  processError({ issues: issue.issues }, issue.path);
              }
              else {
                  const fullpath = [...path, ...issue.path];
                  if (fullpath.length === 0) {
                      result.errors.push(mapper(issue));
                      continue;
                  }
                  let curr = result;
                  let i = 0;
                  while (i < fullpath.length) {
                      const el = fullpath[i];
                      const terminal = i === fullpath.length - 1;
                      if (typeof el === "string") {
                          curr.properties ?? (curr.properties = {});
                          (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
                          curr = curr.properties[el];
                      }
                      else {
                          curr.items ?? (curr.items = []);
                          (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
                          curr = curr.items[el];
                      }
                      if (terminal) {
                          curr.errors.push(mapper(issue));
                      }
                      i++;
                  }
              }
          }
      };
      processError(error);
      return result;
  }
  /** Format a ZodError as a human-readable string in the following form.
   *
   * From
   *
   * ```ts
   * ZodError {
   *   issues: [
   *     {
   *       expected: 'string',
   *       code: 'invalid_type',
   *       path: [ 'username' ],
   *       message: 'Invalid input: expected string'
   *     },
   *     {
   *       expected: 'number',
   *       code: 'invalid_type',
   *       path: [ 'favoriteNumbers', 1 ],
   *       message: 'Invalid input: expected number'
   *     }
   *   ];
   * }
   * ```
   *
   * to
   *
   * ```
   * username
   *   âœ– Expected number, received string at "username
   * favoriteNumbers[0]
   *   âœ– Invalid input: expected number
   * ```
   */
  function toDotPath(_path) {
      const segs = [];
      const path = _path.map((seg) => (typeof seg === "object" ? seg.key : seg));
      for (const seg of path) {
          if (typeof seg === "number")
              segs.push(`[${seg}]`);
          else if (typeof seg === "symbol")
              segs.push(`[${JSON.stringify(String(seg))}]`);
          else if (/[^\w$]/.test(seg))
              segs.push(`[${JSON.stringify(seg)}]`);
          else {
              if (segs.length)
                  segs.push(".");
              segs.push(seg);
          }
      }
      return segs.join("");
  }
  function prettifyError(error) {
      const lines = [];
      // sort by path length
      const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
      // Process each issue
      for (const issue of issues) {
          lines.push(`âœ– ${issue.message}`);
          if (issue.path?.length)
              lines.push(`  â†’ at ${toDotPath(issue.path)}`);
      }
      // Convert Map to formatted string
      return lines.join("\n");
  }

  const _parse$1 = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
          throw new $ZodAsyncError();
      }
      if (result.issues.length) {
          const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
          captureStackTrace(e, _params?.callee);
          throw e;
      }
      return result.value;
  };
  const parse$1 = /* @__PURE__*/ _parse$1($ZodRealError);
  const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
          result = await result;
      if (result.issues.length) {
          const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
          captureStackTrace(e, params?.callee);
          throw e;
      }
      return result.value;
  };
  const parseAsync$1 = /* @__PURE__*/ _parseAsync($ZodRealError);
  const _safeParse = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
          throw new $ZodAsyncError();
      }
      return result.issues.length
          ? {
              success: false,
              error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
          }
          : { success: true, data: result.value };
  };
  const safeParse$1 = /* @__PURE__*/ _safeParse($ZodRealError);
  const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
          result = await result;
      return result.issues.length
          ? {
              success: false,
              error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
          }
          : { success: true, data: result.value };
  };
  const safeParseAsync$1 = /* @__PURE__*/ _safeParseAsync($ZodRealError);
  const _encode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parse$1(_Err)(schema, value, ctx);
  };
  const encode$1 = /* @__PURE__*/ _encode($ZodRealError);
  const _decode = (_Err) => (schema, value, _ctx) => {
      return _parse$1(_Err)(schema, value, _ctx);
  };
  const decode$1 = /* @__PURE__*/ _decode($ZodRealError);
  const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parseAsync(_Err)(schema, value, ctx);
  };
  const encodeAsync$1 = /* @__PURE__*/ _encodeAsync($ZodRealError);
  const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
      return _parseAsync(_Err)(schema, value, _ctx);
  };
  const decodeAsync$1 = /* @__PURE__*/ _decodeAsync($ZodRealError);
  const _safeEncode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParse(_Err)(schema, value, ctx);
  };
  const safeEncode$1 = /* @__PURE__*/ _safeEncode($ZodRealError);
  const _safeDecode = (_Err) => (schema, value, _ctx) => {
      return _safeParse(_Err)(schema, value, _ctx);
  };
  const safeDecode$1 = /* @__PURE__*/ _safeDecode($ZodRealError);
  const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParseAsync(_Err)(schema, value, ctx);
  };
  const safeEncodeAsync$1 = /* @__PURE__*/ _safeEncodeAsync($ZodRealError);
  const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
      return _safeParseAsync(_Err)(schema, value, _ctx);
  };
  const safeDecodeAsync$1 = /* @__PURE__*/ _safeDecodeAsync($ZodRealError);

  const cuid$1 = /^[cC][^\s-]{8,}$/;
  const cuid2$1 = /^[0-9a-z]+$/;
  const ulid$1 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  const xid$1 = /^[0-9a-vA-V]{20}$/;
  const ksuid$1 = /^[A-Za-z0-9]{27}$/;
  const nanoid$1 = /^[a-zA-Z0-9_-]{21}$/;
  /** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
  const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  /** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */
  const extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  /** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
  const guid$1 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  /** Returns a regex for validating an RFC 9562/4122 UUID.
   *
   * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
  const uuid$1 = (version) => {
      if (!version)
          return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
  };
  const uuid4 = /*@__PURE__*/ uuid$1(4);
  const uuid6 = /*@__PURE__*/ uuid$1(6);
  const uuid7 = /*@__PURE__*/ uuid$1(7);
  /** Practical email validation */
  const email$1 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  /** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */
  const html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  /** The classic emailregex.com regex for RFC 5322-compliant emails */
  const rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  /** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */
  const unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  const idnEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  const browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  // from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
  const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  function emoji$1() {
      return new RegExp(_emoji$1, "u");
  }
  const ipv4$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv6$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
  const cidrv4$1 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  const cidrv6$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  // https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
  const base64$1 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  const base64url$1 = /^[A-Za-z0-9_-]*$/;
  // based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
  // export const hostname: RegExp = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
  const hostname$1 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
  const domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
  // https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)
  const e164$1 = /^\+(?:[0-9]){6,14}[0-9]$/;
  // const dateSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
  const date$3 = /*@__PURE__*/ new RegExp(`^${dateSource}$`);
  function timeSource(args) {
      const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
      const regex = typeof args.precision === "number"
          ? args.precision === -1
              ? `${hhmm}`
              : args.precision === 0
                  ? `${hhmm}:[0-5]\\d`
                  : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
          : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
      return regex;
  }
  function time$1(args) {
      return new RegExp(`^${timeSource(args)}$`);
  }
  // Adapted from https://stackoverflow.com/a/3143231
  function datetime$1(args) {
      const time = timeSource({ precision: args.precision });
      const opts = ["Z"];
      if (args.local)
          opts.push("");
      // if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
      if (args.offset)
          opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
      const timeRegex = `${time}(?:${opts.join("|")})`;
      return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
  }
  const string$2 = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
  };
  const bigint$2 = /^\d+n?$/;
  const integer = /^\d+$/;
  const number$2 = /^-?\d+(?:\.\d+)?/i;
  const boolean$2 = /true|false/i;
  const _null$2 = /null/i;
  const _undefined$2 = /undefined/i;
  // regex for string with no uppercase letters
  const lowercase = /^[^A-Z]*$/;
  // regex for string with no lowercase letters
  const uppercase = /^[^a-z]*$/;
  // regex for hexadecimal strings (any length)
  const hex$1 = /^[0-9a-fA-F]*$/;
  // Hash regexes for different algorithms and encodings
  // Helper function to create base64 regex with exact length and padding
  function fixedBase64(bodyLength, padding) {
      return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
  }
  // Helper function to create base64url regex with exact length (no padding)
  function fixedBase64url(length) {
      return new RegExp(`^[A-Za-z0-9-_]{${length}}$`);
  }
  // MD5 (16 bytes): base64 = 24 chars total (22 + "==")
  const md5_hex = /^[0-9a-fA-F]{32}$/;
  const md5_base64 = /*@__PURE__*/ fixedBase64(22, "==");
  const md5_base64url = /*@__PURE__*/ fixedBase64url(22);
  // SHA1 (20 bytes): base64 = 28 chars total (27 + "=")
  const sha1_hex = /^[0-9a-fA-F]{40}$/;
  const sha1_base64 = /*@__PURE__*/ fixedBase64(27, "=");
  const sha1_base64url = /*@__PURE__*/ fixedBase64url(27);
  // SHA256 (32 bytes): base64 = 44 chars total (43 + "=")
  const sha256_hex = /^[0-9a-fA-F]{64}$/;
  const sha256_base64 = /*@__PURE__*/ fixedBase64(43, "=");
  const sha256_base64url = /*@__PURE__*/ fixedBase64url(43);
  // SHA384 (48 bytes): base64 = 64 chars total (no padding)
  const sha384_hex = /^[0-9a-fA-F]{96}$/;
  const sha384_base64 = /*@__PURE__*/ fixedBase64(64, "");
  const sha384_base64url = /*@__PURE__*/ fixedBase64url(64);
  // SHA512 (64 bytes): base64 = 88 chars total (86 + "==")
  const sha512_hex = /^[0-9a-fA-F]{128}$/;
  const sha512_base64 = /*@__PURE__*/ fixedBase64(86, "==");
  const sha512_base64url = /*@__PURE__*/ fixedBase64url(86);

  var regexes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base64: base64$1,
    base64url: base64url$1,
    bigint: bigint$2,
    boolean: boolean$2,
    browserEmail: browserEmail,
    cidrv4: cidrv4$1,
    cidrv6: cidrv6$1,
    cuid: cuid$1,
    cuid2: cuid2$1,
    date: date$3,
    datetime: datetime$1,
    domain: domain,
    duration: duration$1,
    e164: e164$1,
    email: email$1,
    emoji: emoji$1,
    extendedDuration: extendedDuration,
    guid: guid$1,
    hex: hex$1,
    hostname: hostname$1,
    html5Email: html5Email,
    idnEmail: idnEmail,
    integer: integer,
    ipv4: ipv4$1,
    ipv6: ipv6$1,
    ksuid: ksuid$1,
    lowercase: lowercase,
    md5_base64: md5_base64,
    md5_base64url: md5_base64url,
    md5_hex: md5_hex,
    nanoid: nanoid$1,
    null: _null$2,
    number: number$2,
    rfc5322Email: rfc5322Email,
    sha1_base64: sha1_base64,
    sha1_base64url: sha1_base64url,
    sha1_hex: sha1_hex,
    sha256_base64: sha256_base64,
    sha256_base64url: sha256_base64url,
    sha256_hex: sha256_hex,
    sha384_base64: sha384_base64,
    sha384_base64url: sha384_base64url,
    sha384_hex: sha384_hex,
    sha512_base64: sha512_base64,
    sha512_base64url: sha512_base64url,
    sha512_hex: sha512_hex,
    string: string$2,
    time: time$1,
    ulid: ulid$1,
    undefined: _undefined$2,
    unicodeEmail: unicodeEmail,
    uppercase: uppercase,
    uuid: uuid$1,
    uuid4: uuid4,
    uuid6: uuid6,
    uuid7: uuid7,
    xid: xid$1
  });

  // import { $ZodType } from "./schemas.js";
  const $ZodCheck = /*@__PURE__*/ $constructor("$ZodCheck", (inst, def) => {
      var _a;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a = inst._zod).onattach ?? (_a.onattach = []);
  });
  const numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date",
  };
  const $ZodCheckLessThan = /*@__PURE__*/ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
          if (def.value < curr) {
              if (def.inclusive)
                  bag.maximum = def.value;
              else
                  bag.exclusiveMaximum = def.value;
          }
      });
      inst._zod.check = (payload) => {
          if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
              return;
          }
          payload.issues.push({
              origin,
              code: "too_big",
              maximum: def.value,
              input: payload.value,
              inclusive: def.inclusive,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckGreaterThan = /*@__PURE__*/ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
          if (def.value > curr) {
              if (def.inclusive)
                  bag.minimum = def.value;
              else
                  bag.exclusiveMinimum = def.value;
          }
      });
      inst._zod.check = (payload) => {
          if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
              return;
          }
          payload.issues.push({
              origin,
              code: "too_small",
              minimum: def.value,
              input: payload.value,
              inclusive: def.inclusive,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckMultipleOf = 
  /*@__PURE__*/ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst) => {
          var _a;
          (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
          if (typeof payload.value !== typeof def.value)
              throw new Error("Cannot mix number and bigint in multiple_of check.");
          const isMultiple = typeof payload.value === "bigint"
              ? payload.value % def.value === BigInt(0)
              : floatSafeRemainder(payload.value, def.value) === 0;
          if (isMultiple)
              return;
          payload.issues.push({
              origin: typeof payload.value,
              code: "not_multiple_of",
              divisor: def.value,
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckNumberFormat = /*@__PURE__*/ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck.init(inst, def); // no format checks
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.format = def.format;
          bag.minimum = minimum;
          bag.maximum = maximum;
          if (isInt)
              bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
          const input = payload.value;
          if (isInt) {
              if (!Number.isInteger(input)) {
                  // invalid_format issue
                  // payload.issues.push({
                  //   expected: def.format,
                  //   format: def.format,
                  //   code: "invalid_format",
                  //   input,
                  //   inst,
                  // });
                  // invalid_type issue
                  payload.issues.push({
                      expected: origin,
                      format: def.format,
                      code: "invalid_type",
                      continue: false,
                      input,
                      inst,
                  });
                  return;
                  // not_multiple_of issue
                  // payload.issues.push({
                  //   code: "not_multiple_of",
                  //   origin: "number",
                  //   input,
                  //   inst,
                  //   divisor: 1,
                  // });
              }
              if (!Number.isSafeInteger(input)) {
                  if (input > 0) {
                      // too_big
                      payload.issues.push({
                          input,
                          code: "too_big",
                          maximum: Number.MAX_SAFE_INTEGER,
                          note: "Integers must be within the safe integer range.",
                          inst,
                          origin,
                          continue: !def.abort,
                      });
                  }
                  else {
                      // too_small
                      payload.issues.push({
                          input,
                          code: "too_small",
                          minimum: Number.MIN_SAFE_INTEGER,
                          note: "Integers must be within the safe integer range.",
                          inst,
                          origin,
                          continue: !def.abort,
                      });
                  }
                  return;
              }
          }
          if (input < minimum) {
              payload.issues.push({
                  origin: "number",
                  input,
                  code: "too_small",
                  minimum,
                  inclusive: true,
                  inst,
                  continue: !def.abort,
              });
          }
          if (input > maximum) {
              payload.issues.push({
                  origin: "number",
                  input,
                  code: "too_big",
                  maximum,
                  inst,
              });
          }
      };
  });
  const $ZodCheckBigIntFormat = /*@__PURE__*/ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def); // no format checks
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.format = def.format;
          bag.minimum = minimum;
          bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
          const input = payload.value;
          if (input < minimum) {
              payload.issues.push({
                  origin: "bigint",
                  input,
                  code: "too_small",
                  minimum: minimum,
                  inclusive: true,
                  inst,
                  continue: !def.abort,
              });
          }
          if (input > maximum) {
              payload.issues.push({
                  origin: "bigint",
                  input,
                  code: "too_big",
                  maximum,
                  inst,
              });
          }
      };
  });
  const $ZodCheckMaxSize = /*@__PURE__*/ $constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
          const val = payload.value;
          return !nullish$1(val) && val.size !== undefined;
      });
      inst._zod.onattach.push((inst) => {
          const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
          if (def.maximum < curr)
              inst._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
          const input = payload.value;
          const size = input.size;
          if (size <= def.maximum)
              return;
          payload.issues.push({
              origin: getSizableOrigin(input),
              code: "too_big",
              maximum: def.maximum,
              inclusive: true,
              input,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckMinSize = /*@__PURE__*/ $constructor("$ZodCheckMinSize", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
          const val = payload.value;
          return !nullish$1(val) && val.size !== undefined;
      });
      inst._zod.onattach.push((inst) => {
          const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
          if (def.minimum > curr)
              inst._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
          const input = payload.value;
          const size = input.size;
          if (size >= def.minimum)
              return;
          payload.issues.push({
              origin: getSizableOrigin(input),
              code: "too_small",
              minimum: def.minimum,
              inclusive: true,
              input,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckSizeEquals = /*@__PURE__*/ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
          const val = payload.value;
          return !nullish$1(val) && val.size !== undefined;
      });
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.minimum = def.size;
          bag.maximum = def.size;
          bag.size = def.size;
      });
      inst._zod.check = (payload) => {
          const input = payload.value;
          const size = input.size;
          if (size === def.size)
              return;
          const tooBig = size > def.size;
          payload.issues.push({
              origin: getSizableOrigin(input),
              ...(tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size }),
              inclusive: true,
              exact: true,
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckMaxLength = /*@__PURE__*/ $constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
          const val = payload.value;
          return !nullish$1(val) && val.length !== undefined;
      });
      inst._zod.onattach.push((inst) => {
          const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
          if (def.maximum < curr)
              inst._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
          const input = payload.value;
          const length = input.length;
          if (length <= def.maximum)
              return;
          const origin = getLengthableOrigin(input);
          payload.issues.push({
              origin,
              code: "too_big",
              maximum: def.maximum,
              inclusive: true,
              input,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckMinLength = /*@__PURE__*/ $constructor("$ZodCheckMinLength", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
          const val = payload.value;
          return !nullish$1(val) && val.length !== undefined;
      });
      inst._zod.onattach.push((inst) => {
          const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
          if (def.minimum > curr)
              inst._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
          const input = payload.value;
          const length = input.length;
          if (length >= def.minimum)
              return;
          const origin = getLengthableOrigin(input);
          payload.issues.push({
              origin,
              code: "too_small",
              minimum: def.minimum,
              inclusive: true,
              input,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckLengthEquals = /*@__PURE__*/ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a;
      $ZodCheck.init(inst, def);
      (_a = inst._zod.def).when ?? (_a.when = (payload) => {
          const val = payload.value;
          return !nullish$1(val) && val.length !== undefined;
      });
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.minimum = def.length;
          bag.maximum = def.length;
          bag.length = def.length;
      });
      inst._zod.check = (payload) => {
          const input = payload.value;
          const length = input.length;
          if (length === def.length)
              return;
          const origin = getLengthableOrigin(input);
          const tooBig = length > def.length;
          payload.issues.push({
              origin,
              ...(tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length }),
              inclusive: true,
              exact: true,
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckStringFormat = /*@__PURE__*/ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a, _b;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.format = def.format;
          if (def.pattern) {
              bag.patterns ?? (bag.patterns = new Set());
              bag.patterns.add(def.pattern);
          }
      });
      if (def.pattern)
          (_a = inst._zod).check ?? (_a.check = (payload) => {
              def.pattern.lastIndex = 0;
              if (def.pattern.test(payload.value))
                  return;
              payload.issues.push({
                  origin: "string",
                  code: "invalid_format",
                  format: def.format,
                  input: payload.value,
                  ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
                  inst,
                  continue: !def.abort,
              });
          });
      else
          (_b = inst._zod).check ?? (_b.check = () => { });
  });
  const $ZodCheckRegex = /*@__PURE__*/ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
              return;
          payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "regex",
              input: payload.value,
              pattern: def.pattern.toString(),
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckLowerCase = /*@__PURE__*/ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
  });
  const $ZodCheckUpperCase = /*@__PURE__*/ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
  });
  const $ZodCheckIncludes = /*@__PURE__*/ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const escapedRegex = escapeRegex(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.patterns ?? (bag.patterns = new Set());
          bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
          if (payload.value.includes(def.includes, def.position))
              return;
          payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "includes",
              includes: def.includes,
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckStartsWith = /*@__PURE__*/ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.patterns ?? (bag.patterns = new Set());
          bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
          if (payload.value.startsWith(def.prefix))
              return;
          payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "starts_with",
              prefix: def.prefix,
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckEndsWith = /*@__PURE__*/ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.patterns ?? (bag.patterns = new Set());
          bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
          if (payload.value.endsWith(def.suffix))
              return;
          payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "ends_with",
              suffix: def.suffix,
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  ///////////////////////////////////
  /////    $ZodCheckProperty    /////
  ///////////////////////////////////
  function handleCheckPropertyResult(result, payload, property) {
      if (result.issues.length) {
          payload.issues.push(...prefixIssues(property, result.issues));
      }
  }
  const $ZodCheckProperty = /*@__PURE__*/ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
          const result = def.schema._zod.run({
              value: payload.value[def.property],
              issues: [],
          }, {});
          if (result instanceof Promise) {
              return result.then((result) => handleCheckPropertyResult(result, payload, def.property));
          }
          handleCheckPropertyResult(result, payload, def.property);
          return;
      };
  });
  const $ZodCheckMimeType = /*@__PURE__*/ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst) => {
          inst._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
          if (mimeSet.has(payload.value.type))
              return;
          payload.issues.push({
              code: "invalid_value",
              values: def.mime,
              input: payload.value.type,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCheckOverwrite = /*@__PURE__*/ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
          payload.value = def.tx(payload.value);
      };
  });

  class Doc {
      constructor(args = []) {
          this.content = [];
          this.indent = 0;
          if (this)
              this.args = args;
      }
      indented(fn) {
          this.indent += 1;
          fn(this);
          this.indent -= 1;
      }
      write(arg) {
          if (typeof arg === "function") {
              arg(this, { execution: "sync" });
              arg(this, { execution: "async" });
              return;
          }
          const content = arg;
          const lines = content.split("\n").filter((x) => x);
          const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
          const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
          for (const line of dedented) {
              this.content.push(line);
          }
      }
      compile() {
          const F = Function;
          const args = this?.args;
          const content = this?.content ?? [``];
          const lines = [...content.map((x) => `  ${x}`)];
          // console.log(lines.join("\n"));
          return new F(...args, lines.join("\n"));
      }
  }

  const version = {
      major: 4,
      minor: 1,
      patch: 5,
  };

  const $ZodType = /*@__PURE__*/ $constructor("$ZodType", (inst, def) => {
      var _a;
      inst ?? (inst = {});
      inst._zod.def = def; // set _def property
      inst._zod.bag = inst._zod.bag || {}; // initialize _bag object
      inst._zod.version = version;
      const checks = [...(inst._zod.def.checks ?? [])];
      // if inst is itself a checks.$ZodCheck, run it as a check
      if (inst._zod.traits.has("$ZodCheck")) {
          checks.unshift(inst);
      }
      for (const ch of checks) {
          for (const fn of ch._zod.onattach) {
              fn(inst);
          }
      }
      if (checks.length === 0) {
          // deferred initializer
          // inst._zod.parse is not yet defined
          (_a = inst._zod).deferred ?? (_a.deferred = []);
          inst._zod.deferred?.push(() => {
              inst._zod.run = inst._zod.parse;
          });
      }
      else {
          const runChecks = (payload, checks, ctx) => {
              let isAborted = aborted(payload);
              let asyncResult;
              for (const ch of checks) {
                  if (ch._zod.def.when) {
                      const shouldRun = ch._zod.def.when(payload);
                      if (!shouldRun)
                          continue;
                  }
                  else if (isAborted) {
                      continue;
                  }
                  const currLen = payload.issues.length;
                  const _ = ch._zod.check(payload);
                  if (_ instanceof Promise && ctx?.async === false) {
                      throw new $ZodAsyncError();
                  }
                  if (asyncResult || _ instanceof Promise) {
                      asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                          await _;
                          const nextLen = payload.issues.length;
                          if (nextLen === currLen)
                              return;
                          if (!isAborted)
                              isAborted = aborted(payload, currLen);
                      });
                  }
                  else {
                      const nextLen = payload.issues.length;
                      if (nextLen === currLen)
                          continue;
                      if (!isAborted)
                          isAborted = aborted(payload, currLen);
                  }
              }
              if (asyncResult) {
                  return asyncResult.then(() => {
                      return payload;
                  });
              }
              return payload;
          };
          // const handleChecksResult = (
          //   checkResult: ParsePayload,
          //   originalResult: ParsePayload,
          //   ctx: ParseContextInternal
          // ): util.MaybeAsync<ParsePayload> => {
          //   // if the checks mutated the value && there are no issues, re-parse the result
          //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)
          //     return inst._zod.parse(checkResult, ctx);
          //   return originalResult;
          // };
          const handleCanaryResult = (canary, payload, ctx) => {
              // abort if the canary is aborted
              if (aborted(canary)) {
                  canary.aborted = true;
                  return canary;
              }
              // run checks first, then
              const checkResult = runChecks(payload, checks, ctx);
              if (checkResult instanceof Promise) {
                  if (ctx.async === false)
                      throw new $ZodAsyncError();
                  return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));
              }
              return inst._zod.parse(checkResult, ctx);
          };
          inst._zod.run = (payload, ctx) => {
              if (ctx.skipChecks) {
                  return inst._zod.parse(payload, ctx);
              }
              if (ctx.direction === "backward") {
                  // run canary
                  // initial pass (no checks)
                  const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
                  if (canary instanceof Promise) {
                      return canary.then((canary) => {
                          return handleCanaryResult(canary, payload, ctx);
                      });
                  }
                  return handleCanaryResult(canary, payload, ctx);
              }
              // forward
              const result = inst._zod.parse(payload, ctx);
              if (result instanceof Promise) {
                  if (ctx.async === false)
                      throw new $ZodAsyncError();
                  return result.then((result) => runChecks(result, checks, ctx));
              }
              return runChecks(result, checks, ctx);
          };
      }
      inst["~standard"] = {
          validate: (value) => {
              try {
                  const r = safeParse$1(inst, value);
                  return r.success ? { value: r.data } : { issues: r.error?.issues };
              }
              catch (_) {
                  return safeParseAsync$1(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));
              }
          },
          vendor: "zod",
          version: 1,
      };
  });
  const $ZodString = /*@__PURE__*/ $constructor("$ZodString", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? string$2(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
          if (def.coerce)
              try {
                  payload.value = String(payload.value);
              }
              catch (_) { }
          if (typeof payload.value === "string")
              return payload;
          payload.issues.push({
              expected: "string",
              code: "invalid_type",
              input: payload.value,
              inst,
          });
          return payload;
      };
  });
  const $ZodStringFormat = /*@__PURE__*/ $constructor("$ZodStringFormat", (inst, def) => {
      // check initialization must come first
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
  });
  const $ZodGUID = /*@__PURE__*/ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodUUID = /*@__PURE__*/ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
          const versionMap = {
              v1: 1,
              v2: 2,
              v3: 3,
              v4: 4,
              v5: 5,
              v6: 6,
              v7: 7,
              v8: 8,
          };
          const v = versionMap[def.version];
          if (v === undefined)
              throw new Error(`Invalid UUID version: "${def.version}"`);
          def.pattern ?? (def.pattern = uuid$1(v));
      }
      else
          def.pattern ?? (def.pattern = uuid$1());
      $ZodStringFormat.init(inst, def);
  });
  const $ZodEmail = /*@__PURE__*/ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodURL = /*@__PURE__*/ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
          try {
              // Trim whitespace from input
              const trimmed = payload.value.trim();
              // @ts-ignore
              const url = new URL(trimmed);
              if (def.hostname) {
                  def.hostname.lastIndex = 0;
                  if (!def.hostname.test(url.hostname)) {
                      payload.issues.push({
                          code: "invalid_format",
                          format: "url",
                          note: "Invalid hostname",
                          pattern: hostname$1.source,
                          input: payload.value,
                          inst,
                          continue: !def.abort,
                      });
                  }
              }
              if (def.protocol) {
                  def.protocol.lastIndex = 0;
                  if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
                      payload.issues.push({
                          code: "invalid_format",
                          format: "url",
                          note: "Invalid protocol",
                          pattern: def.protocol.source,
                          input: payload.value,
                          inst,
                          continue: !def.abort,
                      });
                  }
              }
              // Set the output value based on normalize flag
              if (def.normalize) {
                  // Use normalized URL
                  payload.value = url.href;
              }
              else {
                  // Preserve the original input (trimmed)
                  payload.value = trimmed;
              }
              return;
          }
          catch (_) {
              payload.issues.push({
                  code: "invalid_format",
                  format: "url",
                  input: payload.value,
                  inst,
                  continue: !def.abort,
              });
          }
      };
  });
  const $ZodEmoji = /*@__PURE__*/ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji$1());
      $ZodStringFormat.init(inst, def);
  });
  const $ZodNanoID = /*@__PURE__*/ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodCUID = /*@__PURE__*/ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodCUID2 = /*@__PURE__*/ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodULID = /*@__PURE__*/ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodXID = /*@__PURE__*/ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodKSUID = /*@__PURE__*/ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodISODateTime = /*@__PURE__*/ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime$1(def));
      $ZodStringFormat.init(inst, def);
  });
  const $ZodISODate = /*@__PURE__*/ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date$3);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodISOTime = /*@__PURE__*/ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time$1(def));
      $ZodStringFormat.init(inst, def);
  });
  const $ZodISODuration = /*@__PURE__*/ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodIPv4 = /*@__PURE__*/ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.format = `ipv4`;
      });
  });
  const $ZodIPv6 = /*@__PURE__*/ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst) => {
          const bag = inst._zod.bag;
          bag.format = `ipv6`;
      });
      inst._zod.check = (payload) => {
          try {
              // @ts-ignore
              new URL(`http://[${payload.value}]`);
              // return;
          }
          catch {
              payload.issues.push({
                  code: "invalid_format",
                  format: "ipv6",
                  input: payload.value,
                  inst,
                  continue: !def.abort,
              });
          }
      };
  });
  const $ZodCIDRv4 = /*@__PURE__*/ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4$1);
      $ZodStringFormat.init(inst, def);
  });
  const $ZodCIDRv6 = /*@__PURE__*/ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6$1); // not used for validation
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
          const [address, prefix] = payload.value.split("/");
          try {
              if (!prefix)
                  throw new Error();
              const prefixNum = Number(prefix);
              if (`${prefixNum}` !== prefix)
                  throw new Error();
              if (prefixNum < 0 || prefixNum > 128)
                  throw new Error();
              // @ts-ignore
              new URL(`http://[${address}]`);
          }
          catch {
              payload.issues.push({
                  code: "invalid_format",
                  format: "cidrv6",
                  input: payload.value,
                  inst,
                  continue: !def.abort,
              });
          }
      };
  });
  //////////////////////////////   ZodBase64   //////////////////////////////
  function isValidBase64(data) {
      if (data === "")
          return true;
      if (data.length % 4 !== 0)
          return false;
      try {
          // @ts-ignore
          atob(data);
          return true;
      }
      catch {
          return false;
      }
  }
  const $ZodBase64 = /*@__PURE__*/ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base64$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst) => {
          inst._zod.bag.contentEncoding = "base64";
      });
      inst._zod.check = (payload) => {
          if (isValidBase64(payload.value))
              return;
          payload.issues.push({
              code: "invalid_format",
              format: "base64",
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  //////////////////////////////   ZodBase64   //////////////////////////////
  function isValidBase64URL(data) {
      if (!base64url$1.test(data))
          return false;
      const base64 = data.replace(/[-_]/g, (c) => (c === "-" ? "+" : "/"));
      const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, "=");
      return isValidBase64(padded);
  }
  const $ZodBase64URL = /*@__PURE__*/ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url$1);
      $ZodStringFormat.init(inst, def);
      inst._zod.onattach.push((inst) => {
          inst._zod.bag.contentEncoding = "base64url";
      });
      inst._zod.check = (payload) => {
          if (isValidBase64URL(payload.value))
              return;
          payload.issues.push({
              code: "invalid_format",
              format: "base64url",
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodE164 = /*@__PURE__*/ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164$1);
      $ZodStringFormat.init(inst, def);
  });
  //////////////////////////////   ZodJWT   //////////////////////////////
  function isValidJWT(token, algorithm = null) {
      try {
          const tokensParts = token.split(".");
          if (tokensParts.length !== 3)
              return false;
          const [header] = tokensParts;
          if (!header)
              return false;
          // @ts-ignore
          const parsedHeader = JSON.parse(atob(header));
          if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
              return false;
          if (!parsedHeader.alg)
              return false;
          if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
              return false;
          return true;
      }
      catch {
          return false;
      }
  }
  const $ZodJWT = /*@__PURE__*/ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
          if (isValidJWT(payload.value, def.alg))
              return;
          payload.issues.push({
              code: "invalid_format",
              format: "jwt",
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodCustomStringFormat = /*@__PURE__*/ $constructor("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
          if (def.fn(payload.value))
              return;
          payload.issues.push({
              code: "invalid_format",
              format: def.format,
              input: payload.value,
              inst,
              continue: !def.abort,
          });
      };
  });
  const $ZodNumber = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number$2;
      inst._zod.parse = (payload, _ctx) => {
          if (def.coerce)
              try {
                  payload.value = Number(payload.value);
              }
              catch (_) { }
          const input = payload.value;
          if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
              return payload;
          }
          const received = typeof input === "number"
              ? Number.isNaN(input)
                  ? "NaN"
                  : !Number.isFinite(input)
                      ? "Infinity"
                      : undefined
              : undefined;
          payload.issues.push({
              expected: "number",
              code: "invalid_type",
              input,
              inst,
              ...(received ? { received } : {}),
          });
          return payload;
      };
  });
  const $ZodNumberFormat = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def); // no format checksp
  });
  const $ZodBoolean = /*@__PURE__*/ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean$2;
      inst._zod.parse = (payload, _ctx) => {
          if (def.coerce)
              try {
                  payload.value = Boolean(payload.value);
              }
              catch (_) { }
          const input = payload.value;
          if (typeof input === "boolean")
              return payload;
          payload.issues.push({
              expected: "boolean",
              code: "invalid_type",
              input,
              inst,
          });
          return payload;
      };
  });
  const $ZodBigInt = /*@__PURE__*/ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint$2;
      inst._zod.parse = (payload, _ctx) => {
          if (def.coerce)
              try {
                  payload.value = BigInt(payload.value);
              }
              catch (_) { }
          if (typeof payload.value === "bigint")
              return payload;
          payload.issues.push({
              expected: "bigint",
              code: "invalid_type",
              input: payload.value,
              inst,
          });
          return payload;
      };
  });
  const $ZodBigIntFormat = /*@__PURE__*/ $constructor("$ZodBigInt", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def); // no format checks
  });
  const $ZodSymbol = /*@__PURE__*/ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (typeof input === "symbol")
              return payload;
          payload.issues.push({
              expected: "symbol",
              code: "invalid_type",
              input,
              inst,
          });
          return payload;
      };
  });
  const $ZodUndefined = /*@__PURE__*/ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined$2;
      inst._zod.values = new Set([undefined]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (typeof input === "undefined")
              return payload;
          payload.issues.push({
              expected: "undefined",
              code: "invalid_type",
              input,
              inst,
          });
          return payload;
      };
  });
  const $ZodNull = /*@__PURE__*/ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null$2;
      inst._zod.values = new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (input === null)
              return payload;
          payload.issues.push({
              expected: "null",
              code: "invalid_type",
              input,
              inst,
          });
          return payload;
      };
  });
  const $ZodAny = /*@__PURE__*/ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
  });
  const $ZodUnknown = /*@__PURE__*/ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
  });
  const $ZodNever = /*@__PURE__*/ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
          payload.issues.push({
              expected: "never",
              code: "invalid_type",
              input: payload.value,
              inst,
          });
          return payload;
      };
  });
  const $ZodVoid = /*@__PURE__*/ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (typeof input === "undefined")
              return payload;
          payload.issues.push({
              expected: "void",
              code: "invalid_type",
              input,
              inst,
          });
          return payload;
      };
  });
  const $ZodDate = /*@__PURE__*/ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
          if (def.coerce) {
              try {
                  payload.value = new Date(payload.value);
              }
              catch (_err) { }
          }
          const input = payload.value;
          const isDate = input instanceof Date;
          const isValidDate = isDate && !Number.isNaN(input.getTime());
          if (isValidDate)
              return payload;
          payload.issues.push({
              expected: "date",
              code: "invalid_type",
              input,
              ...(isDate ? { received: "Invalid Date" } : {}),
              inst,
          });
          return payload;
      };
  });
  function handleArrayResult(result, final, index) {
      if (result.issues.length) {
          final.issues.push(...prefixIssues(index, result.issues));
      }
      final.value[index] = result.value;
  }
  const $ZodArray = /*@__PURE__*/ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!Array.isArray(input)) {
              payload.issues.push({
                  expected: "array",
                  code: "invalid_type",
                  input,
                  inst,
              });
              return payload;
          }
          payload.value = Array(input.length);
          const proms = [];
          for (let i = 0; i < input.length; i++) {
              const item = input[i];
              const result = def.element._zod.run({
                  value: item,
                  issues: [],
              }, ctx);
              if (result instanceof Promise) {
                  proms.push(result.then((result) => handleArrayResult(result, payload, i)));
              }
              else {
                  handleArrayResult(result, payload, i);
              }
          }
          if (proms.length) {
              return Promise.all(proms).then(() => payload);
          }
          return payload; //handleArrayResultsAsync(parseResults, final);
      };
  });
  function handlePropertyResult(result, final, key, input) {
      if (result.issues.length) {
          final.issues.push(...prefixIssues(key, result.issues));
      }
      if (result.value === undefined) {
          if (key in input) {
              final.value[key] = undefined;
          }
      }
      else {
          final.value[key] = result.value;
      }
  }
  function normalizeDef(def) {
      const keys = Object.keys(def.shape);
      for (const k of keys) {
          if (!def.shape[k]._zod.traits.has("$ZodType")) {
              throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
          }
      }
      const okeys = optionalKeys(def.shape);
      return {
          ...def,
          keys,
          keySet: new Set(keys),
          numKeys: keys.length,
          optionalKeys: new Set(okeys),
      };
  }
  function handleCatchall(proms, input, payload, ctx, def, inst) {
      const unrecognized = [];
      // iterate over input keys
      const keySet = def.keySet;
      const _catchall = def.catchall._zod;
      const t = _catchall.def.type;
      for (const key of Object.keys(input)) {
          if (keySet.has(key))
              continue;
          if (t === "never") {
              unrecognized.push(key);
              continue;
          }
          const r = _catchall.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
              proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
          }
          else {
              handlePropertyResult(r, payload, key, input);
          }
      }
      if (unrecognized.length) {
          payload.issues.push({
              code: "unrecognized_keys",
              keys: unrecognized,
              input,
              inst,
          });
      }
      if (!proms.length)
          return payload;
      return Promise.all(proms).then(() => {
          return payload;
      });
  }
  const $ZodObject = /*@__PURE__*/ $constructor("$ZodObject", (inst, def) => {
      // requires cast because technically $ZodObject doesn't extend
      $ZodType.init(inst, def);
      const _normalized = cached(() => normalizeDef(def));
      defineLazy(inst._zod, "propValues", () => {
          const shape = def.shape;
          const propValues = {};
          for (const key in shape) {
              const field = shape[key]._zod;
              if (field.values) {
                  propValues[key] ?? (propValues[key] = new Set());
                  for (const v of field.values)
                      propValues[key].add(v);
              }
          }
          return propValues;
      });
      const isObject$1 = isObject;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
          value ?? (value = _normalized.value);
          const input = payload.value;
          if (!isObject$1(input)) {
              payload.issues.push({
                  expected: "object",
                  code: "invalid_type",
                  input,
                  inst,
              });
              return payload;
          }
          payload.value = {};
          const proms = [];
          const shape = value.shape;
          for (const key of value.keys) {
              const el = shape[key];
              const r = el._zod.run({ value: input[key], issues: [] }, ctx);
              if (r instanceof Promise) {
                  proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
              }
              else {
                  handlePropertyResult(r, payload, key, input);
              }
          }
          if (!catchall) {
              return proms.length ? Promise.all(proms).then(() => payload) : payload;
          }
          return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
      };
  });
  const $ZodObjectJIT = /*@__PURE__*/ $constructor("$ZodObjectJIT", (inst, def) => {
      // requires cast because technically $ZodObject doesn't extend
      $ZodObject.init(inst, def);
      const superParse = inst._zod.parse;
      const _normalized = cached(() => normalizeDef(def));
      const generateFastpass = (shape) => {
          const doc = new Doc(["shape", "payload", "ctx"]);
          const normalized = _normalized.value;
          const parseStr = (key) => {
              const k = esc(key);
              return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
          };
          doc.write(`const input = payload.value;`);
          const ids = Object.create(null);
          let counter = 0;
          for (const key of normalized.keys) {
              ids[key] = `key_${counter++}`;
          }
          // A: preserve key order {
          doc.write(`const newResult = {}`);
          for (const key of normalized.keys) {
              const id = ids[key];
              const k = esc(key);
              doc.write(`const ${id} = ${parseStr(key)};`);
              doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
      `);
          }
          doc.write(`payload.value = newResult;`);
          doc.write(`return payload;`);
          const fn = doc.compile();
          return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject$1 = isObject;
      const jit = !globalConfig.jitless;
      const allowsEval$1 = allowsEval;
      const fastEnabled = jit && allowsEval$1.value; // && !def.catchall;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
          value ?? (value = _normalized.value);
          const input = payload.value;
          if (!isObject$1(input)) {
              payload.issues.push({
                  expected: "object",
                  code: "invalid_type",
                  input,
                  inst,
              });
              return payload;
          }
          if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
              // always synchronous
              if (!fastpass)
                  fastpass = generateFastpass(def.shape);
              payload = fastpass(payload, ctx);
              if (!catchall)
                  return payload;
              return handleCatchall([], input, payload, ctx, value, inst);
          }
          return superParse(payload, ctx);
      };
  });
  function handleUnionResults(results, final, inst, ctx) {
      for (const result of results) {
          if (result.issues.length === 0) {
              final.value = result.value;
              return final;
          }
      }
      const nonaborted = results.filter((r) => !aborted(r));
      if (nonaborted.length === 1) {
          final.value = nonaborted[0].value;
          return nonaborted[0];
      }
      final.issues.push({
          code: "invalid_union",
          input: final.value,
          inst,
          errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
      });
      return final;
  }
  const $ZodUnion = /*@__PURE__*/ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
      defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
      defineLazy(inst._zod, "values", () => {
          if (def.options.every((o) => o._zod.values)) {
              return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
          }
          return undefined;
      });
      defineLazy(inst._zod, "pattern", () => {
          if (def.options.every((o) => o._zod.pattern)) {
              const patterns = def.options.map((o) => o._zod.pattern);
              return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
          }
          return undefined;
      });
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
          if (single) {
              return first(payload, ctx);
          }
          let async = false;
          const results = [];
          for (const option of def.options) {
              const result = option._zod.run({
                  value: payload.value,
                  issues: [],
              }, ctx);
              if (result instanceof Promise) {
                  results.push(result);
                  async = true;
              }
              else {
                  if (result.issues.length === 0)
                      return result;
                  results.push(result);
              }
          }
          if (!async)
              return handleUnionResults(results, payload, inst, ctx);
          return Promise.all(results).then((results) => {
              return handleUnionResults(results, payload, inst, ctx);
          });
      };
  });
  const $ZodDiscriminatedUnion = 
  /*@__PURE__*/
  $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "propValues", () => {
          const propValues = {};
          for (const option of def.options) {
              const pv = option._zod.propValues;
              if (!pv || Object.keys(pv).length === 0)
                  throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
              for (const [k, v] of Object.entries(pv)) {
                  if (!propValues[k])
                      propValues[k] = new Set();
                  for (const val of v) {
                      propValues[k].add(val);
                  }
              }
          }
          return propValues;
      });
      const disc = cached(() => {
          const opts = def.options;
          const map = new Map();
          for (const o of opts) {
              const values = o._zod.propValues?.[def.discriminator];
              if (!values || values.size === 0)
                  throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
              for (const v of values) {
                  if (map.has(v)) {
                      throw new Error(`Duplicate discriminator value "${String(v)}"`);
                  }
                  map.set(v, o);
              }
          }
          return map;
      });
      inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!isObject(input)) {
              payload.issues.push({
                  code: "invalid_type",
                  expected: "object",
                  input,
                  inst,
              });
              return payload;
          }
          const opt = disc.value.get(input?.[def.discriminator]);
          if (opt) {
              return opt._zod.run(payload, ctx);
          }
          if (def.unionFallback) {
              return _super(payload, ctx);
          }
          // no matching discriminator
          payload.issues.push({
              code: "invalid_union",
              errors: [],
              note: "No matching discriminator",
              discriminator: def.discriminator,
              input,
              path: [def.discriminator],
              inst,
          });
          return payload;
      };
  });
  const $ZodIntersection = /*@__PURE__*/ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          const left = def.left._zod.run({ value: input, issues: [] }, ctx);
          const right = def.right._zod.run({ value: input, issues: [] }, ctx);
          const async = left instanceof Promise || right instanceof Promise;
          if (async) {
              return Promise.all([left, right]).then(([left, right]) => {
                  return handleIntersectionResults(payload, left, right);
              });
          }
          return handleIntersectionResults(payload, left, right);
      };
  });
  function mergeValues(a, b) {
      // const aType = parse.t(a);
      // const bType = parse.t(b);
      if (a === b) {
          return { valid: true, data: a };
      }
      if (a instanceof Date && b instanceof Date && +a === +b) {
          return { valid: true, data: a };
      }
      if (isPlainObject(a) && isPlainObject(b)) {
          const bKeys = Object.keys(b);
          const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
          const newObj = { ...a, ...b };
          for (const key of sharedKeys) {
              const sharedValue = mergeValues(a[key], b[key]);
              if (!sharedValue.valid) {
                  return {
                      valid: false,
                      mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
                  };
              }
              newObj[key] = sharedValue.data;
          }
          return { valid: true, data: newObj };
      }
      if (Array.isArray(a) && Array.isArray(b)) {
          if (a.length !== b.length) {
              return { valid: false, mergeErrorPath: [] };
          }
          const newArray = [];
          for (let index = 0; index < a.length; index++) {
              const itemA = a[index];
              const itemB = b[index];
              const sharedValue = mergeValues(itemA, itemB);
              if (!sharedValue.valid) {
                  return {
                      valid: false,
                      mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
                  };
              }
              newArray.push(sharedValue.data);
          }
          return { valid: true, data: newArray };
      }
      return { valid: false, mergeErrorPath: [] };
  }
  function handleIntersectionResults(result, left, right) {
      if (left.issues.length) {
          result.issues.push(...left.issues);
      }
      if (right.issues.length) {
          result.issues.push(...right.issues);
      }
      if (aborted(result))
          return result;
      const merged = mergeValues(left.value, right.value);
      if (!merged.valid) {
          throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
      }
      result.value = merged.data;
      return result;
  }
  const $ZodTuple = /*@__PURE__*/ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!Array.isArray(input)) {
              payload.issues.push({
                  input,
                  inst,
                  expected: "tuple",
                  code: "invalid_type",
              });
              return payload;
          }
          payload.value = [];
          const proms = [];
          if (!def.rest) {
              const tooBig = input.length > items.length;
              const tooSmall = input.length < optStart - 1;
              if (tooBig || tooSmall) {
                  payload.issues.push({
                      ...(tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }),
                      input,
                      inst,
                      origin: "array",
                  });
                  return payload;
              }
          }
          let i = -1;
          for (const item of items) {
              i++;
              if (i >= input.length)
                  if (i >= optStart)
                      continue;
              const result = item._zod.run({
                  value: input[i],
                  issues: [],
              }, ctx);
              if (result instanceof Promise) {
                  proms.push(result.then((result) => handleTupleResult(result, payload, i)));
              }
              else {
                  handleTupleResult(result, payload, i);
              }
          }
          if (def.rest) {
              const rest = input.slice(items.length);
              for (const el of rest) {
                  i++;
                  const result = def.rest._zod.run({
                      value: el,
                      issues: [],
                  }, ctx);
                  if (result instanceof Promise) {
                      proms.push(result.then((result) => handleTupleResult(result, payload, i)));
                  }
                  else {
                      handleTupleResult(result, payload, i);
                  }
              }
          }
          if (proms.length)
              return Promise.all(proms).then(() => payload);
          return payload;
      };
  });
  function handleTupleResult(result, final, index) {
      if (result.issues.length) {
          final.issues.push(...prefixIssues(index, result.issues));
      }
      final.value[index] = result.value;
  }
  const $ZodRecord = /*@__PURE__*/ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!isPlainObject(input)) {
              payload.issues.push({
                  expected: "record",
                  code: "invalid_type",
                  input,
                  inst,
              });
              return payload;
          }
          const proms = [];
          if (def.keyType._zod.values) {
              const values = def.keyType._zod.values;
              payload.value = {};
              for (const key of values) {
                  if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
                      const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                      if (result instanceof Promise) {
                          proms.push(result.then((result) => {
                              if (result.issues.length) {
                                  payload.issues.push(...prefixIssues(key, result.issues));
                              }
                              payload.value[key] = result.value;
                          }));
                      }
                      else {
                          if (result.issues.length) {
                              payload.issues.push(...prefixIssues(key, result.issues));
                          }
                          payload.value[key] = result.value;
                      }
                  }
              }
              let unrecognized;
              for (const key in input) {
                  if (!values.has(key)) {
                      unrecognized = unrecognized ?? [];
                      unrecognized.push(key);
                  }
              }
              if (unrecognized && unrecognized.length > 0) {
                  payload.issues.push({
                      code: "unrecognized_keys",
                      input,
                      inst,
                      keys: unrecognized,
                  });
              }
          }
          else {
              payload.value = {};
              for (const key of Reflect.ownKeys(input)) {
                  if (key === "__proto__")
                      continue;
                  const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
                  if (keyResult instanceof Promise) {
                      throw new Error("Async schemas not supported in object keys currently");
                  }
                  if (keyResult.issues.length) {
                      payload.issues.push({
                          code: "invalid_key",
                          origin: "record",
                          issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                          input: key,
                          path: [key],
                          inst,
                      });
                      payload.value[keyResult.value] = keyResult.value;
                      continue;
                  }
                  const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                  if (result instanceof Promise) {
                      proms.push(result.then((result) => {
                          if (result.issues.length) {
                              payload.issues.push(...prefixIssues(key, result.issues));
                          }
                          payload.value[keyResult.value] = result.value;
                      }));
                  }
                  else {
                      if (result.issues.length) {
                          payload.issues.push(...prefixIssues(key, result.issues));
                      }
                      payload.value[keyResult.value] = result.value;
                  }
              }
          }
          if (proms.length) {
              return Promise.all(proms).then(() => payload);
          }
          return payload;
      };
  });
  const $ZodMap = /*@__PURE__*/ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!(input instanceof Map)) {
              payload.issues.push({
                  expected: "map",
                  code: "invalid_type",
                  input,
                  inst,
              });
              return payload;
          }
          const proms = [];
          payload.value = new Map();
          for (const [key, value] of input) {
              const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
              const valueResult = def.valueType._zod.run({ value: value, issues: [] }, ctx);
              if (keyResult instanceof Promise || valueResult instanceof Promise) {
                  proms.push(Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {
                      handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
                  }));
              }
              else {
                  handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
              }
          }
          if (proms.length)
              return Promise.all(proms).then(() => payload);
          return payload;
      };
  });
  function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
      if (keyResult.issues.length) {
          if (propertyKeyTypes.has(typeof key)) {
              final.issues.push(...prefixIssues(key, keyResult.issues));
          }
          else {
              final.issues.push({
                  code: "invalid_key",
                  origin: "map",
                  input,
                  inst,
                  issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              });
          }
      }
      if (valueResult.issues.length) {
          if (propertyKeyTypes.has(typeof key)) {
              final.issues.push(...prefixIssues(key, valueResult.issues));
          }
          else {
              final.issues.push({
                  origin: "map",
                  code: "invalid_element",
                  input,
                  inst,
                  key: key,
                  issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              });
          }
      }
      final.value.set(keyResult.value, valueResult.value);
  }
  const $ZodSet = /*@__PURE__*/ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
          const input = payload.value;
          if (!(input instanceof Set)) {
              payload.issues.push({
                  input,
                  inst,
                  expected: "set",
                  code: "invalid_type",
              });
              return payload;
          }
          const proms = [];
          payload.value = new Set();
          for (const item of input) {
              const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
              if (result instanceof Promise) {
                  proms.push(result.then((result) => handleSetResult(result, payload)));
              }
              else
                  handleSetResult(result, payload);
          }
          if (proms.length)
              return Promise.all(proms).then(() => payload);
          return payload;
      };
  });
  function handleSetResult(result, final) {
      if (result.issues.length) {
          final.issues.push(...result.issues);
      }
      final.value.add(result.value);
  }
  const $ZodEnum = /*@__PURE__*/ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const values = getEnumValues(def.entries);
      const valuesSet = new Set(values);
      inst._zod.values = valuesSet;
      inst._zod.pattern = new RegExp(`^(${values
        .filter((k) => propertyKeyTypes.has(typeof k))
        .map((o) => (typeof o === "string" ? escapeRegex(o) : o.toString()))
        .join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (valuesSet.has(input)) {
              return payload;
          }
          payload.issues.push({
              code: "invalid_value",
              values,
              input,
              inst,
          });
          return payload;
      };
  });
  const $ZodLiteral = /*@__PURE__*/ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      if (def.values.length === 0) {
          throw new Error("Cannot create literal schema with no valid values");
      }
      inst._zod.values = new Set(def.values);
      inst._zod.pattern = new RegExp(`^(${def.values
        .map((o) => (typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)))
        .join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          if (inst._zod.values.has(input)) {
              return payload;
          }
          payload.issues.push({
              code: "invalid_value",
              values: def.values,
              input,
              inst,
          });
          return payload;
      };
  });
  const $ZodFile = /*@__PURE__*/ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
          const input = payload.value;
          // @ts-ignore
          if (input instanceof File)
              return payload;
          payload.issues.push({
              expected: "file",
              code: "invalid_type",
              input,
              inst,
          });
          return payload;
      };
  });
  const $ZodTransform = /*@__PURE__*/ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
              throw new $ZodEncodeError(inst.constructor.name);
          }
          const _out = def.transform(payload.value, payload);
          if (ctx.async) {
              const output = _out instanceof Promise ? _out : Promise.resolve(_out);
              return output.then((output) => {
                  payload.value = output;
                  return payload;
              });
          }
          if (_out instanceof Promise) {
              throw new $ZodAsyncError();
          }
          payload.value = _out;
          return payload;
      };
  });
  function handleOptionalResult(result, input) {
      if (result.issues.length && input === undefined) {
          return { issues: [], value: undefined };
      }
      return result;
  }
  const $ZodOptional = /*@__PURE__*/ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
          return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
      });
      defineLazy(inst._zod, "pattern", () => {
          const pattern = def.innerType._zod.pattern;
          return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
      });
      inst._zod.parse = (payload, ctx) => {
          if (def.innerType._zod.optin === "optional") {
              const result = def.innerType._zod.run(payload, ctx);
              if (result instanceof Promise)
                  return result.then((r) => handleOptionalResult(r, payload.value));
              return handleOptionalResult(result, payload.value);
          }
          if (payload.value === undefined) {
              return payload;
          }
          return def.innerType._zod.run(payload, ctx);
      };
  });
  const $ZodNullable = /*@__PURE__*/ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
          const pattern = def.innerType._zod.pattern;
          return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
      });
      defineLazy(inst._zod, "values", () => {
          return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
      });
      inst._zod.parse = (payload, ctx) => {
          // Forward direction (decode): allow null to pass through
          if (payload.value === null)
              return payload;
          return def.innerType._zod.run(payload, ctx);
      };
  });
  const $ZodDefault = /*@__PURE__*/ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      // inst._zod.qin = "true";
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
              return def.innerType._zod.run(payload, ctx);
          }
          // Forward direction (decode): apply defaults for undefined input
          if (payload.value === undefined) {
              payload.value = def.defaultValue;
              /**
               * $ZodDefault returns the default value immediately in forward direction.
               * It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
              return payload;
          }
          // Forward direction: continue with default handling
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
              return result.then((result) => handleDefaultResult(result, def));
          }
          return handleDefaultResult(result, def);
      };
  });
  function handleDefaultResult(payload, def) {
      if (payload.value === undefined) {
          payload.value = def.defaultValue;
      }
      return payload;
  }
  const $ZodPrefault = /*@__PURE__*/ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
              return def.innerType._zod.run(payload, ctx);
          }
          // Forward direction (decode): apply prefault for undefined input
          if (payload.value === undefined) {
              payload.value = def.defaultValue;
          }
          return def.innerType._zod.run(payload, ctx);
      };
  });
  const $ZodNonOptional = /*@__PURE__*/ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
          const v = def.innerType._zod.values;
          return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
      });
      inst._zod.parse = (payload, ctx) => {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
              return result.then((result) => handleNonOptionalResult(result, inst));
          }
          return handleNonOptionalResult(result, inst);
      };
  });
  function handleNonOptionalResult(payload, inst) {
      if (!payload.issues.length && payload.value === undefined) {
          payload.issues.push({
              code: "invalid_type",
              expected: "nonoptional",
              input: payload.value,
              inst,
          });
      }
      return payload;
  }
  const $ZodSuccess = /*@__PURE__*/ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
              throw new $ZodEncodeError("ZodSuccess");
          }
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
              return result.then((result) => {
                  payload.value = result.issues.length === 0;
                  return payload;
              });
          }
          payload.value = result.issues.length === 0;
          return payload;
      };
  });
  const $ZodCatch = /*@__PURE__*/ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
              return def.innerType._zod.run(payload, ctx);
          }
          // Forward direction (decode): apply catch logic
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
              return result.then((result) => {
                  payload.value = result.value;
                  if (result.issues.length) {
                      payload.value = def.catchValue({
                          ...payload,
                          error: {
                              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                          },
                          input: payload.value,
                      });
                      payload.issues = [];
                  }
                  return payload;
              });
          }
          payload.value = result.value;
          if (result.issues.length) {
              payload.value = def.catchValue({
                  ...payload,
                  error: {
                      issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                  },
                  input: payload.value,
              });
              payload.issues = [];
          }
          return payload;
      };
  });
  const $ZodNaN = /*@__PURE__*/ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
          if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
              payload.issues.push({
                  input: payload.value,
                  inst,
                  expected: "nan",
                  code: "invalid_type",
              });
              return payload;
          }
          return payload;
      };
  });
  const $ZodPipe = /*@__PURE__*/ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
              const right = def.out._zod.run(payload, ctx);
              if (right instanceof Promise) {
                  return right.then((right) => handlePipeResult(right, def.in, ctx));
              }
              return handlePipeResult(right, def.in, ctx);
          }
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
              return left.then((left) => handlePipeResult(left, def.out, ctx));
          }
          return handlePipeResult(left, def.out, ctx);
      };
  });
  function handlePipeResult(left, next, ctx) {
      if (left.issues.length) {
          // prevent further checks
          left.aborted = true;
          return left;
      }
      return next._zod.run({ value: left.value, issues: left.issues }, ctx);
  }
  const $ZodCodec = /*@__PURE__*/ $constructor("$ZodCodec", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
          const direction = ctx.direction || "forward";
          if (direction === "forward") {
              const left = def.in._zod.run(payload, ctx);
              if (left instanceof Promise) {
                  return left.then((left) => handleCodecAResult(left, def, ctx));
              }
              return handleCodecAResult(left, def, ctx);
          }
          else {
              const right = def.out._zod.run(payload, ctx);
              if (right instanceof Promise) {
                  return right.then((right) => handleCodecAResult(right, def, ctx));
              }
              return handleCodecAResult(right, def, ctx);
          }
      };
  });
  function handleCodecAResult(result, def, ctx) {
      if (result.issues.length) {
          // prevent further checks
          result.aborted = true;
          return result;
      }
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
          const transformed = def.transform(result.value, result);
          if (transformed instanceof Promise) {
              return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
          }
          return handleCodecTxResult(result, transformed, def.out, ctx);
      }
      else {
          const transformed = def.reverseTransform(result.value, result);
          if (transformed instanceof Promise) {
              return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
          }
          return handleCodecTxResult(result, transformed, def.in, ctx);
      }
  }
  function handleCodecTxResult(left, value, nextSchema, ctx) {
      // Check if transform added any issues
      if (left.issues.length) {
          left.aborted = true;
          return left;
      }
      return nextSchema._zod.run({ value, issues: left.issues }, ctx);
  }
  const $ZodReadonly = /*@__PURE__*/ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      inst._zod.parse = (payload, ctx) => {
          if (ctx.direction === "backward") {
              return def.innerType._zod.run(payload, ctx);
          }
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise) {
              return result.then(handleReadonlyResult);
          }
          return handleReadonlyResult(result);
      };
  });
  function handleReadonlyResult(payload) {
      payload.value = Object.freeze(payload.value);
      return payload;
  }
  const $ZodTemplateLiteral = /*@__PURE__*/ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
          if (typeof part === "object" && part !== null) {
              // is Zod schema
              if (!part._zod.pattern) {
                  // if (!source)
                  throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
              }
              const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
              if (!source)
                  throw new Error(`Invalid template literal part: ${part._zod.traits}`);
              const start = source.startsWith("^") ? 1 : 0;
              const end = source.endsWith("$") ? source.length - 1 : source.length;
              regexParts.push(source.slice(start, end));
          }
          else if (part === null || primitiveTypes.has(typeof part)) {
              regexParts.push(escapeRegex(`${part}`));
          }
          else {
              throw new Error(`Invalid template literal part: ${part}`);
          }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
          if (typeof payload.value !== "string") {
              payload.issues.push({
                  input: payload.value,
                  inst,
                  expected: "template_literal",
                  code: "invalid_type",
              });
              return payload;
          }
          inst._zod.pattern.lastIndex = 0;
          if (!inst._zod.pattern.test(payload.value)) {
              payload.issues.push({
                  input: payload.value,
                  inst,
                  code: "invalid_format",
                  format: def.format ?? "template_literal",
                  pattern: inst._zod.pattern.source,
              });
              return payload;
          }
          return payload;
      };
  });
  const $ZodFunction = /*@__PURE__*/ $constructor("$ZodFunction", (inst, def) => {
      $ZodType.init(inst, def);
      inst._def = def;
      inst._zod.def = def;
      inst.implement = (func) => {
          if (typeof func !== "function") {
              throw new Error("implement() must be called with a function");
          }
          return function (...args) {
              const parsedArgs = inst._def.input ? parse$1(inst._def.input, args) : args;
              const result = Reflect.apply(func, this, parsedArgs);
              if (inst._def.output) {
                  return parse$1(inst._def.output, result);
              }
              return result;
          };
      };
      inst.implementAsync = (func) => {
          if (typeof func !== "function") {
              throw new Error("implementAsync() must be called with a function");
          }
          return async function (...args) {
              const parsedArgs = inst._def.input ? await parseAsync$1(inst._def.input, args) : args;
              const result = await Reflect.apply(func, this, parsedArgs);
              if (inst._def.output) {
                  return await parseAsync$1(inst._def.output, result);
              }
              return result;
          };
      };
      inst._zod.parse = (payload, _ctx) => {
          if (typeof payload.value !== "function") {
              payload.issues.push({
                  code: "invalid_type",
                  expected: "function",
                  input: payload.value,
                  inst,
              });
              return payload;
          }
          // Check if output is a promise type to determine if we should use async implementation
          const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
          if (hasPromiseOutput) {
              payload.value = inst.implementAsync(payload.value);
          }
          else {
              payload.value = inst.implement(payload.value);
          }
          return payload;
      };
      inst.input = (...args) => {
          const F = inst.constructor;
          if (Array.isArray(args[0])) {
              return new F({
                  type: "function",
                  input: new $ZodTuple({
                      type: "tuple",
                      items: args[0],
                      rest: args[1],
                  }),
                  output: inst._def.output,
              });
          }
          return new F({
              type: "function",
              input: args[0],
              output: inst._def.output,
          });
      };
      inst.output = (output) => {
          const F = inst.constructor;
          return new F({
              type: "function",
              input: inst._def.input,
              output,
          });
      };
      return inst;
  });
  const $ZodPromise = /*@__PURE__*/ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
          return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
  });
  const $ZodLazy = /*@__PURE__*/ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      // let _innerType!: any;
      // util.defineLazy(def, "getter", () => {
      //   if (!_innerType) {
      //     _innerType = def.getter();
      //   }
      //   return () => _innerType;
      // });
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
      defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
      inst._zod.parse = (payload, ctx) => {
          const inner = inst._zod.innerType;
          return inner._zod.run(payload, ctx);
      };
  });
  const $ZodCustom = /*@__PURE__*/ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
          return payload;
      };
      inst._zod.check = (payload) => {
          const input = payload.value;
          const r = def.fn(input);
          if (r instanceof Promise) {
              return r.then((r) => handleRefineResult(r, payload, input, inst));
          }
          handleRefineResult(r, payload, input, inst);
          return;
      };
  });
  function handleRefineResult(result, payload, input, inst) {
      if (!result) {
          const _iss = {
              code: "custom",
              input,
              inst, // incorporates params.error into issue reporting
              path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting
              continue: !inst._zod.def.abort,
              // params: inst._zod.def.params,
          };
          if (inst._zod.def.params)
              _iss.params = inst._zod.def.params;
          payload.issues.push(issue(_iss));
      }
  }

  const error$F = () => {
      const Sizable = {
          string: { unit: "Ø­Ø±Ù", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
          file: { unit: "Ø¨Ø§ÙŠØª", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
          array: { unit: "Ø¹Ù†ØµØ±", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
          set: { unit: "Ø¹Ù†ØµØ±", verb: "Ø£Ù† ÙŠØ­ÙˆÙŠ" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "Ù…Ø¯Ø®Ù„",
          email: "Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ",
          url: "Ø±Ø§Ø¨Ø·",
          emoji: "Ø¥ÙŠÙ…ÙˆØ¬ÙŠ",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ØªØ§Ø±ÙŠØ® ÙˆÙˆÙ‚Øª Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
          date: "ØªØ§Ø±ÙŠØ® Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
          time: "ÙˆÙ‚Øª Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
          duration: "Ù…Ø¯Ø© Ø¨Ù…Ø¹ÙŠØ§Ø± ISO",
          ipv4: "Ø¹Ù†ÙˆØ§Ù† IPv4",
          ipv6: "Ø¹Ù†ÙˆØ§Ù† IPv6",
          cidrv4: "Ù…Ø¯Ù‰ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¨ØµÙŠØºØ© IPv4",
          cidrv6: "Ù…Ø¯Ù‰ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø¨ØµÙŠØºØ© IPv6",
          base64: "Ù†ÙŽØµ Ø¨ØªØ±Ù…ÙŠØ² base64-encoded",
          base64url: "Ù†ÙŽØµ Ø¨ØªØ±Ù…ÙŠØ² base64url-encoded",
          json_string: "Ù†ÙŽØµ Ø¹Ù„Ù‰ Ù‡ÙŠØ¦Ø© JSON",
          e164: "Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¨Ù…Ø¹ÙŠØ§Ø± E.164",
          jwt: "JWT",
          template_literal: "Ù…Ø¯Ø®Ù„",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©: ÙŠÙØªØ±Ø¶ Ø¥Ø¯Ø®Ø§Ù„ ${issue.expected}ØŒ ÙˆÙ„ÙƒÙ† ØªÙ… Ø¥Ø¯Ø®Ø§Ù„ ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„Ø©: ÙŠÙØªØ±Ø¶ Ø¥Ø¯Ø®Ø§Ù„ ${stringifyPrimitive(issue.values[0])}`;
                  return `Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØªÙˆÙ‚Ø¹ Ø§Ù†ØªÙ‚Ø§Ø¡ Ø£Ø­Ø¯ Ù‡Ø°Ù‡ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª: ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return ` Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ø£Ù† ØªÙƒÙˆÙ† ${issue.origin ?? "Ø§Ù„Ù‚ÙŠÙ…Ø©"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±"}`;
                  return `Ø£ÙƒØ¨Ø± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ø£Ù† ØªÙƒÙˆÙ† ${issue.origin ?? "Ø§Ù„Ù‚ÙŠÙ…Ø©"} ${adj} ${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ù„Ù€ ${issue.origin} Ø£Ù† ÙŠÙƒÙˆÙ† ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Ø£ØµØºØ± Ù…Ù† Ø§Ù„Ù„Ø§Ø²Ù…: ÙŠÙØªØ±Ø¶ Ù„Ù€ ${issue.origin} Ø£Ù† ÙŠÙƒÙˆÙ† ${adj} ${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ "${issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙ†ØªÙ‡ÙŠ Ø¨Ù€ "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ¶Ù…Ù‘ÙŽÙ† "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Ù†ÙŽØµ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ù†Ù…Ø· ${_issue.pattern}`;
                  return `${Nouns[_issue.format] ?? issue.format} ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„`;
              }
              case "not_multiple_of":
                  return `Ø±Ù‚Ù… ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„: ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ù† Ù…Ø¶Ø§Ø¹ÙØ§Øª ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Ù…Ø¹Ø±Ù${issue.keys.length > 1 ? "Ø§Øª" : ""} ØºØ±ÙŠØ¨${issue.keys.length > 1 ? "Ø©" : ""}: ${joinValues(issue.keys, "ØŒ ")}`;
              case "invalid_key":
                  return `Ù…Ø¹Ø±Ù ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„ ÙÙŠ ${issue.origin}`;
              case "invalid_union":
                  return "Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„";
              case "invalid_element":
                  return `Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„ ÙÙŠ ${issue.origin}`;
              default:
                  return "Ù…Ø¯Ø®Ù„ ØºÙŠØ± Ù…Ù‚Ø¨ÙˆÙ„";
          }
      };
  };
  function ar () {
      return {
          localeError: error$F(),
      };
  }

  const error$E = () => {
      const Sizable = {
          string: { unit: "simvol", verb: "olmalÄ±dÄ±r" },
          file: { unit: "bayt", verb: "olmalÄ±dÄ±r" },
          array: { unit: "element", verb: "olmalÄ±dÄ±r" },
          set: { unit: "element", verb: "olmalÄ±dÄ±r" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "input",
          email: "email address",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO datetime",
          date: "ISO date",
          time: "ISO time",
          duration: "ISO duration",
          ipv4: "IPv4 address",
          ipv6: "IPv6 address",
          cidrv4: "IPv4 range",
          cidrv6: "IPv6 range",
          base64: "base64-encoded string",
          base64url: "base64url-encoded string",
          json_string: "JSON string",
          e164: "E.164 number",
          jwt: "JWT",
          template_literal: "input",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `YanlÄ±ÅŸ dÉ™yÉ™r: gÃ¶zlÉ™nilÉ™n ${issue.expected}, daxil olan ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `YanlÄ±ÅŸ dÉ™yÉ™r: gÃ¶zlÉ™nilÉ™n ${stringifyPrimitive(issue.values[0])}`;
                  return `YanlÄ±ÅŸ seÃ§im: aÅŸaÄŸÄ±dakÄ±lardan biri olmalÄ±dÄ±r: ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Ã‡ox bÃ¶yÃ¼k: gÃ¶zlÉ™nilÉ™n ${issue.origin ?? "dÉ™yÉ™r"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element"}`;
                  return `Ã‡ox bÃ¶yÃ¼k: gÃ¶zlÉ™nilÉ™n ${issue.origin ?? "dÉ™yÉ™r"} ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Ã‡ox kiÃ§ik: gÃ¶zlÉ™nilÉ™n ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  return `Ã‡ox kiÃ§ik: gÃ¶zlÉ™nilÉ™n ${issue.origin} ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `YanlÄ±ÅŸ mÉ™tn: "${_issue.prefix}" ilÉ™ baÅŸlamalÄ±dÄ±r`;
                  if (_issue.format === "ends_with")
                      return `YanlÄ±ÅŸ mÉ™tn: "${_issue.suffix}" ilÉ™ bitmÉ™lidir`;
                  if (_issue.format === "includes")
                      return `YanlÄ±ÅŸ mÉ™tn: "${_issue.includes}" daxil olmalÄ±dÄ±r`;
                  if (_issue.format === "regex")
                      return `YanlÄ±ÅŸ mÉ™tn: ${_issue.pattern} ÅŸablonuna uyÄŸun olmalÄ±dÄ±r`;
                  return `YanlÄ±ÅŸ ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `YanlÄ±ÅŸ É™dÉ™d: ${issue.divisor} ilÉ™ bÃ¶lÃ¼nÉ™ bilÉ™n olmalÄ±dÄ±r`;
              case "unrecognized_keys":
                  return `TanÄ±nmayan aÃ§ar${issue.keys.length > 1 ? "lar" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `${issue.origin} daxilindÉ™ yanlÄ±ÅŸ aÃ§ar`;
              case "invalid_union":
                  return "YanlÄ±ÅŸ dÉ™yÉ™r";
              case "invalid_element":
                  return `${issue.origin} daxilindÉ™ yanlÄ±ÅŸ dÉ™yÉ™r`;
              default:
                  return `YanlÄ±ÅŸ dÉ™yÉ™r`;
          }
      };
  };
  function az () {
      return {
          localeError: error$E(),
      };
  }

  function getBelarusianPlural(count, one, few, many) {
      const absCount = Math.abs(count);
      const lastDigit = absCount % 10;
      const lastTwoDigits = absCount % 100;
      if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
          return many;
      }
      if (lastDigit === 1) {
          return one;
      }
      if (lastDigit >= 2 && lastDigit <= 4) {
          return few;
      }
      return many;
  }
  const error$D = () => {
      const Sizable = {
          string: {
              unit: {
                  one: "ÑÑ–Ð¼Ð²Ð°Ð»",
                  few: "ÑÑ–Ð¼Ð²Ð°Ð»Ñ‹",
                  many: "ÑÑ–Ð¼Ð²Ð°Ð»Ð°Ñž",
              },
              verb: "Ð¼ÐµÑ†ÑŒ",
          },
          array: {
              unit: {
                  one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
                  few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹",
                  many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž",
              },
              verb: "Ð¼ÐµÑ†ÑŒ",
          },
          set: {
              unit: {
                  one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
                  few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹",
                  many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ñž",
              },
              verb: "Ð¼ÐµÑ†ÑŒ",
          },
          file: {
              unit: {
                  one: "Ð±Ð°Ð¹Ñ‚",
                  few: "Ð±Ð°Ð¹Ñ‚Ñ‹",
                  many: "Ð±Ð°Ð¹Ñ‚Ð°Ñž",
              },
              verb: "Ð¼ÐµÑ†ÑŒ",
          },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Ð»Ñ–Ðº";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "Ð¼Ð°ÑÑ–Ñž";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "ÑƒÐ²Ð¾Ð´",
          email: "email Ð°Ð´Ñ€Ð°Ñ",
          url: "URL",
          emoji: "ÑÐ¼Ð¾Ð´Ð·Ñ–",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO Ð´Ð°Ñ‚Ð° Ñ– Ñ‡Ð°Ñ",
          date: "ISO Ð´Ð°Ñ‚Ð°",
          time: "ISO Ñ‡Ð°Ñ",
          duration: "ISO Ð¿Ñ€Ð°Ñ†ÑÐ³Ð»Ð°ÑÑ†ÑŒ",
          ipv4: "IPv4 Ð°Ð´Ñ€Ð°Ñ",
          ipv6: "IPv6 Ð°Ð´Ñ€Ð°Ñ",
          cidrv4: "IPv4 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½",
          cidrv6: "IPv6 Ð´Ñ‹ÑÐ¿Ð°Ð·Ð¾Ð½",
          base64: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64",
          base64url: "Ñ€Ð°Ð´Ð¾Ðº Ñƒ Ñ„Ð°Ñ€Ð¼Ð°Ñ†Ðµ base64url",
          json_string: "JSON Ñ€Ð°Ð´Ð¾Ðº",
          e164: "Ð½ÑƒÐ¼Ð°Ñ€ E.164",
          jwt: "JWT",
          template_literal: "ÑƒÐ²Ð¾Ð´",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°ÑžÑÑ ${issue.expected}, Ð°Ñ‚Ñ€Ñ‹Ð¼Ð°Ð½Ð° ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ ${stringifyPrimitive(issue.values[0])}`;
                  return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð²Ð°Ñ€Ñ‹ÑÐ½Ñ‚: Ñ‡Ð°ÐºÐ°ÑžÑÑ Ð°Ð´Ð·Ñ–Ð½ Ð· ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      const maxValue = Number(issue.maximum);
                      const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
                      return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;
                  }
                  return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð²ÑÐ»Ñ–ÐºÑ–: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue.origin ?? "Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ"} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      const minValue = Number(issue.minimum);
                      const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
                      return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;
                  }
                  return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð° Ð¼Ð°Ð»Ñ‹: Ñ‡Ð°ÐºÐ°Ð»Ð°ÑÑ, ÑˆÑ‚Ð¾ ${issue.origin} Ð¿Ð°Ð²Ñ–Ð½Ð½Ð° Ð±Ñ‹Ñ†ÑŒ ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð¿Ð°Ñ‡Ñ‹Ð½Ð°Ñ†Ñ†Ð° Ð· "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð°ÐºÐ°Ð½Ñ‡Ð²Ð°Ñ†Ñ†Ð° Ð½Ð° "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð·Ð¼ÑÑˆÑ‡Ð°Ñ†ÑŒ "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ñ€Ð°Ð´Ð¾Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð°Ð´Ð¿Ð°Ð²ÑÐ´Ð°Ñ†ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
                  return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ Ð»Ñ–Ðº: Ð¿Ð°Ð²Ñ–Ð½ÐµÐ½ Ð±Ñ‹Ñ†ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${issue.divisor}`;
              case "unrecognized_keys":
                  return `ÐÐµÑ€Ð°ÑÐ¿Ð°Ð·Ð½Ð°Ð½Ñ‹ ${issue.keys.length > 1 ? "ÐºÐ»ÑŽÑ‡Ñ‹" : "ÐºÐ»ÑŽÑ‡"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÐºÐ»ÑŽÑ‡ Ñƒ ${issue.origin}`;
              case "invalid_union":
                  return "ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´";
              case "invalid_element":
                  return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ð°Ðµ Ð·Ð½Ð°Ñ‡ÑÐ½Ð½Ðµ Ñž ${issue.origin}`;
              default:
                  return `ÐÑÐ¿Ñ€Ð°Ð²Ñ–Ð»ÑŒÐ½Ñ‹ ÑžÐ²Ð¾Ð´`;
          }
      };
  };
  function be () {
      return {
          localeError: error$D(),
      };
  }

  const error$C = () => {
      const Sizable = {
          string: { unit: "carÃ cters", verb: "contenir" },
          file: { unit: "bytes", verb: "contenir" },
          array: { unit: "elements", verb: "contenir" },
          set: { unit: "elements", verb: "contenir" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "entrada",
          email: "adreÃ§a electrÃ²nica",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "data i hora ISO",
          date: "data ISO",
          time: "hora ISO",
          duration: "durada ISO",
          ipv4: "adreÃ§a IPv4",
          ipv6: "adreÃ§a IPv6",
          cidrv4: "rang IPv4",
          cidrv6: "rang IPv6",
          base64: "cadena codificada en base64",
          base64url: "cadena codificada en base64url",
          json_string: "cadena JSON",
          e164: "nÃºmero E.164",
          jwt: "JWT",
          template_literal: "entrada",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Tipus invÃ lid: s'esperava ${issue.expected}, s'ha rebut ${parsedType(issue.input)}`;
              // return `Tipus invÃ lid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Valor invÃ lid: s'esperava ${stringifyPrimitive(issue.values[0])}`;
                  return `OpciÃ³ invÃ lida: s'esperava una de ${joinValues(issue.values, " o ")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "com a mÃ xim" : "menys de";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Massa gran: s'esperava que ${issue.origin ?? "el valor"} continguÃ©s ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
                  return `Massa gran: s'esperava que ${issue.origin ?? "el valor"} fos ${adj} ${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? "com a mÃ­nim" : "mÃ©s de";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Massa petit: s'esperava que ${issue.origin} continguÃ©s ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Massa petit: s'esperava que ${issue.origin} fos ${adj} ${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `Format invÃ lid: ha de comenÃ§ar amb "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `Format invÃ lid: ha d'acabar amb "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Format invÃ lid: ha d'incloure "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Format invÃ lid: ha de coincidir amb el patrÃ³ ${_issue.pattern}`;
                  return `Format invÃ lid per a ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `NÃºmero invÃ lid: ha de ser mÃºltiple de ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Clau${issue.keys.length > 1 ? "s" : ""} no reconeguda${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Clau invÃ lida a ${issue.origin}`;
              case "invalid_union":
                  return "Entrada invÃ lida"; // Could also be "Tipus d'uniÃ³ invÃ lid" but "Entrada invÃ lida" is more general
              case "invalid_element":
                  return `Element invÃ lid a ${issue.origin}`;
              default:
                  return `Entrada invÃ lida`;
          }
      };
  };
  function ca () {
      return {
          localeError: error$C(),
      };
  }

  const error$B = () => {
      const Sizable = {
          string: { unit: "znakÅ¯", verb: "mÃ­t" },
          file: { unit: "bajtÅ¯", verb: "mÃ­t" },
          array: { unit: "prvkÅ¯", verb: "mÃ­t" },
          set: { unit: "prvkÅ¯", verb: "mÃ­t" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "ÄÃ­slo";
              }
              case "string": {
                  return "Å™etÄ›zec";
              }
              case "boolean": {
                  return "boolean";
              }
              case "bigint": {
                  return "bigint";
              }
              case "function": {
                  return "funkce";
              }
              case "symbol": {
                  return "symbol";
              }
              case "undefined": {
                  return "undefined";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "pole";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "regulÃ¡rnÃ­ vÃ½raz",
          email: "e-mailovÃ¡ adresa",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "datum a Äas ve formÃ¡tu ISO",
          date: "datum ve formÃ¡tu ISO",
          time: "Äas ve formÃ¡tu ISO",
          duration: "doba trvÃ¡nÃ­ ISO",
          ipv4: "IPv4 adresa",
          ipv6: "IPv6 adresa",
          cidrv4: "rozsah IPv4",
          cidrv6: "rozsah IPv6",
          base64: "Å™etÄ›zec zakÃ³dovanÃ½ ve formÃ¡tu base64",
          base64url: "Å™etÄ›zec zakÃ³dovanÃ½ ve formÃ¡tu base64url",
          json_string: "Å™etÄ›zec ve formÃ¡tu JSON",
          e164: "ÄÃ­slo E.164",
          jwt: "JWT",
          template_literal: "vstup",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `NeplatnÃ½ vstup: oÄekÃ¡vÃ¡no ${issue.expected}, obdrÅ¾eno ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `NeplatnÃ½ vstup: oÄekÃ¡vÃ¡no ${stringifyPrimitive(issue.values[0])}`;
                  return `NeplatnÃ¡ moÅ¾nost: oÄekÃ¡vÃ¡na jedna z hodnot ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Hodnota je pÅ™Ã­liÅ¡ velkÃ¡: ${issue.origin ?? "hodnota"} musÃ­ mÃ­t ${adj}${issue.maximum.toString()} ${sizing.unit ?? "prvkÅ¯"}`;
                  }
                  return `Hodnota je pÅ™Ã­liÅ¡ velkÃ¡: ${issue.origin ?? "hodnota"} musÃ­ bÃ½t ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Hodnota je pÅ™Ã­liÅ¡ malÃ¡: ${issue.origin ?? "hodnota"} musÃ­ mÃ­t ${adj}${issue.minimum.toString()} ${sizing.unit ?? "prvkÅ¯"}`;
                  }
                  return `Hodnota je pÅ™Ã­liÅ¡ malÃ¡: ${issue.origin ?? "hodnota"} musÃ­ bÃ½t ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `NeplatnÃ½ Å™etÄ›zec: musÃ­ zaÄÃ­nat na "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `NeplatnÃ½ Å™etÄ›zec: musÃ­ konÄit na "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `NeplatnÃ½ Å™etÄ›zec: musÃ­ obsahovat "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `NeplatnÃ½ Å™etÄ›zec: musÃ­ odpovÃ­dat vzoru ${_issue.pattern}`;
                  return `NeplatnÃ½ formÃ¡t ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `NeplatnÃ© ÄÃ­slo: musÃ­ bÃ½t nÃ¡sobkem ${issue.divisor}`;
              case "unrecognized_keys":
                  return `NeznÃ¡mÃ© klÃ­Äe: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `NeplatnÃ½ klÃ­Ä v ${issue.origin}`;
              case "invalid_union":
                  return "NeplatnÃ½ vstup";
              case "invalid_element":
                  return `NeplatnÃ¡ hodnota v ${issue.origin}`;
              default:
                  return `NeplatnÃ½ vstup`;
          }
      };
  };
  function cs () {
      return {
          localeError: error$B(),
      };
  }

  const error$A = () => {
      const Sizable = {
          string: { unit: "tegn", verb: "havde" },
          file: { unit: "bytes", verb: "havde" },
          array: { unit: "elementer", verb: "indeholdt" },
          set: { unit: "elementer", verb: "indeholdt" },
      };
      const TypeNames = {
          string: "streng",
          number: "tal",
          boolean: "boolean",
          array: "liste",
          object: "objekt",
          set: "sÃ¦t",
          file: "fil",
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      function getTypeName(type) {
          return TypeNames[type] ?? type;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "tal";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "liste";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
                  return "objekt";
              }
          }
          return t;
      };
      const Nouns = {
          regex: "input",
          email: "e-mailadresse",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO dato- og klokkeslÃ¦t",
          date: "ISO-dato",
          time: "ISO-klokkeslÃ¦t",
          duration: "ISO-varighed",
          ipv4: "IPv4-omrÃ¥de",
          ipv6: "IPv6-omrÃ¥de",
          cidrv4: "IPv4-spektrum",
          cidrv6: "IPv6-spektrum",
          base64: "base64-kodet streng",
          base64url: "base64url-kodet streng",
          json_string: "JSON-streng",
          e164: "E.164-nummer",
          jwt: "JWT",
          template_literal: "input",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Ugyldigt input: forventede ${getTypeName(issue.expected)}, fik ${getTypeName(parsedType(issue.input))}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Ugyldig vÃ¦rdi: forventede ${stringifyPrimitive(issue.values[0])}`;
                  return `Ugyldigt valg: forventede en af fÃ¸lgende ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  const origin = getTypeName(issue.origin);
                  if (sizing)
                      return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "elementer"}`;
                  return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  const origin = getTypeName(issue.origin);
                  if (sizing) {
                      return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `For lille: forventede ${origin} havde ${adj} ${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Ugyldig streng: skal matche mÃ¸nsteret ${_issue.pattern}`;
                  return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Ugyldigt tal: skal vÃ¦re deleligt med ${issue.divisor}`;
              case "unrecognized_keys":
                  return `${issue.keys.length > 1 ? "Ukendte nÃ¸gler" : "Ukendt nÃ¸gle"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Ugyldig nÃ¸gle i ${issue.origin}`;
              case "invalid_union":
                  return "Ugyldigt input: matcher ingen af de tilladte typer";
              case "invalid_element":
                  return `Ugyldig vÃ¦rdi i ${issue.origin}`;
              default:
                  return `Ugyldigt input`;
          }
      };
  };
  function da () {
      return {
          localeError: error$A(),
      };
  }

  const error$z = () => {
      const Sizable = {
          string: { unit: "Zeichen", verb: "zu haben" },
          file: { unit: "Bytes", verb: "zu haben" },
          array: { unit: "Elemente", verb: "zu haben" },
          set: { unit: "Elemente", verb: "zu haben" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Zahl";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "Array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "Eingabe",
          email: "E-Mail-Adresse",
          url: "URL",
          emoji: "Emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO-Datum und -Uhrzeit",
          date: "ISO-Datum",
          time: "ISO-Uhrzeit",
          duration: "ISO-Dauer",
          ipv4: "IPv4-Adresse",
          ipv6: "IPv6-Adresse",
          cidrv4: "IPv4-Bereich",
          cidrv6: "IPv6-Bereich",
          base64: "Base64-codierter String",
          base64url: "Base64-URL-codierter String",
          json_string: "JSON-String",
          e164: "E.164-Nummer",
          jwt: "JWT",
          template_literal: "Eingabe",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `UngÃ¼ltige Eingabe: erwartet ${issue.expected}, erhalten ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `UngÃ¼ltige Eingabe: erwartet ${stringifyPrimitive(issue.values[0])}`;
                  return `UngÃ¼ltige Option: erwartet eine von ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Zu groÃŸ: erwartet, dass ${issue.origin ?? "Wert"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
                  return `Zu groÃŸ: erwartet, dass ${issue.origin ?? "Wert"} ${adj}${issue.maximum.toString()} ist`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} hat`;
                  }
                  return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ist`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `UngÃ¼ltiger String: muss mit "${_issue.prefix}" beginnen`;
                  if (_issue.format === "ends_with")
                      return `UngÃ¼ltiger String: muss mit "${_issue.suffix}" enden`;
                  if (_issue.format === "includes")
                      return `UngÃ¼ltiger String: muss "${_issue.includes}" enthalten`;
                  if (_issue.format === "regex")
                      return `UngÃ¼ltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
                  return `UngÃ¼ltig: ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `UngÃ¼ltige Zahl: muss ein Vielfaches von ${issue.divisor} sein`;
              case "unrecognized_keys":
                  return `${issue.keys.length > 1 ? "Unbekannte SchlÃ¼ssel" : "Unbekannter SchlÃ¼ssel"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `UngÃ¼ltiger SchlÃ¼ssel in ${issue.origin}`;
              case "invalid_union":
                  return "UngÃ¼ltige Eingabe";
              case "invalid_element":
                  return `UngÃ¼ltiger Wert in ${issue.origin}`;
              default:
                  return `UngÃ¼ltige Eingabe`;
          }
      };
  };
  function de () {
      return {
          localeError: error$z(),
      };
  }

  const parsedType$3 = (data) => {
      const t = typeof data;
      switch (t) {
          case "number": {
              return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
              if (Array.isArray(data)) {
                  return "array";
              }
              if (data === null) {
                  return "null";
              }
              if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                  return data.constructor.name;
              }
          }
      }
      return t;
  };
  const error$y = () => {
      const Sizable = {
          string: { unit: "characters", verb: "to have" },
          file: { unit: "bytes", verb: "to have" },
          array: { unit: "items", verb: "to have" },
          set: { unit: "items", verb: "to have" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const Nouns = {
          regex: "input",
          email: "email address",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO datetime",
          date: "ISO date",
          time: "ISO time",
          duration: "ISO duration",
          ipv4: "IPv4 address",
          ipv6: "IPv6 address",
          cidrv4: "IPv4 range",
          cidrv6: "IPv6 range",
          base64: "base64-encoded string",
          base64url: "base64url-encoded string",
          json_string: "JSON string",
          e164: "E.164 number",
          jwt: "JWT",
          template_literal: "input",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Invalid input: expected ${issue.expected}, received ${parsedType$3(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Invalid input: expected ${stringifyPrimitive(issue.values[0])}`;
                  return `Invalid option: expected one of ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Too big: expected ${issue.origin ?? "value"} to have ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
                  return `Too big: expected ${issue.origin ?? "value"} to be ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Too small: expected ${issue.origin} to have ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Too small: expected ${issue.origin} to be ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `Invalid string: must start with "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `Invalid string: must end with "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Invalid string: must include "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Invalid string: must match pattern ${_issue.pattern}`;
                  return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Invalid number: must be a multiple of ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Unrecognized key${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Invalid key in ${issue.origin}`;
              case "invalid_union":
                  return "Invalid input";
              case "invalid_element":
                  return `Invalid value in ${issue.origin}`;
              default:
                  return `Invalid input`;
          }
      };
  };
  function en () {
      return {
          localeError: error$y(),
      };
  }

  const parsedType$2 = (data) => {
      const t = typeof data;
      switch (t) {
          case "number": {
              return Number.isNaN(data) ? "NaN" : "nombro";
          }
          case "object": {
              if (Array.isArray(data)) {
                  return "tabelo";
              }
              if (data === null) {
                  return "senvalora";
              }
              if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                  return data.constructor.name;
              }
          }
      }
      return t;
  };
  const error$x = () => {
      const Sizable = {
          string: { unit: "karaktrojn", verb: "havi" },
          file: { unit: "bajtojn", verb: "havi" },
          array: { unit: "elementojn", verb: "havi" },
          set: { unit: "elementojn", verb: "havi" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const Nouns = {
          regex: "enigo",
          email: "retadreso",
          url: "URL",
          emoji: "emoÄio",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO-datotempo",
          date: "ISO-dato",
          time: "ISO-tempo",
          duration: "ISO-daÅ­ro",
          ipv4: "IPv4-adreso",
          ipv6: "IPv6-adreso",
          cidrv4: "IPv4-rango",
          cidrv6: "IPv6-rango",
          base64: "64-ume kodita karaktraro",
          base64url: "URL-64-ume kodita karaktraro",
          json_string: "JSON-karaktraro",
          e164: "E.164-nombro",
          jwt: "JWT",
          template_literal: "enigo",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Nevalida enigo: atendiÄis ${issue.expected}, riceviÄis ${parsedType$2(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Nevalida enigo: atendiÄis ${stringifyPrimitive(issue.values[0])}`;
                  return `Nevalida opcio: atendiÄis unu el ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Tro granda: atendiÄis ke ${issue.origin ?? "valoro"} havu ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
                  return `Tro granda: atendiÄis ke ${issue.origin ?? "valoro"} havu ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Tro malgranda: atendiÄis ke ${issue.origin} havu ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Tro malgranda: atendiÄis ke ${issue.origin} estu ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Nevalida karaktraro: devas komenciÄi per "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Nevalida karaktraro: devas finiÄi per "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
                  return `Nevalida ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Nevalida nombro: devas esti oblo de ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Nekonata${issue.keys.length > 1 ? "j" : ""} Ålosilo${issue.keys.length > 1 ? "j" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Nevalida Ålosilo en ${issue.origin}`;
              case "invalid_union":
                  return "Nevalida enigo";
              case "invalid_element":
                  return `Nevalida valoro en ${issue.origin}`;
              default:
                  return `Nevalida enigo`;
          }
      };
  };
  function eo () {
      return {
          localeError: error$x(),
      };
  }

  const error$w = () => {
      const Sizable = {
          string: { unit: "caracteres", verb: "tener" },
          file: { unit: "bytes", verb: "tener" },
          array: { unit: "elementos", verb: "tener" },
          set: { unit: "elementos", verb: "tener" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "nÃºmero";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "arreglo";
                  }
                  if (data === null) {
                      return "nulo";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "entrada",
          email: "direcciÃ³n de correo electrÃ³nico",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "fecha y hora ISO",
          date: "fecha ISO",
          time: "hora ISO",
          duration: "duraciÃ³n ISO",
          ipv4: "direcciÃ³n IPv4",
          ipv6: "direcciÃ³n IPv6",
          cidrv4: "rango IPv4",
          cidrv6: "rango IPv6",
          base64: "cadena codificada en base64",
          base64url: "URL codificada en base64",
          json_string: "cadena JSON",
          e164: "nÃºmero E.164",
          jwt: "JWT",
          template_literal: "entrada",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Entrada invÃ¡lida: se esperaba ${issue.expected}, recibido ${parsedType(issue.input)}`;
              // return `Entrada invÃ¡lida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Entrada invÃ¡lida: se esperaba ${stringifyPrimitive(issue.values[0])}`;
                  return `OpciÃ³n invÃ¡lida: se esperaba una de ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Demasiado grande: se esperaba que ${issue.origin ?? "valor"} tuviera ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementos"}`;
                  return `Demasiado grande: se esperaba que ${issue.origin ?? "valor"} fuera ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Demasiado pequeÃ±o: se esperaba que ${issue.origin} tuviera ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Demasiado pequeÃ±o: se esperaba que ${issue.origin} fuera ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Cadena invÃ¡lida: debe comenzar con "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Cadena invÃ¡lida: debe terminar en "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Cadena invÃ¡lida: debe incluir "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Cadena invÃ¡lida: debe coincidir con el patrÃ³n ${_issue.pattern}`;
                  return `InvÃ¡lido ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `NÃºmero invÃ¡lido: debe ser mÃºltiplo de ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Llave${issue.keys.length > 1 ? "s" : ""} desconocida${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Llave invÃ¡lida en ${issue.origin}`;
              case "invalid_union":
                  return "Entrada invÃ¡lida";
              case "invalid_element":
                  return `Valor invÃ¡lido en ${issue.origin}`;
              default:
                  return `Entrada invÃ¡lida`;
          }
      };
  };
  function es () {
      return {
          localeError: error$w(),
      };
  }

  const error$v = () => {
      const Sizable = {
          string: { unit: "Ú©Ø§Ø±Ø§Ú©ØªØ±", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
          file: { unit: "Ø¨Ø§ÛŒØª", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
          array: { unit: "Ø¢ÛŒØªÙ…", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
          set: { unit: "Ø¢ÛŒØªÙ…", verb: "Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Ø¹Ø¯Ø¯";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "Ø¢Ø±Ø§ÛŒÙ‡";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "ÙˆØ±ÙˆØ¯ÛŒ",
          email: "Ø¢Ø¯Ø±Ø³ Ø§ÛŒÙ…ÛŒÙ„",
          url: "URL",
          emoji: "Ø§ÛŒÙ…ÙˆØ¬ÛŒ",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ØªØ§Ø±ÛŒØ® Ùˆ Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
          date: "ØªØ§Ø±ÛŒØ® Ø§ÛŒØ²Ùˆ",
          time: "Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
          duration: "Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø§ÛŒØ²Ùˆ",
          ipv4: "IPv4 Ø¢Ø¯Ø±Ø³",
          ipv6: "IPv6 Ø¢Ø¯Ø±Ø³",
          cidrv4: "IPv4 Ø¯Ø§Ù…Ù†Ù‡",
          cidrv6: "IPv6 Ø¯Ø§Ù…Ù†Ù‡",
          base64: "base64-encoded Ø±Ø´ØªÙ‡",
          base64url: "base64url-encoded Ø±Ø´ØªÙ‡",
          json_string: "JSON Ø±Ø´ØªÙ‡",
          e164: "E.164 Ø¹Ø¯Ø¯",
          jwt: "JWT",
          template_literal: "ÙˆØ±ÙˆØ¯ÛŒ",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ${issue.expected} Ù…ÛŒâ€ŒØ¨ÙˆØ¯ØŒ ${parsedType(issue.input)} Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯`;
              case "invalid_value":
                  if (issue.values.length === 1) {
                      return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ${stringifyPrimitive(issue.values[0])} Ù…ÛŒâ€ŒØ¨ÙˆØ¯`;
                  }
                  return `Ú¯Ø²ÛŒÙ†Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ù…ÛŒâ€ŒØ¨Ø§ÛŒØ³Øª ÛŒÚ©ÛŒ Ø§Ø² ${joinValues(issue.values, "|")} Ù…ÛŒâ€ŒØ¨ÙˆØ¯`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯: ${issue.origin ?? "Ù…Ù‚Ø¯Ø§Ø±"} Ø¨Ø§ÛŒØ¯ ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±"} Ø¨Ø§Ø´Ø¯`;
                  }
                  return `Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯: ${issue.origin ?? "Ù…Ù‚Ø¯Ø§Ø±"} Ø¨Ø§ÛŒØ¯ ${adj}${issue.maximum.toString()} Ø¨Ø§Ø´Ø¯`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©: ${issue.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue.minimum.toString()} ${sizing.unit} Ø¨Ø§Ø´Ø¯`;
                  }
                  return `Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©: ${issue.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue.minimum.toString()} Ø¨Ø§Ø´Ø¯`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ "${_issue.prefix}" Ø´Ø±ÙˆØ¹ Ø´ÙˆØ¯`;
                  }
                  if (_issue.format === "ends_with") {
                      return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ "${_issue.suffix}" ØªÙ…Ø§Ù… Ø´ÙˆØ¯`;
                  }
                  if (_issue.format === "includes") {
                      return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„ "${_issue.includes}" Ø¨Ø§Ø´Ø¯`;
                  }
                  if (_issue.format === "regex") {
                      return `Ø±Ø´ØªÙ‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ø¨Ø§ Ø§Ù„Ú¯ÙˆÛŒ ${_issue.pattern} Ù…Ø·Ø§Ø¨Ù‚Øª Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯`;
                  }
                  return `${Nouns[_issue.format] ?? issue.format} Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
              }
              case "not_multiple_of":
                  return `Ø¹Ø¯Ø¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø¨Ø§ÛŒØ¯ Ù…Ø¶Ø±Ø¨ ${issue.divisor} Ø¨Ø§Ø´Ø¯`;
              case "unrecognized_keys":
                  return `Ú©Ù„ÛŒØ¯${issue.keys.length > 1 ? "Ù‡Ø§ÛŒ" : ""} Ù†Ø§Ø´Ù†Ø§Ø³: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Ú©Ù„ÛŒØ¯ Ù†Ø§Ø´Ù†Ø§Ø³ Ø¯Ø± ${issue.origin}`;
              case "invalid_union":
                  return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
              case "invalid_element":
                  return `Ù…Ù‚Ø¯Ø§Ø± Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¯Ø± ${issue.origin}`;
              default:
                  return `ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±`;
          }
      };
  };
  function fa () {
      return {
          localeError: error$v(),
      };
  }

  const error$u = () => {
      const Sizable = {
          string: { unit: "merkkiÃ¤", subject: "merkkijonon" },
          file: { unit: "tavua", subject: "tiedoston" },
          array: { unit: "alkiota", subject: "listan" },
          set: { unit: "alkiota", subject: "joukon" },
          number: { unit: "", subject: "luvun" },
          bigint: { unit: "", subject: "suuren kokonaisluvun" },
          int: { unit: "", subject: "kokonaisluvun" },
          date: { unit: "", subject: "pÃ¤ivÃ¤mÃ¤Ã¤rÃ¤n" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "sÃ¤Ã¤nnÃ¶llinen lauseke",
          email: "sÃ¤hkÃ¶postiosoite",
          url: "URL-osoite",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO-aikaleima",
          date: "ISO-pÃ¤ivÃ¤mÃ¤Ã¤rÃ¤",
          time: "ISO-aika",
          duration: "ISO-kesto",
          ipv4: "IPv4-osoite",
          ipv6: "IPv6-osoite",
          cidrv4: "IPv4-alue",
          cidrv6: "IPv6-alue",
          base64: "base64-koodattu merkkijono",
          base64url: "base64url-koodattu merkkijono",
          json_string: "JSON-merkkijono",
          e164: "E.164-luku",
          jwt: "JWT",
          template_literal: "templaattimerkkijono",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Virheellinen tyyppi: odotettiin ${issue.expected}, oli ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Virheellinen syÃ¶te: tÃ¤ytyy olla ${stringifyPrimitive(issue.values[0])}`;
                  return `Virheellinen valinta: tÃ¤ytyy olla yksi seuraavista: ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Liian suuri: ${sizing.subject} tÃ¤ytyy olla ${adj}${issue.maximum.toString()} ${sizing.unit}`.trim();
                  }
                  return `Liian suuri: arvon tÃ¤ytyy olla ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Liian pieni: ${sizing.subject} tÃ¤ytyy olla ${adj}${issue.minimum.toString()} ${sizing.unit}`.trim();
                  }
                  return `Liian pieni: arvon tÃ¤ytyy olla ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Virheellinen syÃ¶te: tÃ¤ytyy alkaa "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Virheellinen syÃ¶te: tÃ¤ytyy loppua "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Virheellinen syÃ¶te: tÃ¤ytyy sisÃ¤ltÃ¤Ã¤ "${_issue.includes}"`;
                  if (_issue.format === "regex") {
                      return `Virheellinen syÃ¶te: tÃ¤ytyy vastata sÃ¤Ã¤nnÃ¶llistÃ¤ lauseketta ${_issue.pattern}`;
                  }
                  return `Virheellinen ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Virheellinen luku: tÃ¤ytyy olla luvun ${issue.divisor} monikerta`;
              case "unrecognized_keys":
                  return `${issue.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return "Virheellinen avain tietueessa";
              case "invalid_union":
                  return "Virheellinen unioni";
              case "invalid_element":
                  return "Virheellinen arvo joukossa";
              default:
                  return `Virheellinen syÃ¶te`;
          }
      };
  };
  function fi () {
      return {
          localeError: error$u(),
      };
  }

  const error$t = () => {
      const Sizable = {
          string: { unit: "caractÃ¨res", verb: "avoir" },
          file: { unit: "octets", verb: "avoir" },
          array: { unit: "Ã©lÃ©ments", verb: "avoir" },
          set: { unit: "Ã©lÃ©ments", verb: "avoir" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "nombre";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "tableau";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "entrÃ©e",
          email: "adresse e-mail",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "date et heure ISO",
          date: "date ISO",
          time: "heure ISO",
          duration: "durÃ©e ISO",
          ipv4: "adresse IPv4",
          ipv6: "adresse IPv6",
          cidrv4: "plage IPv4",
          cidrv6: "plage IPv6",
          base64: "chaÃ®ne encodÃ©e en base64",
          base64url: "chaÃ®ne encodÃ©e en base64url",
          json_string: "chaÃ®ne JSON",
          e164: "numÃ©ro E.164",
          jwt: "JWT",
          template_literal: "entrÃ©e",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `EntrÃ©e invalide : ${issue.expected} attendu, ${parsedType(issue.input)} reÃ§u`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `EntrÃ©e invalide : ${stringifyPrimitive(issue.values[0])} attendu`;
                  return `Option invalide : une valeur parmi ${joinValues(issue.values, "|")} attendue`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Trop grand : ${issue.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Ã©lÃ©ment(s)"}`;
                  return `Trop grand : ${issue.origin ?? "valeur"} doit Ãªtre ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Trop petit : ${issue.origin} doit ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Trop petit : ${issue.origin} doit Ãªtre ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `ChaÃ®ne invalide : doit commencer par "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `ChaÃ®ne invalide : doit se terminer par "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `ChaÃ®ne invalide : doit inclure "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `ChaÃ®ne invalide : doit correspondre au modÃ¨le ${_issue.pattern}`;
                  return `${Nouns[_issue.format] ?? issue.format} invalide`;
              }
              case "not_multiple_of":
                  return `Nombre invalide : doit Ãªtre un multiple de ${issue.divisor}`;
              case "unrecognized_keys":
                  return `ClÃ©${issue.keys.length > 1 ? "s" : ""} non reconnue${issue.keys.length > 1 ? "s" : ""} : ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `ClÃ© invalide dans ${issue.origin}`;
              case "invalid_union":
                  return "EntrÃ©e invalide";
              case "invalid_element":
                  return `Valeur invalide dans ${issue.origin}`;
              default:
                  return `EntrÃ©e invalide`;
          }
      };
  };
  function fr () {
      return {
          localeError: error$t(),
      };
  }

  const error$s = () => {
      const Sizable = {
          string: { unit: "caractÃ¨res", verb: "avoir" },
          file: { unit: "octets", verb: "avoir" },
          array: { unit: "Ã©lÃ©ments", verb: "avoir" },
          set: { unit: "Ã©lÃ©ments", verb: "avoir" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "entrÃ©e",
          email: "adresse courriel",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "date-heure ISO",
          date: "date ISO",
          time: "heure ISO",
          duration: "durÃ©e ISO",
          ipv4: "adresse IPv4",
          ipv6: "adresse IPv6",
          cidrv4: "plage IPv4",
          cidrv6: "plage IPv6",
          base64: "chaÃ®ne encodÃ©e en base64",
          base64url: "chaÃ®ne encodÃ©e en base64url",
          json_string: "chaÃ®ne JSON",
          e164: "numÃ©ro E.164",
          jwt: "JWT",
          template_literal: "entrÃ©e",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `EntrÃ©e invalide : attendu ${issue.expected}, reÃ§u ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `EntrÃ©e invalide : attendu ${stringifyPrimitive(issue.values[0])}`;
                  return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "â‰¤" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Trop grand : attendu que ${issue.origin ?? "la valeur"} ait ${adj}${issue.maximum.toString()} ${sizing.unit}`;
                  return `Trop grand : attendu que ${issue.origin ?? "la valeur"} soit ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? "â‰¥" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Trop petit : attendu que ${issue.origin} ait ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Trop petit : attendu que ${issue.origin} soit ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `ChaÃ®ne invalide : doit commencer par "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `ChaÃ®ne invalide : doit se terminer par "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `ChaÃ®ne invalide : doit inclure "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `ChaÃ®ne invalide : doit correspondre au motif ${_issue.pattern}`;
                  return `${Nouns[_issue.format] ?? issue.format} invalide`;
              }
              case "not_multiple_of":
                  return `Nombre invalide : doit Ãªtre un multiple de ${issue.divisor}`;
              case "unrecognized_keys":
                  return `ClÃ©${issue.keys.length > 1 ? "s" : ""} non reconnue${issue.keys.length > 1 ? "s" : ""} : ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `ClÃ© invalide dans ${issue.origin}`;
              case "invalid_union":
                  return "EntrÃ©e invalide";
              case "invalid_element":
                  return `Valeur invalide dans ${issue.origin}`;
              default:
                  return `EntrÃ©e invalide`;
          }
      };
  };
  function frCA () {
      return {
          localeError: error$s(),
      };
  }

  const error$r = () => {
      const Sizable = {
          string: { unit: "××•×ª×™×•×ª", verb: "×œ×›×œ×•×œ" },
          file: { unit: "×‘×™×™×˜×™×", verb: "×œ×›×œ×•×œ" },
          array: { unit: "×¤×¨×™×˜×™×", verb: "×œ×›×œ×•×œ" },
          set: { unit: "×¤×¨×™×˜×™×", verb: "×œ×›×œ×•×œ" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "×§×œ×˜",
          email: "×›×ª×•×‘×ª ××™×ž×™×™×œ",
          url: "×›×ª×•×‘×ª ×¨×©×ª",
          emoji: "××™×ž×•×’'×™",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "×ª××¨×™×š ×•×–×ž×Ÿ ISO",
          date: "×ª××¨×™×š ISO",
          time: "×–×ž×Ÿ ISO",
          duration: "×ž×©×š ×–×ž×Ÿ ISO",
          ipv4: "×›×ª×•×‘×ª IPv4",
          ipv6: "×›×ª×•×‘×ª IPv6",
          cidrv4: "×˜×•×•×— IPv4",
          cidrv6: "×˜×•×•×— IPv6",
          base64: "×ž×—×¨×•×–×ª ×‘×‘×¡×™×¡ 64",
          base64url: "×ž×—×¨×•×–×ª ×‘×‘×¡×™×¡ 64 ×œ×›×ª×•×‘×•×ª ×¨×©×ª",
          json_string: "×ž×—×¨×•×–×ª JSON",
          e164: "×ž×¡×¤×¨ E.164",
          jwt: "JWT",
          template_literal: "×§×œ×˜",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ${issue.expected}, ×”×ª×§×‘×œ ${parsedType(issue.input)}`;
              // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ${stringifyPrimitive(issue.values[0])}`;
                  return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ: ×¦×¨×™×š ××—×ª ×ž×”××¤×©×¨×•×™×•×ª  ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `×’×“×•×œ ×ž×“×™: ${issue.origin ?? "value"} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
                  return `×’×“×•×œ ×ž×“×™: ${issue.origin ?? "value"} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `×§×˜×Ÿ ×ž×“×™: ${issue.origin} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `×§×˜×Ÿ ×ž×“×™: ${issue.origin} ×¦×¨×™×š ×œ×”×™×•×ª ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×ª×—×™×œ ×‘"${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×¡×ª×™×™× ×‘ "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×›×œ×•×œ "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `×ž×—×¨×•×–×ª ×œ× ×ª×§×™× ×”: ×—×™×™×‘×ª ×œ×”×ª××™× ×œ×ª×‘× ×™×ª ${_issue.pattern}`;
                  return `${Nouns[_issue.format] ?? issue.format} ×œ× ×ª×§×™×Ÿ`;
              }
              case "not_multiple_of":
                  return `×ž×¡×¤×¨ ×œ× ×ª×§×™×Ÿ: ×—×™×™×‘ ×œ×”×™×•×ª ×ž×›×¤×œ×” ×©×œ ${issue.divisor}`;
              case "unrecognized_keys":
                  return `×ž×¤×ª×—${issue.keys.length > 1 ? "×•×ª" : ""} ×œ× ×ž×–×•×”${issue.keys.length > 1 ? "×™×" : "×”"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `×ž×¤×ª×— ×œ× ×ª×§×™×Ÿ ×‘${issue.origin}`;
              case "invalid_union":
                  return "×§×œ×˜ ×œ× ×ª×§×™×Ÿ";
              case "invalid_element":
                  return `×¢×¨×š ×œ× ×ª×§×™×Ÿ ×‘${issue.origin}`;
              default:
                  return `×§×œ×˜ ×œ× ×ª×§×™×Ÿ`;
          }
      };
  };
  function he () {
      return {
          localeError: error$r(),
      };
  }

  const error$q = () => {
      const Sizable = {
          string: { unit: "karakter", verb: "legyen" },
          file: { unit: "byte", verb: "legyen" },
          array: { unit: "elem", verb: "legyen" },
          set: { unit: "elem", verb: "legyen" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "szÃ¡m";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "tÃ¶mb";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "bemenet",
          email: "email cÃ­m",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO idÅ‘bÃ©lyeg",
          date: "ISO dÃ¡tum",
          time: "ISO idÅ‘",
          duration: "ISO idÅ‘intervallum",
          ipv4: "IPv4 cÃ­m",
          ipv6: "IPv6 cÃ­m",
          cidrv4: "IPv4 tartomÃ¡ny",
          cidrv6: "IPv6 tartomÃ¡ny",
          base64: "base64-kÃ³dolt string",
          base64url: "base64url-kÃ³dolt string",
          json_string: "JSON string",
          e164: "E.164 szÃ¡m",
          jwt: "JWT",
          template_literal: "bemenet",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Ã‰rvÃ©nytelen bemenet: a vÃ¡rt Ã©rtÃ©k ${issue.expected}, a kapott Ã©rtÃ©k ${parsedType(issue.input)}`;
              // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Ã‰rvÃ©nytelen bemenet: a vÃ¡rt Ã©rtÃ©k ${stringifyPrimitive(issue.values[0])}`;
                  return `Ã‰rvÃ©nytelen opciÃ³: valamelyik Ã©rtÃ©k vÃ¡rt ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `TÃºl nagy: ${issue.origin ?? "Ã©rtÃ©k"} mÃ©rete tÃºl nagy ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elem"}`;
                  return `TÃºl nagy: a bemeneti Ã©rtÃ©k ${issue.origin ?? "Ã©rtÃ©k"} tÃºl nagy: ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `TÃºl kicsi: a bemeneti Ã©rtÃ©k ${issue.origin} mÃ©rete tÃºl kicsi ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `TÃºl kicsi: a bemeneti Ã©rtÃ©k ${issue.origin} tÃºl kicsi ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Ã‰rvÃ©nytelen string: "${_issue.prefix}" Ã©rtÃ©kkel kell kezdÅ‘dnie`;
                  if (_issue.format === "ends_with")
                      return `Ã‰rvÃ©nytelen string: "${_issue.suffix}" Ã©rtÃ©kkel kell vÃ©gzÅ‘dnie`;
                  if (_issue.format === "includes")
                      return `Ã‰rvÃ©nytelen string: "${_issue.includes}" Ã©rtÃ©ket kell tartalmaznia`;
                  if (_issue.format === "regex")
                      return `Ã‰rvÃ©nytelen string: ${_issue.pattern} mintÃ¡nak kell megfelelnie`;
                  return `Ã‰rvÃ©nytelen ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Ã‰rvÃ©nytelen szÃ¡m: ${issue.divisor} tÃ¶bbszÃ¶rÃ¶sÃ©nek kell lennie`;
              case "unrecognized_keys":
                  return `Ismeretlen kulcs${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Ã‰rvÃ©nytelen kulcs ${issue.origin}`;
              case "invalid_union":
                  return "Ã‰rvÃ©nytelen bemenet";
              case "invalid_element":
                  return `Ã‰rvÃ©nytelen Ã©rtÃ©k: ${issue.origin}`;
              default:
                  return `Ã‰rvÃ©nytelen bemenet`;
          }
      };
  };
  function hu () {
      return {
          localeError: error$q(),
      };
  }

  const error$p = () => {
      const Sizable = {
          string: { unit: "karakter", verb: "memiliki" },
          file: { unit: "byte", verb: "memiliki" },
          array: { unit: "item", verb: "memiliki" },
          set: { unit: "item", verb: "memiliki" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "input",
          email: "alamat email",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "tanggal dan waktu format ISO",
          date: "tanggal format ISO",
          time: "jam format ISO",
          duration: "durasi format ISO",
          ipv4: "alamat IPv4",
          ipv6: "alamat IPv6",
          cidrv4: "rentang alamat IPv4",
          cidrv6: "rentang alamat IPv6",
          base64: "string dengan enkode base64",
          base64url: "string dengan enkode base64url",
          json_string: "string JSON",
          e164: "angka E.164",
          jwt: "JWT",
          template_literal: "input",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Input tidak valid: diharapkan ${issue.expected}, diterima ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Input tidak valid: diharapkan ${stringifyPrimitive(issue.values[0])}`;
                  return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Terlalu besar: diharapkan ${issue.origin ?? "value"} memiliki ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elemen"}`;
                  return `Terlalu besar: diharapkan ${issue.origin ?? "value"} menjadi ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Terlalu kecil: diharapkan ${issue.origin} memiliki ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Terlalu kecil: diharapkan ${issue.origin} menjadi ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `String tidak valid: harus menyertakan "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
                  return `${Nouns[_issue.format] ?? issue.format} tidak valid`;
              }
              case "not_multiple_of":
                  return `Angka tidak valid: harus kelipatan dari ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Kunci tidak dikenali ${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Kunci tidak valid di ${issue.origin}`;
              case "invalid_union":
                  return "Input tidak valid";
              case "invalid_element":
                  return `Nilai tidak valid di ${issue.origin}`;
              default:
                  return `Input tidak valid`;
          }
      };
  };
  function id () {
      return {
          localeError: error$p(),
      };
  }

  const parsedType$1 = (data) => {
      const t = typeof data;
      switch (t) {
          case "number": {
              return Number.isNaN(data) ? "NaN" : "nÃºmer";
          }
          case "object": {
              if (Array.isArray(data)) {
                  return "fylki";
              }
              if (data === null) {
                  return "null";
              }
              if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                  return data.constructor.name;
              }
          }
      }
      return t;
  };
  const error$o = () => {
      const Sizable = {
          string: { unit: "stafi", verb: "aÃ° hafa" },
          file: { unit: "bÃ¦ti", verb: "aÃ° hafa" },
          array: { unit: "hluti", verb: "aÃ° hafa" },
          set: { unit: "hluti", verb: "aÃ° hafa" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const Nouns = {
          regex: "gildi",
          email: "netfang",
          url: "vefslÃ³Ã°",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO dagsetning og tÃ­mi",
          date: "ISO dagsetning",
          time: "ISO tÃ­mi",
          duration: "ISO tÃ­malengd",
          ipv4: "IPv4 address",
          ipv6: "IPv6 address",
          cidrv4: "IPv4 range",
          cidrv6: "IPv6 range",
          base64: "base64-encoded strengur",
          base64url: "base64url-encoded strengur",
          json_string: "JSON strengur",
          e164: "E.164 tÃ¶lugildi",
          jwt: "JWT",
          template_literal: "gildi",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Rangt gildi: ÃžÃº slÃ³st inn ${parsedType$1(issue.input)} Ã¾ar sem Ã¡ aÃ° vera ${issue.expected}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Rangt gildi: gert rÃ¡Ã° fyrir ${stringifyPrimitive(issue.values[0])}`;
                  return `Ã“gilt val: mÃ¡ vera eitt af eftirfarandi ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Of stÃ³rt: gert er rÃ¡Ã° fyrir aÃ° ${issue.origin ?? "gildi"} hafi ${adj}${issue.maximum.toString()} ${sizing.unit ?? "hluti"}`;
                  return `Of stÃ³rt: gert er rÃ¡Ã° fyrir aÃ° ${issue.origin ?? "gildi"} sÃ© ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Of lÃ­tiÃ°: gert er rÃ¡Ã° fyrir aÃ° ${issue.origin} hafi ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Of lÃ­tiÃ°: gert er rÃ¡Ã° fyrir aÃ° ${issue.origin} sÃ© ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `Ã“gildur strengur: verÃ°ur aÃ° byrja Ã¡ "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `Ã“gildur strengur: verÃ°ur aÃ° enda Ã¡ "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Ã“gildur strengur: verÃ°ur aÃ° innihalda "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Ã“gildur strengur: verÃ°ur aÃ° fylgja mynstri ${_issue.pattern}`;
                  return `Rangt ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `RÃ¶ng tala: verÃ°ur aÃ° vera margfeldi af ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Ã“Ã¾ekkt ${issue.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Rangur lykill Ã­ ${issue.origin}`;
              case "invalid_union":
                  return "Rangt gildi";
              case "invalid_element":
                  return `Rangt gildi Ã­ ${issue.origin}`;
              default:
                  return `Rangt gildi`;
          }
      };
  };
  function is () {
      return {
          localeError: error$o(),
      };
  }

  const error$n = () => {
      const Sizable = {
          string: { unit: "caratteri", verb: "avere" },
          file: { unit: "byte", verb: "avere" },
          array: { unit: "elementi", verb: "avere" },
          set: { unit: "elementi", verb: "avere" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "numero";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "vettore";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "input",
          email: "indirizzo email",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "data e ora ISO",
          date: "data ISO",
          time: "ora ISO",
          duration: "durata ISO",
          ipv4: "indirizzo IPv4",
          ipv6: "indirizzo IPv6",
          cidrv4: "intervallo IPv4",
          cidrv6: "intervallo IPv6",
          base64: "stringa codificata in base64",
          base64url: "URL codificata in base64",
          json_string: "stringa JSON",
          e164: "numero E.164",
          jwt: "JWT",
          template_literal: "input",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Input non valido: atteso ${issue.expected}, ricevuto ${parsedType(issue.input)}`;
              // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Input non valido: atteso ${stringifyPrimitive(issue.values[0])}`;
                  return `Opzione non valida: atteso uno tra ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Troppo grande: ${issue.origin ?? "valore"} deve avere ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementi"}`;
                  return `Troppo grande: ${issue.origin ?? "valore"} deve essere ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Troppo piccolo: ${issue.origin} deve avere ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Troppo piccolo: ${issue.origin} deve essere ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Stringa non valida: deve includere "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
                  return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Numero non valido: deve essere un multiplo di ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Chiav${issue.keys.length > 1 ? "i" : "e"} non riconosciut${issue.keys.length > 1 ? "e" : "a"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Chiave non valida in ${issue.origin}`;
              case "invalid_union":
                  return "Input non valido";
              case "invalid_element":
                  return `Valore non valido in ${issue.origin}`;
              default:
                  return `Input non valido`;
          }
      };
  };
  function it () {
      return {
          localeError: error$n(),
      };
  }

  const error$m = () => {
      const Sizable = {
          string: { unit: "æ–‡å­—", verb: "ã§ã‚ã‚‹" },
          file: { unit: "ãƒã‚¤ãƒˆ", verb: "ã§ã‚ã‚‹" },
          array: { unit: "è¦ç´ ", verb: "ã§ã‚ã‚‹" },
          set: { unit: "è¦ç´ ", verb: "ã§ã‚ã‚‹" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "æ•°å€¤";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "é…åˆ—";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "å…¥åŠ›å€¤",
          email: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
          url: "URL",
          emoji: "çµµæ–‡å­—",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISOæ—¥æ™‚",
          date: "ISOæ—¥ä»˜",
          time: "ISOæ™‚åˆ»",
          duration: "ISOæœŸé–“",
          ipv4: "IPv4ã‚¢ãƒ‰ãƒ¬ã‚¹",
          ipv6: "IPv6ã‚¢ãƒ‰ãƒ¬ã‚¹",
          cidrv4: "IPv4ç¯„å›²",
          cidrv6: "IPv6ç¯„å›²",
          base64: "base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—",
          base64url: "base64urlã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—",
          json_string: "JSONæ–‡å­—åˆ—",
          e164: "E.164ç•ªå·",
          jwt: "JWT",
          template_literal: "å…¥åŠ›å€¤",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ç„¡åŠ¹ãªå…¥åŠ›: ${issue.expected}ãŒæœŸå¾…ã•ã‚Œã¾ã—ãŸãŒã€${parsedType(issue.input)}ãŒå…¥åŠ›ã•ã‚Œã¾ã—ãŸ`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `ç„¡åŠ¹ãªå…¥åŠ›: ${stringifyPrimitive(issue.values[0])}ãŒæœŸå¾…ã•ã‚Œã¾ã—ãŸ`;
                  return `ç„¡åŠ¹ãªé¸æŠž: ${joinValues(issue.values, "ã€")}ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
              case "too_big": {
                  const adj = issue.inclusive ? "ä»¥ä¸‹ã§ã‚ã‚‹" : "ã‚ˆã‚Šå°ã•ã„";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `å¤§ãã™ãŽã‚‹å€¤: ${issue.origin ?? "å€¤"}ã¯${issue.maximum.toString()}${sizing.unit ?? "è¦ç´ "}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
                  return `å¤§ãã™ãŽã‚‹å€¤: ${issue.origin ?? "å€¤"}ã¯${issue.maximum.toString()}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? "ä»¥ä¸Šã§ã‚ã‚‹" : "ã‚ˆã‚Šå¤§ãã„";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `å°ã•ã™ãŽã‚‹å€¤: ${issue.origin}ã¯${issue.minimum.toString()}${sizing.unit}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
                  return `å°ã•ã™ãŽã‚‹å€¤: ${issue.origin}ã¯${issue.minimum.toString()}${adj}å¿…è¦ãŒã‚ã‚Šã¾ã™`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.prefix}"ã§å§‹ã¾ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
                  if (_issue.format === "ends_with")
                      return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.suffix}"ã§çµ‚ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
                  if (_issue.format === "includes")
                      return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: "${_issue.includes}"ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™`;
                  if (_issue.format === "regex")
                      return `ç„¡åŠ¹ãªæ–‡å­—åˆ—: ãƒ‘ã‚¿ãƒ¼ãƒ³${_issue.pattern}ã«ä¸€è‡´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
                  return `ç„¡åŠ¹ãª${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `ç„¡åŠ¹ãªæ•°å€¤: ${issue.divisor}ã®å€æ•°ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`;
              case "unrecognized_keys":
                  return `èªè­˜ã•ã‚Œã¦ã„ãªã„ã‚­ãƒ¼${issue.keys.length > 1 ? "ç¾¤" : ""}: ${joinValues(issue.keys, "ã€")}`;
              case "invalid_key":
                  return `${issue.origin}å†…ã®ç„¡åŠ¹ãªã‚­ãƒ¼`;
              case "invalid_union":
                  return "ç„¡åŠ¹ãªå…¥åŠ›";
              case "invalid_element":
                  return `${issue.origin}å†…ã®ç„¡åŠ¹ãªå€¤`;
              default:
                  return `ç„¡åŠ¹ãªå…¥åŠ›`;
          }
      };
  };
  function ja () {
      return {
          localeError: error$m(),
      };
  }

  const error$l = () => {
      const Sizable = {
          string: { unit: "ážáž½áž¢áž€áŸ’ážŸážš", verb: "áž‚áž½ážšáž˜áž¶áž“" },
          file: { unit: "áž”áŸƒ", verb: "áž‚áž½ážšáž˜áž¶áž“" },
          array: { unit: "áž’áž¶ážáž»", verb: "áž‚áž½ážšáž˜áž¶áž“" },
          set: { unit: "áž’áž¶ážáž»", verb: "áž‚áž½ážšáž˜áž¶áž“" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "áž˜áž·áž“áž˜áŸ‚áž“áž‡áž¶áž›áŸáž (NaN)" : "áž›áŸáž";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "áž¢áž¶ážšáŸ (Array)";
                  }
                  if (data === null) {
                      return "áž‚áŸ’áž˜áž¶áž“ážáž˜áŸ’áž›áŸƒ (null)";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›",
          email: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“áž¢áŸŠáž¸áž˜áŸ‚áž›",
          url: "URL",
          emoji: "ážŸáž‰áŸ’áž‰áž¶áž¢áž¶ážšáž˜áŸ’áž˜ážŽáŸ",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ áž“áž·áž„áž˜áŸ‰áŸ„áž„ ISO",
          date: "áž€áž¶áž›áž”ážšáž·áž…áŸ’áž†áŸáž‘ ISO",
          time: "áž˜áŸ‰áŸ„áž„ ISO",
          duration: "ážšáž™áŸˆáž–áŸáž› ISO",
          ipv4: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv4",
          ipv6: "áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv6",
          cidrv4: "ážŠáŸ‚áž“áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv4",
          cidrv6: "ážŠáŸ‚áž“áž¢áž¶ážŸáž™ážŠáŸ’áž‹áž¶áž“ IPv6",
          base64: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž¢áŸŠáž·áž€áž¼ážŠ base64",
          base64url: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž¢áŸŠáž·áž€áž¼ážŠ base64url",
          json_string: "ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážš JSON",
          e164: "áž›áŸáž E.164",
          jwt: "JWT",
          template_literal: "áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue.expected} áž”áŸ‰áž»áž“áŸ’ážáŸ‚áž‘áž‘áž½áž›áž”áž¶áž“ ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž”áž‰áŸ’áž…áž¼áž›áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${stringifyPrimitive(issue.values[0])}`;
                  return `áž‡áž˜áŸ’ážšáž¾ážŸáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž‡áž¶áž˜áž½áž™áž€áŸ’áž“áž»áž„áž…áŸ†ážŽáŸ„áž˜ ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `áž’áŸ†áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue.origin ?? "ážáž˜áŸ’áž›áŸƒ"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "áž’áž¶ážáž»"}`;
                  return `áž’áŸ†áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue.origin ?? "ážáž˜áŸ’áž›áŸƒ"} ${adj} ${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `ážáž¼áž…áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `ážáž¼áž…áž–áŸáž€áŸ– ážáŸ’ážšáž¼ážœáž€áž¶ážš ${issue.origin} ${adj} ${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ážŠáŸ„áž™ "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž”áž‰áŸ’áž…áž”áŸ‹ážŠáŸ„áž™ "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœáž˜áž¶áž“ "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `ážáŸ’ážŸáŸ‚áž¢áž€áŸ’ážŸážšáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœážáŸ‚áž•áŸ’áž‚áž¼áž•áŸ’áž‚áž„áž“áž¹áž„áž‘áž˜áŸ’ážšáž„áŸ‹ážŠáŸ‚áž›áž”áž¶áž“áž€áŸ†ážŽážáŸ‹ ${_issue.pattern}`;
                  return `áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `áž›áŸážáž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáŸ– ážáŸ’ážšáž¼ážœážáŸ‚áž‡áž¶áž–áž áž»áž‚áž»ážŽáž“áŸƒ ${issue.divisor}`;
              case "unrecognized_keys":
                  return `ážšáž€ážƒáž¾áž‰ážŸáŸ„áž˜áž·áž“ážŸáŸ’áž‚áž¶áž›áŸ‹áŸ– ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `ážŸáŸ„áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž“áŸ…áž€áŸ’áž“áž»áž„ ${issue.origin}`;
              case "invalid_union":
                  return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœ`;
              case "invalid_element":
                  return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœáž“áŸ…áž€áŸ’áž“áž»áž„ ${issue.origin}`;
              default:
                  return `áž‘áž·áž“áŸ’áž“áž“áŸáž™áž˜áž·áž“ážáŸ’ážšáž¹áž˜ážáŸ’ážšáž¼ážœ`;
          }
      };
  };
  function kh () {
      return {
          localeError: error$l(),
      };
  }

  const error$k = () => {
      const Sizable = {
          string: { unit: "ë¬¸ìž", verb: "to have" },
          file: { unit: "ë°”ì´íŠ¸", verb: "to have" },
          array: { unit: "ê°œ", verb: "to have" },
          set: { unit: "ê°œ", verb: "to have" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "ìž…ë ¥",
          email: "ì´ë©”ì¼ ì£¼ì†Œ",
          url: "URL",
          emoji: "ì´ëª¨ì§€",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO ë‚ ì§œì‹œê°„",
          date: "ISO ë‚ ì§œ",
          time: "ISO ì‹œê°„",
          duration: "ISO ê¸°ê°„",
          ipv4: "IPv4 ì£¼ì†Œ",
          ipv6: "IPv6 ì£¼ì†Œ",
          cidrv4: "IPv4 ë²”ìœ„",
          cidrv6: "IPv6 ë²”ìœ„",
          base64: "base64 ì¸ì½”ë”© ë¬¸ìžì—´",
          base64url: "base64url ì¸ì½”ë”© ë¬¸ìžì—´",
          json_string: "JSON ë¬¸ìžì—´",
          e164: "E.164 ë²ˆí˜¸",
          jwt: "JWT",
          template_literal: "ìž…ë ¥",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ìž˜ëª»ëœ ìž…ë ¥: ì˜ˆìƒ íƒ€ìž…ì€ ${issue.expected}, ë°›ì€ íƒ€ìž…ì€ ${parsedType(issue.input)}ìž…ë‹ˆë‹¤`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `ìž˜ëª»ëœ ìž…ë ¥: ê°’ì€ ${stringifyPrimitive(issue.values[0])} ì´ì–´ì•¼ í•©ë‹ˆë‹¤`;
                  return `ìž˜ëª»ëœ ì˜µì…˜: ${joinValues(issue.values, "ë˜ëŠ” ")} ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤`;
              case "too_big": {
                  const adj = issue.inclusive ? "ì´í•˜" : "ë¯¸ë§Œ";
                  const suffix = adj === "ë¯¸ë§Œ" ? "ì´ì–´ì•¼ í•©ë‹ˆë‹¤" : "ì—¬ì•¼ í•©ë‹ˆë‹¤";
                  const sizing = getSizing(issue.origin);
                  const unit = sizing?.unit ?? "ìš”ì†Œ";
                  if (sizing)
                      return `${issue.origin ?? "ê°’"}ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${issue.maximum.toString()}${unit} ${adj}${suffix}`;
                  return `${issue.origin ?? "ê°’"}ì´ ë„ˆë¬´ í½ë‹ˆë‹¤: ${issue.maximum.toString()} ${adj}${suffix}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? "ì´ìƒ" : "ì´ˆê³¼";
                  const suffix = adj === "ì´ìƒ" ? "ì´ì–´ì•¼ í•©ë‹ˆë‹¤" : "ì—¬ì•¼ í•©ë‹ˆë‹¤";
                  const sizing = getSizing(issue.origin);
                  const unit = sizing?.unit ?? "ìš”ì†Œ";
                  if (sizing) {
                      return `${issue.origin ?? "ê°’"}ì´ ë„ˆë¬´ ìž‘ìŠµë‹ˆë‹¤: ${issue.minimum.toString()}${unit} ${adj}${suffix}`;
                  }
                  return `${issue.origin ?? "ê°’"}ì´ ë„ˆë¬´ ìž‘ìŠµë‹ˆë‹¤: ${issue.minimum.toString()} ${adj}${suffix}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.prefix}"(ìœ¼)ë¡œ ì‹œìž‘í•´ì•¼ í•©ë‹ˆë‹¤`;
                  }
                  if (_issue.format === "ends_with")
                      return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.suffix}"(ìœ¼)ë¡œ ëë‚˜ì•¼ í•©ë‹ˆë‹¤`;
                  if (_issue.format === "includes")
                      return `ìž˜ëª»ëœ ë¬¸ìžì—´: "${_issue.includes}"ì„(ë¥¼) í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤`;
                  if (_issue.format === "regex")
                      return `ìž˜ëª»ëœ ë¬¸ìžì—´: ì •ê·œì‹ ${_issue.pattern} íŒ¨í„´ê³¼ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤`;
                  return `ìž˜ëª»ëœ ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `ìž˜ëª»ëœ ìˆ«ìž: ${issue.divisor}ì˜ ë°°ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤`;
              case "unrecognized_keys":
                  return `ì¸ì‹í•  ìˆ˜ ì—†ëŠ” í‚¤: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `ìž˜ëª»ëœ í‚¤: ${issue.origin}`;
              case "invalid_union":
                  return `ìž˜ëª»ëœ ìž…ë ¥`;
              case "invalid_element":
                  return `ìž˜ëª»ëœ ê°’: ${issue.origin}`;
              default:
                  return `ìž˜ëª»ëœ ìž…ë ¥`;
          }
      };
  };
  function ko () {
      return {
          localeError: error$k(),
      };
  }

  const error$j = () => {
      const Sizable = {
          string: { unit: "Ð·Ð½Ð°Ñ†Ð¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
          file: { unit: "Ð±Ð°Ñ˜Ñ‚Ð¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
          array: { unit: "ÑÑ‚Ð°Ð²ÐºÐ¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
          set: { unit: "ÑÑ‚Ð°Ð²ÐºÐ¸", verb: "Ð´Ð° Ð¸Ð¼Ð°Ð°Ñ‚" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Ð±Ñ€Ð¾Ñ˜";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "Ð½Ð¸Ð·Ð°";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "Ð²Ð½ÐµÑ",
          email: "Ð°Ð´Ñ€ÐµÑÐ° Ð½Ð° Ðµ-Ð¿Ð¾ÑˆÑ‚Ð°",
          url: "URL",
          emoji: "ÐµÐ¼Ð¾ÑŸÐ¸",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO Ð´Ð°Ñ‚ÑƒÐ¼ Ð¸ Ð²Ñ€ÐµÐ¼Ðµ",
          date: "ISO Ð´Ð°Ñ‚ÑƒÐ¼",
          time: "ISO Ð²Ñ€ÐµÐ¼Ðµ",
          duration: "ISO Ð²Ñ€ÐµÐ¼ÐµÑ‚Ñ€Ð°ÐµÑšÐµ",
          ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑÐ°",
          ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑÐ°",
          cidrv4: "IPv4 Ð¾Ð¿ÑÐµÐ³",
          cidrv6: "IPv6 Ð¾Ð¿ÑÐµÐ³",
          base64: "base64-ÐµÐ½ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½Ð° Ð½Ð¸Ð·Ð°",
          base64url: "base64url-ÐµÐ½ÐºÐ¾Ð´Ð¸Ñ€Ð°Ð½Ð° Ð½Ð¸Ð·Ð°",
          json_string: "JSON Ð½Ð¸Ð·Ð°",
          e164: "E.164 Ð±Ñ€Ð¾Ñ˜",
          jwt: "JWT",
          template_literal: "Ð²Ð½ÐµÑ",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue.expected}, Ð¿Ñ€Ð¸Ð¼ÐµÐ½Ð¾ ${parsedType(issue.input)}`;
              // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Invalid input: expected ${stringifyPrimitive(issue.values[0])}`;
                  return `Ð“Ñ€ÐµÑˆÐ°Ð½Ð° Ð¾Ð¿Ñ†Ð¸Ñ˜Ð°: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ÐµÐ´Ð½Ð° ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð³Ð¾Ð»ÐµÐ¼: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue.origin ?? "Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð°"} Ð´Ð° Ð¸Ð¼Ð° ${adj}${issue.maximum.toString()} ${sizing.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¸"}`;
                  return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð³Ð¾Ð»ÐµÐ¼: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue.origin ?? "Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð°"} Ð´Ð° Ð±Ð¸Ð´Ðµ ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð¼Ð°Ð»: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue.origin} Ð´Ð° Ð¸Ð¼Ð° ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `ÐŸÑ€ÐµÐ¼Ð½Ð¾Ð³Ñƒ Ð¼Ð°Ð»: ÑÐµ Ð¾Ñ‡ÐµÐºÑƒÐ²Ð° ${issue.origin} Ð´Ð° Ð±Ð¸Ð´Ðµ ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð·Ð°Ð¿Ð¾Ñ‡Ð½ÑƒÐ²Ð° ÑÐ¾ "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð·Ð°Ð²Ñ€ÑˆÑƒÐ²Ð° ÑÐ¾ "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð²ÐºÐ»ÑƒÑ‡ÑƒÐ²Ð° "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `ÐÐµÐ²Ð°Ð¶ÐµÑ‡ÐºÐ° Ð½Ð¸Ð·Ð°: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð¾Ð´Ð³Ð¾Ð°Ñ€Ð° Ð½Ð° Ð¿Ð°Ñ‚ÐµÑ€Ð½Ð¾Ñ‚ ${_issue.pattern}`;
                  return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð±Ñ€Ð¾Ñ˜: Ð¼Ð¾Ñ€Ð° Ð´Ð° Ð±Ð¸Ð´Ðµ Ð´ÐµÐ»Ð¸Ð² ÑÐ¾ ${issue.divisor}`;
              case "unrecognized_keys":
                  return `${issue.keys.length > 1 ? "ÐÐµÐ¿Ñ€ÐµÐ¿Ð¾Ð·Ð½Ð°ÐµÐ½Ð¸ ÐºÐ»ÑƒÑ‡ÐµÐ²Ð¸" : "ÐÐµÐ¿Ñ€ÐµÐ¿Ð¾Ð·Ð½Ð°ÐµÐ½ ÐºÐ»ÑƒÑ‡"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Ð“Ñ€ÐµÑˆÐµÐ½ ÐºÐ»ÑƒÑ‡ Ð²Ð¾ ${issue.origin}`;
              case "invalid_union":
                  return "Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ";
              case "invalid_element":
                  return `Ð“Ñ€ÐµÑˆÐ½Ð° Ð²Ñ€ÐµÐ´Ð½Ð¾ÑÑ‚ Ð²Ð¾ ${issue.origin}`;
              default:
                  return `Ð“Ñ€ÐµÑˆÐµÐ½ Ð²Ð½ÐµÑ`;
          }
      };
  };
  function mk () {
      return {
          localeError: error$j(),
      };
  }

  const error$i = () => {
      const Sizable = {
          string: { unit: "aksara", verb: "mempunyai" },
          file: { unit: "bait", verb: "mempunyai" },
          array: { unit: "elemen", verb: "mempunyai" },
          set: { unit: "elemen", verb: "mempunyai" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "nombor";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "input",
          email: "alamat e-mel",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "tarikh masa ISO",
          date: "tarikh ISO",
          time: "masa ISO",
          duration: "tempoh ISO",
          ipv4: "alamat IPv4",
          ipv6: "alamat IPv6",
          cidrv4: "julat IPv4",
          cidrv6: "julat IPv6",
          base64: "string dikodkan base64",
          base64url: "string dikodkan base64url",
          json_string: "string JSON",
          e164: "nombor E.164",
          jwt: "JWT",
          template_literal: "input",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Input tidak sah: dijangka ${issue.expected}, diterima ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Input tidak sah: dijangka ${stringifyPrimitive(issue.values[0])}`;
                  return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Terlalu besar: dijangka ${issue.origin ?? "nilai"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elemen"}`;
                  return `Terlalu besar: dijangka ${issue.origin ?? "nilai"} adalah ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Terlalu kecil: dijangka ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Terlalu kecil: dijangka ${issue.origin} adalah ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
                  return `${Nouns[_issue.format] ?? issue.format} tidak sah`;
              }
              case "not_multiple_of":
                  return `Nombor tidak sah: perlu gandaan ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Kunci tidak dikenali: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Kunci tidak sah dalam ${issue.origin}`;
              case "invalid_union":
                  return "Input tidak sah";
              case "invalid_element":
                  return `Nilai tidak sah dalam ${issue.origin}`;
              default:
                  return `Input tidak sah`;
          }
      };
  };
  function ms () {
      return {
          localeError: error$i(),
      };
  }

  const error$h = () => {
      const Sizable = {
          string: { unit: "tekens" },
          file: { unit: "bytes" },
          array: { unit: "elementen" },
          set: { unit: "elementen" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "getal";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "invoer",
          email: "emailadres",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO datum en tijd",
          date: "ISO datum",
          time: "ISO tijd",
          duration: "ISO duur",
          ipv4: "IPv4-adres",
          ipv6: "IPv6-adres",
          cidrv4: "IPv4-bereik",
          cidrv6: "IPv6-bereik",
          base64: "base64-gecodeerde tekst",
          base64url: "base64 URL-gecodeerde tekst",
          json_string: "JSON string",
          e164: "E.164-nummer",
          jwt: "JWT",
          template_literal: "invoer",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Ongeldige invoer: verwacht ${issue.expected}, ontving ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue.values[0])}`;
                  return `Ongeldige optie: verwacht Ã©Ã©n van ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Te lang: verwacht dat ${issue.origin ?? "waarde"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
                  return `Te lang: verwacht dat ${issue.origin ?? "waarde"} ${adj}${issue.maximum.toString()} is`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} bevat`;
                  }
                  return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} is`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
                  }
                  if (_issue.format === "ends_with")
                      return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
                  if (_issue.format === "includes")
                      return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
                  if (_issue.format === "regex")
                      return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
                  return `Ongeldig: ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Ongeldig getal: moet een veelvoud van ${issue.divisor} zijn`;
              case "unrecognized_keys":
                  return `Onbekende key${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Ongeldige key in ${issue.origin}`;
              case "invalid_union":
                  return "Ongeldige invoer";
              case "invalid_element":
                  return `Ongeldige waarde in ${issue.origin}`;
              default:
                  return `Ongeldige invoer`;
          }
      };
  };
  function nl () {
      return {
          localeError: error$h(),
      };
  }

  const error$g = () => {
      const Sizable = {
          string: { unit: "tegn", verb: "Ã¥ ha" },
          file: { unit: "bytes", verb: "Ã¥ ha" },
          array: { unit: "elementer", verb: "Ã¥ inneholde" },
          set: { unit: "elementer", verb: "Ã¥ inneholde" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "tall";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "liste";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "input",
          email: "e-postadresse",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO dato- og klokkeslett",
          date: "ISO-dato",
          time: "ISO-klokkeslett",
          duration: "ISO-varighet",
          ipv4: "IPv4-omrÃ¥de",
          ipv6: "IPv6-omrÃ¥de",
          cidrv4: "IPv4-spekter",
          cidrv6: "IPv6-spekter",
          base64: "base64-enkodet streng",
          base64url: "base64url-enkodet streng",
          json_string: "JSON-streng",
          e164: "E.164-nummer",
          jwt: "JWT",
          template_literal: "input",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Ugyldig input: forventet ${issue.expected}, fikk ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Ugyldig verdi: forventet ${stringifyPrimitive(issue.values[0])}`;
                  return `Ugyldig valg: forventet en av ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `For stor(t): forventet ${issue.origin ?? "value"} til Ã¥ ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementer"}`;
                  return `For stor(t): forventet ${issue.origin ?? "value"} til Ã¥ ha ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `For lite(n): forventet ${issue.origin} til Ã¥ ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `For lite(n): forventet ${issue.origin} til Ã¥ ha ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Ugyldig streng: mÃ¥ starte med "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Ugyldig streng: mÃ¥ ende med "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Ugyldig streng: mÃ¥ inneholde "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Ugyldig streng: mÃ¥ matche mÃ¸nsteret ${_issue.pattern}`;
                  return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Ugyldig tall: mÃ¥ vÃ¦re et multiplum av ${issue.divisor}`;
              case "unrecognized_keys":
                  return `${issue.keys.length > 1 ? "Ukjente nÃ¸kler" : "Ukjent nÃ¸kkel"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Ugyldig nÃ¸kkel i ${issue.origin}`;
              case "invalid_union":
                  return "Ugyldig input";
              case "invalid_element":
                  return `Ugyldig verdi i ${issue.origin}`;
              default:
                  return `Ugyldig input`;
          }
      };
  };
  function no () {
      return {
          localeError: error$g(),
      };
  }

  const error$f = () => {
      const Sizable = {
          string: { unit: "harf", verb: "olmalÄ±dÄ±r" },
          file: { unit: "bayt", verb: "olmalÄ±dÄ±r" },
          array: { unit: "unsur", verb: "olmalÄ±dÄ±r" },
          set: { unit: "unsur", verb: "olmalÄ±dÄ±r" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "numara";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "saf";
                  }
                  if (data === null) {
                      return "gayb";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "giren",
          email: "epostagÃ¢h",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO hengÃ¢mÄ±",
          date: "ISO tarihi",
          time: "ISO zamanÄ±",
          duration: "ISO mÃ¼ddeti",
          ipv4: "IPv4 niÅŸÃ¢nÄ±",
          ipv6: "IPv6 niÅŸÃ¢nÄ±",
          cidrv4: "IPv4 menzili",
          cidrv6: "IPv6 menzili",
          base64: "base64-ÅŸifreli metin",
          base64url: "base64url-ÅŸifreli metin",
          json_string: "JSON metin",
          e164: "E.164 sayÄ±sÄ±",
          jwt: "JWT",
          template_literal: "giren",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `FÃ¢sit giren: umulan ${issue.expected}, alÄ±nan ${parsedType(issue.input)}`;
              // return `FÃ¢sit giren: umulan ${issue.expected}, alÄ±nan ${util.getParsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `FÃ¢sit giren: umulan ${stringifyPrimitive(issue.values[0])}`;
                  return `FÃ¢sit tercih: mÃ»teberler ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Fazla bÃ¼yÃ¼k: ${issue.origin ?? "value"}, ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalÄ±ydÄ±.`;
                  return `Fazla bÃ¼yÃ¼k: ${issue.origin ?? "value"}, ${adj}${issue.maximum.toString()} olmalÄ±ydÄ±.`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Fazla kÃ¼Ã§Ã¼k: ${issue.origin}, ${adj}${issue.minimum.toString()} ${sizing.unit} sahip olmalÄ±ydÄ±.`;
                  }
                  return `Fazla kÃ¼Ã§Ã¼k: ${issue.origin}, ${adj}${issue.minimum.toString()} olmalÄ±ydÄ±.`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `FÃ¢sit metin: "${_issue.prefix}" ile baÅŸlamalÄ±.`;
                  if (_issue.format === "ends_with")
                      return `FÃ¢sit metin: "${_issue.suffix}" ile bitmeli.`;
                  if (_issue.format === "includes")
                      return `FÃ¢sit metin: "${_issue.includes}" ihtivÃ¢ etmeli.`;
                  if (_issue.format === "regex")
                      return `FÃ¢sit metin: ${_issue.pattern} nakÅŸÄ±na uymalÄ±.`;
                  return `FÃ¢sit ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `FÃ¢sit sayÄ±: ${issue.divisor} katÄ± olmalÄ±ydÄ±.`;
              case "unrecognized_keys":
                  return `TanÄ±nmayan anahtar ${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `${issue.origin} iÃ§in tanÄ±nmayan anahtar var.`;
              case "invalid_union":
                  return "Giren tanÄ±namadÄ±.";
              case "invalid_element":
                  return `${issue.origin} iÃ§in tanÄ±nmayan kÄ±ymet var.`;
              default:
                  return `KÄ±ymet tanÄ±namadÄ±.`;
          }
      };
  };
  function ota () {
      return {
          localeError: error$f(),
      };
  }

  const error$e = () => {
      const Sizable = {
          string: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" },
          file: { unit: "Ø¨Ø§ÛŒÙ¼Ø³", verb: "ÙˆÙ„Ø±ÙŠ" },
          array: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" },
          set: { unit: "ØªÙˆÚ©ÙŠ", verb: "ÙˆÙ„Ø±ÙŠ" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Ø¹Ø¯Ø¯";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "Ø§Ø±Û";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "ÙˆØ±ÙˆØ¯ÙŠ",
          email: "Ø¨Ø±ÛŒÚšÙ†Ø§Ù„ÛŒÚ©",
          url: "ÛŒÙˆ Ø¢Ø± Ø§Ù„",
          emoji: "Ø§ÛŒÙ…ÙˆØ¬ÙŠ",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "Ù†ÛŒÙ¼Ù‡ Ø§Ùˆ ÙˆØ®Øª",
          date: "Ù†ÛÙ¼Ù‡",
          time: "ÙˆØ®Øª",
          duration: "Ù…ÙˆØ¯Ù‡",
          ipv4: "Ø¯ IPv4 Ù¾ØªÙ‡",
          ipv6: "Ø¯ IPv6 Ù¾ØªÙ‡",
          cidrv4: "Ø¯ IPv4 Ø³Ø§Ø­Ù‡",
          cidrv6: "Ø¯ IPv6 Ø³Ø§Ø­Ù‡",
          base64: "base64-encoded Ù…ØªÙ†",
          base64url: "base64url-encoded Ù…ØªÙ†",
          json_string: "JSON Ù…ØªÙ†",
          e164: "Ø¯ E.164 Ø´Ù…ÛØ±Ù‡",
          jwt: "JWT",
          template_literal: "ÙˆØ±ÙˆØ¯ÙŠ",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Ù†Ø§Ø³Ù… ÙˆØ±ÙˆØ¯ÙŠ: Ø¨Ø§ÛŒØ¯ ${issue.expected} ÙˆØ§ÛŒ, Ù…Ú«Ø± ${parsedType(issue.input)} ØªØ±Ù„Ø§Ø³Ù‡ Ø´Ùˆ`;
              case "invalid_value":
                  if (issue.values.length === 1) {
                      return `Ù†Ø§Ø³Ù… ÙˆØ±ÙˆØ¯ÙŠ: Ø¨Ø§ÛŒØ¯ ${stringifyPrimitive(issue.values[0])} ÙˆØ§ÛŒ`;
                  }
                  return `Ù†Ø§Ø³Ù… Ø§Ù†ØªØ®Ø§Ø¨: Ø¨Ø§ÛŒØ¯ ÛŒÙˆ Ù„Ù‡ ${joinValues(issue.values, "|")} Ú…Ø®Ù‡ ÙˆØ§ÛŒ`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Ú‰ÛŒØ± Ù„ÙˆÛŒ: ${issue.origin ?? "Ø§Ø±Ø²ÚšØª"} Ø¨Ø§ÛŒØ¯ ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†ØµØ±ÙˆÙ†Ù‡"} ÙˆÙ„Ø±ÙŠ`;
                  }
                  return `Ú‰ÛŒØ± Ù„ÙˆÛŒ: ${issue.origin ?? "Ø§Ø±Ø²ÚšØª"} Ø¨Ø§ÛŒØ¯ ${adj}${issue.maximum.toString()} ÙˆÙŠ`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Ú‰ÛŒØ± Ú©ÙˆÚ†Ù†ÛŒ: ${issue.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue.minimum.toString()} ${sizing.unit} ÙˆÙ„Ø±ÙŠ`;
                  }
                  return `Ú‰ÛŒØ± Ú©ÙˆÚ†Ù†ÛŒ: ${issue.origin} Ø¨Ø§ÛŒØ¯ ${adj}${issue.minimum.toString()} ÙˆÙŠ`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ "${_issue.prefix}" Ø³Ø±Ù‡ Ù¾ÛŒÙ„ Ø´ÙŠ`;
                  }
                  if (_issue.format === "ends_with") {
                      return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ "${_issue.suffix}" Ø³Ø±Ù‡ Ù¾Ø§ÛŒ ØªÙ‡ ÙˆØ±Ø³ÙŠÚ–ÙŠ`;
                  }
                  if (_issue.format === "includes") {
                      return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ "${_issue.includes}" ÙˆÙ„Ø±ÙŠ`;
                  }
                  if (_issue.format === "regex") {
                      return `Ù†Ø§Ø³Ù… Ù…ØªÙ†: Ø¨Ø§ÛŒØ¯ Ø¯ ${_issue.pattern} Ø³Ø±Ù‡ Ù…Ø·Ø§Ø¨Ù‚Øª ÙˆÙ„Ø±ÙŠ`;
                  }
                  return `${Nouns[_issue.format] ?? issue.format} Ù†Ø§Ø³Ù… Ø¯ÛŒ`;
              }
              case "not_multiple_of":
                  return `Ù†Ø§Ø³Ù… Ø¹Ø¯Ø¯: Ø¨Ø§ÛŒØ¯ Ø¯ ${issue.divisor} Ù…Ø¶Ø±Ø¨ ÙˆÙŠ`;
              case "unrecognized_keys":
                  return `Ù†Ø§Ø³Ù… ${issue.keys.length > 1 ? "Ú©Ù„ÛŒÚ‰ÙˆÙ†Ù‡" : "Ú©Ù„ÛŒÚ‰"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Ù†Ø§Ø³Ù… Ú©Ù„ÛŒÚ‰ Ù¾Ù‡ ${issue.origin} Ú©Û`;
              case "invalid_union":
                  return `Ù†Ø§Ø³Ù…Ù‡ ÙˆØ±ÙˆØ¯ÙŠ`;
              case "invalid_element":
                  return `Ù†Ø§Ø³Ù… Ø¹Ù†ØµØ± Ù¾Ù‡ ${issue.origin} Ú©Û`;
              default:
                  return `Ù†Ø§Ø³Ù…Ù‡ ÙˆØ±ÙˆØ¯ÙŠ`;
          }
      };
  };
  function ps () {
      return {
          localeError: error$e(),
      };
  }

  const error$d = () => {
      const Sizable = {
          string: { unit: "znakÃ³w", verb: "mieÄ‡" },
          file: { unit: "bajtÃ³w", verb: "mieÄ‡" },
          array: { unit: "elementÃ³w", verb: "mieÄ‡" },
          set: { unit: "elementÃ³w", verb: "mieÄ‡" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "liczba";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "tablica";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "wyraÅ¼enie",
          email: "adres email",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "data i godzina w formacie ISO",
          date: "data w formacie ISO",
          time: "godzina w formacie ISO",
          duration: "czas trwania ISO",
          ipv4: "adres IPv4",
          ipv6: "adres IPv6",
          cidrv4: "zakres IPv4",
          cidrv6: "zakres IPv6",
          base64: "ciÄ…g znakÃ³w zakodowany w formacie base64",
          base64url: "ciÄ…g znakÃ³w zakodowany w formacie base64url",
          json_string: "ciÄ…g znakÃ³w w formacie JSON",
          e164: "liczba E.164",
          jwt: "JWT",
          template_literal: "wejÅ›cie",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `NieprawidÅ‚owe dane wejÅ›ciowe: oczekiwano ${issue.expected}, otrzymano ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `NieprawidÅ‚owe dane wejÅ›ciowe: oczekiwano ${stringifyPrimitive(issue.values[0])}`;
                  return `NieprawidÅ‚owa opcja: oczekiwano jednej z wartoÅ›ci ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Za duÅ¼a wartoÅ›Ä‡: oczekiwano, Å¼e ${issue.origin ?? "wartoÅ›Ä‡"} bÄ™dzie mieÄ‡ ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementÃ³w"}`;
                  }
                  return `Zbyt duÅ¼(y/a/e): oczekiwano, Å¼e ${issue.origin ?? "wartoÅ›Ä‡"} bÄ™dzie wynosiÄ‡ ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Za maÅ‚a wartoÅ›Ä‡: oczekiwano, Å¼e ${issue.origin ?? "wartoÅ›Ä‡"} bÄ™dzie mieÄ‡ ${adj}${issue.minimum.toString()} ${sizing.unit ?? "elementÃ³w"}`;
                  }
                  return `Zbyt maÅ‚(y/a/e): oczekiwano, Å¼e ${issue.origin ?? "wartoÅ›Ä‡"} bÄ™dzie wynosiÄ‡ ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi zaczynaÄ‡ siÄ™ od "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi koÅ„czyÄ‡ siÄ™ na "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi zawieraÄ‡ "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `NieprawidÅ‚owy ciÄ…g znakÃ³w: musi odpowiadaÄ‡ wzorcowi ${_issue.pattern}`;
                  return `NieprawidÅ‚ow(y/a/e) ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `NieprawidÅ‚owa liczba: musi byÄ‡ wielokrotnoÅ›ciÄ… ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Nierozpoznane klucze${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `NieprawidÅ‚owy klucz w ${issue.origin}`;
              case "invalid_union":
                  return "NieprawidÅ‚owe dane wejÅ›ciowe";
              case "invalid_element":
                  return `NieprawidÅ‚owa wartoÅ›Ä‡ w ${issue.origin}`;
              default:
                  return `NieprawidÅ‚owe dane wejÅ›ciowe`;
          }
      };
  };
  function pl () {
      return {
          localeError: error$d(),
      };
  }

  const error$c = () => {
      const Sizable = {
          string: { unit: "caracteres", verb: "ter" },
          file: { unit: "bytes", verb: "ter" },
          array: { unit: "itens", verb: "ter" },
          set: { unit: "itens", verb: "ter" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "nÃºmero";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "nulo";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "padrÃ£o",
          email: "endereÃ§o de e-mail",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "data e hora ISO",
          date: "data ISO",
          time: "hora ISO",
          duration: "duraÃ§Ã£o ISO",
          ipv4: "endereÃ§o IPv4",
          ipv6: "endereÃ§o IPv6",
          cidrv4: "faixa de IPv4",
          cidrv6: "faixa de IPv6",
          base64: "texto codificado em base64",
          base64url: "URL codificada em base64",
          json_string: "texto JSON",
          e164: "nÃºmero E.164",
          jwt: "JWT",
          template_literal: "entrada",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Tipo invÃ¡lido: esperado ${issue.expected}, recebido ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Entrada invÃ¡lida: esperado ${stringifyPrimitive(issue.values[0])}`;
                  return `OpÃ§Ã£o invÃ¡lida: esperada uma das ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Muito grande: esperado que ${issue.origin ?? "valor"} tivesse ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementos"}`;
                  return `Muito grande: esperado que ${issue.origin ?? "valor"} fosse ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Muito pequeno: esperado que ${issue.origin} tivesse ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Muito pequeno: esperado que ${issue.origin} fosse ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Texto invÃ¡lido: deve comeÃ§ar com "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Texto invÃ¡lido: deve terminar com "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Texto invÃ¡lido: deve incluir "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Texto invÃ¡lido: deve corresponder ao padrÃ£o ${_issue.pattern}`;
                  return `${Nouns[_issue.format] ?? issue.format} invÃ¡lido`;
              }
              case "not_multiple_of":
                  return `NÃºmero invÃ¡lido: deve ser mÃºltiplo de ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Chave${issue.keys.length > 1 ? "s" : ""} desconhecida${issue.keys.length > 1 ? "s" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Chave invÃ¡lida em ${issue.origin}`;
              case "invalid_union":
                  return "Entrada invÃ¡lida";
              case "invalid_element":
                  return `Valor invÃ¡lido em ${issue.origin}`;
              default:
                  return `Campo invÃ¡lido`;
          }
      };
  };
  function pt () {
      return {
          localeError: error$c(),
      };
  }

  function getRussianPlural(count, one, few, many) {
      const absCount = Math.abs(count);
      const lastDigit = absCount % 10;
      const lastTwoDigits = absCount % 100;
      if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
          return many;
      }
      if (lastDigit === 1) {
          return one;
      }
      if (lastDigit >= 2 && lastDigit <= 4) {
          return few;
      }
      return many;
  }
  const error$b = () => {
      const Sizable = {
          string: {
              unit: {
                  one: "ÑÐ¸Ð¼Ð²Ð¾Ð»",
                  few: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°",
                  many: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²",
              },
              verb: "Ð¸Ð¼ÐµÑ‚ÑŒ",
          },
          file: {
              unit: {
                  one: "Ð±Ð°Ð¹Ñ‚",
                  few: "Ð±Ð°Ð¹Ñ‚Ð°",
                  many: "Ð±Ð°Ð¹Ñ‚",
              },
              verb: "Ð¸Ð¼ÐµÑ‚ÑŒ",
          },
          array: {
              unit: {
                  one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
                  few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°",
                  many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²",
              },
              verb: "Ð¸Ð¼ÐµÑ‚ÑŒ",
          },
          set: {
              unit: {
                  one: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
                  few: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°",
                  many: "ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²",
              },
              verb: "Ð¸Ð¼ÐµÑ‚ÑŒ",
          },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "Ð¼Ð°ÑÑÐ¸Ð²";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "Ð²Ð²Ð¾Ð´",
          email: "email Ð°Ð´Ñ€ÐµÑ",
          url: "URL",
          emoji: "ÑÐ¼Ð¾Ð´Ð·Ð¸",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO Ð´Ð°Ñ‚Ð° Ð¸ Ð²Ñ€ÐµÐ¼Ñ",
          date: "ISO Ð´Ð°Ñ‚Ð°",
          time: "ISO Ð²Ñ€ÐµÐ¼Ñ",
          duration: "ISO Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ",
          ipv4: "IPv4 Ð°Ð´Ñ€ÐµÑ",
          ipv6: "IPv6 Ð°Ð´Ñ€ÐµÑ",
          cidrv4: "IPv4 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½",
          cidrv6: "IPv6 Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½",
          base64: "ÑÑ‚Ñ€Ð¾ÐºÐ° Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ base64",
          base64url: "ÑÑ‚Ñ€Ð¾ÐºÐ° Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ base64url",
          json_string: "JSON ÑÑ‚Ñ€Ð¾ÐºÐ°",
          e164: "Ð½Ð¾Ð¼ÐµÑ€ E.164",
          jwt: "JWT",
          template_literal: "Ð²Ð²Ð¾Ð´",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ ${issue.expected}, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ ${stringifyPrimitive(issue.values[0])}`;
                  return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð´Ð½Ð¾ Ð¸Ð· ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      const maxValue = Number(issue.maximum);
                      const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
                      return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"} Ð±ÑƒÐ´ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ${adj}${issue.maximum.toString()} ${unit}`;
                  }
                  return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"} Ð±ÑƒÐ´ÐµÑ‚ ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      const minValue = Number(issue.minimum);
                      const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
                      return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue.origin} Ð±ÑƒÐ´ÐµÑ‚ Ð¸Ð¼ÐµÑ‚ÑŒ ${adj}${issue.minimum.toString()} ${unit}`;
                  }
                  return `Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ: Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ñ‡Ñ‚Ð¾ ${issue.origin} Ð±ÑƒÐ´ÐµÑ‚ ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° Ð½Ð°Ñ‡Ð¸Ð½Ð°Ñ‚ÑŒÑÑ Ñ "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° Ð·Ð°ÐºÐ°Ð½Ñ‡Ð¸Ð²Ð°Ñ‚ÑŒÑÑ Ð½Ð° "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ°: Ð´Ð¾Ð»Ð¶Ð½Ð° ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¾Ð²Ð°Ñ‚ÑŒ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
                  return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾: Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ ÐºÑ€Ð°Ñ‚Ð½Ñ‹Ð¼ ${issue.divisor}`;
              case "unrecognized_keys":
                  return `ÐÐµÑ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ð½Ð½${issue.keys.length > 1 ? "Ñ‹Ðµ" : "Ñ‹Ð¹"} ÐºÐ»ÑŽÑ‡${issue.keys.length > 1 ? "Ð¸" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ÐºÐ»ÑŽÑ‡ Ð² ${issue.origin}`;
              case "invalid_union":
                  return "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ";
              case "invalid_element":
                  return `ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð² ${issue.origin}`;
              default:
                  return `ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ`;
          }
      };
  };
  function ru () {
      return {
          localeError: error$b(),
      };
  }

  const error$a = () => {
      const Sizable = {
          string: { unit: "znakov", verb: "imeti" },
          file: { unit: "bajtov", verb: "imeti" },
          array: { unit: "elementov", verb: "imeti" },
          set: { unit: "elementov", verb: "imeti" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Å¡tevilo";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "tabela";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "vnos",
          email: "e-poÅ¡tni naslov",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO datum in Äas",
          date: "ISO datum",
          time: "ISO Äas",
          duration: "ISO trajanje",
          ipv4: "IPv4 naslov",
          ipv6: "IPv6 naslov",
          cidrv4: "obseg IPv4",
          cidrv6: "obseg IPv6",
          base64: "base64 kodiran niz",
          base64url: "base64url kodiran niz",
          json_string: "JSON niz",
          e164: "E.164 Å¡tevilka",
          jwt: "JWT",
          template_literal: "vnos",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Neveljaven vnos: priÄakovano ${issue.expected}, prejeto ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Neveljaven vnos: priÄakovano ${stringifyPrimitive(issue.values[0])}`;
                  return `Neveljavna moÅ¾nost: priÄakovano eno izmed ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Preveliko: priÄakovano, da bo ${issue.origin ?? "vrednost"} imelo ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementov"}`;
                  return `Preveliko: priÄakovano, da bo ${issue.origin ?? "vrednost"} ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Premajhno: priÄakovano, da bo ${issue.origin} imelo ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Premajhno: priÄakovano, da bo ${issue.origin} ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `Neveljaven niz: mora se zaÄeti z "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `Neveljaven niz: mora se konÄati z "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
                  return `Neveljaven ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Neveljavno Å¡tevilo: mora biti veÄkratnik ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Neprepoznan${issue.keys.length > 1 ? "i kljuÄi" : " kljuÄ"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Neveljaven kljuÄ v ${issue.origin}`;
              case "invalid_union":
                  return "Neveljaven vnos";
              case "invalid_element":
                  return `Neveljavna vrednost v ${issue.origin}`;
              default:
                  return "Neveljaven vnos";
          }
      };
  };
  function sl () {
      return {
          localeError: error$a(),
      };
  }

  const error$9 = () => {
      const Sizable = {
          string: { unit: "tecken", verb: "att ha" },
          file: { unit: "bytes", verb: "att ha" },
          array: { unit: "objekt", verb: "att innehÃ¥lla" },
          set: { unit: "objekt", verb: "att innehÃ¥lla" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "antal";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "lista";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "reguljÃ¤rt uttryck",
          email: "e-postadress",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO-datum och tid",
          date: "ISO-datum",
          time: "ISO-tid",
          duration: "ISO-varaktighet",
          ipv4: "IPv4-intervall",
          ipv6: "IPv6-intervall",
          cidrv4: "IPv4-spektrum",
          cidrv6: "IPv6-spektrum",
          base64: "base64-kodad strÃ¤ng",
          base64url: "base64url-kodad strÃ¤ng",
          json_string: "JSON-strÃ¤ng",
          e164: "E.164-nummer",
          jwt: "JWT",
          template_literal: "mall-literal",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Ogiltig inmatning: fÃ¶rvÃ¤ntat ${issue.expected}, fick ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Ogiltig inmatning: fÃ¶rvÃ¤ntat ${stringifyPrimitive(issue.values[0])}`;
                  return `Ogiltigt val: fÃ¶rvÃ¤ntade en av ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `FÃ¶r stor(t): fÃ¶rvÃ¤ntade ${issue.origin ?? "vÃ¤rdet"} att ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element"}`;
                  }
                  return `FÃ¶r stor(t): fÃ¶rvÃ¤ntat ${issue.origin ?? "vÃ¤rdet"} att ha ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `FÃ¶r lite(t): fÃ¶rvÃ¤ntade ${issue.origin ?? "vÃ¤rdet"} att ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `FÃ¶r lite(t): fÃ¶rvÃ¤ntade ${issue.origin ?? "vÃ¤rdet"} att ha ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `Ogiltig strÃ¤ng: mÃ¥ste bÃ¶rja med "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `Ogiltig strÃ¤ng: mÃ¥ste sluta med "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Ogiltig strÃ¤ng: mÃ¥ste innehÃ¥lla "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Ogiltig strÃ¤ng: mÃ¥ste matcha mÃ¶nstret "${_issue.pattern}"`;
                  return `Ogiltig(t) ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Ogiltigt tal: mÃ¥ste vara en multipel av ${issue.divisor}`;
              case "unrecognized_keys":
                  return `${issue.keys.length > 1 ? "OkÃ¤nda nycklar" : "OkÃ¤nd nyckel"}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Ogiltig nyckel i ${issue.origin ?? "vÃ¤rdet"}`;
              case "invalid_union":
                  return "Ogiltig input";
              case "invalid_element":
                  return `Ogiltigt vÃ¤rde i ${issue.origin ?? "vÃ¤rdet"}`;
              default:
                  return `Ogiltig input`;
          }
      };
  };
  function sv () {
      return {
          localeError: error$9(),
      };
  }

  const error$8 = () => {
      const Sizable = {
          string: { unit: "à®Žà®´à¯à®¤à¯à®¤à¯à®•à¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
          file: { unit: "à®ªà¯ˆà®Ÿà¯à®Ÿà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
          array: { unit: "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
          set: { unit: "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯", verb: "à®•à¯Šà®£à¯à®Ÿà®¿à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "à®Žà®£à¯ à®…à®²à¯à®²à®¾à®¤à®¤à¯" : "à®Žà®£à¯";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "à®…à®£à®¿";
                  }
                  if (data === null) {
                      return "à®µà¯†à®±à¯à®®à¯ˆ";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "à®‰à®³à¯à®³à¯€à®Ÿà¯",
          email: "à®®à®¿à®©à¯à®©à®žà¯à®šà®²à¯ à®®à¯à®•à®µà®°à®¿",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO à®¤à¯‡à®¤à®¿ à®¨à¯‡à®°à®®à¯",
          date: "ISO à®¤à¯‡à®¤à®¿",
          time: "ISO à®¨à¯‡à®°à®®à¯",
          duration: "ISO à®•à®¾à®² à®…à®³à®µà¯",
          ipv4: "IPv4 à®®à¯à®•à®µà®°à®¿",
          ipv6: "IPv6 à®®à¯à®•à®µà®°à®¿",
          cidrv4: "IPv4 à®µà®°à®®à¯à®ªà¯",
          cidrv6: "IPv6 à®µà®°à®®à¯à®ªà¯",
          base64: "base64-encoded à®šà®°à®®à¯",
          base64url: "base64url-encoded à®šà®°à®®à¯",
          json_string: "JSON à®šà®°à®®à¯",
          e164: "E.164 à®Žà®£à¯",
          jwt: "JWT",
          template_literal: "input",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue.expected}, à®ªà¯†à®±à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${stringifyPrimitive(issue.values[0])}`;
                  return `à®¤à®µà®±à®¾à®© à®µà®¿à®°à¯à®ªà¯à®ªà®®à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${joinValues(issue.values, "|")} à®‡à®²à¯ à®’à®©à¯à®±à¯`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `à®®à®¿à®• à®ªà¯†à®°à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue.origin ?? "à®®à®¤à®¿à®ªà¯à®ªà¯"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "à®‰à®±à¯à®ªà¯à®ªà¯à®•à®³à¯"} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
                  }
                  return `à®®à®¿à®• à®ªà¯†à®°à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue.origin ?? "à®®à®¤à®¿à®ªà¯à®ªà¯"} ${adj}${issue.maximum.toString()} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `à®®à®¿à®•à®šà¯ à®šà®¿à®±à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`; //
                  }
                  return `à®®à®¿à®•à®šà¯ à®šà®¿à®±à®¿à®¯à®¤à¯: à®Žà®¤à®¿à®°à¯à®ªà®¾à®°à¯à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®Ÿà®¤à¯ ${issue.origin} ${adj}${issue.minimum.toString()} à®†à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.prefix}" à®‡à®²à¯ à®¤à¯Šà®Ÿà®™à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
                  if (_issue.format === "ends_with")
                      return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.suffix}" à®‡à®²à¯ à®®à¯à®Ÿà®¿à®µà®Ÿà¯ˆà®¯ à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
                  if (_issue.format === "includes")
                      return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: "${_issue.includes}" à® à®‰à®³à¯à®³à®Ÿà®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
                  if (_issue.format === "regex")
                      return `à®¤à®µà®±à®¾à®© à®šà®°à®®à¯: ${_issue.pattern} à®®à¯à®±à¯ˆà®ªà®¾à®Ÿà¯à®Ÿà¯à®Ÿà®©à¯ à®ªà¯Šà®°à¯à®¨à¯à®¤ à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
                  return `à®¤à®µà®±à®¾à®© ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `à®¤à®µà®±à®¾à®© à®Žà®£à¯: ${issue.divisor} à®‡à®©à¯ à®ªà®²à®®à®¾à®• à®‡à®°à¯à®•à¯à®• à®µà¯‡à®£à¯à®Ÿà¯à®®à¯`;
              case "unrecognized_keys":
                  return `à®…à®Ÿà¯ˆà®¯à®¾à®³à®®à¯ à®¤à¯†à®°à®¿à®¯à®¾à®¤ à®µà®¿à®šà¯ˆ${issue.keys.length > 1 ? "à®•à®³à¯" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `${issue.origin} à®‡à®²à¯ à®¤à®µà®±à®¾à®© à®µà®¿à®šà¯ˆ`;
              case "invalid_union":
                  return "à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯";
              case "invalid_element":
                  return `${issue.origin} à®‡à®²à¯ à®¤à®µà®±à®¾à®© à®®à®¤à®¿à®ªà¯à®ªà¯`;
              default:
                  return `à®¤à®µà®±à®¾à®© à®‰à®³à¯à®³à¯€à®Ÿà¯`;
          }
      };
  };
  function ta () {
      return {
          localeError: error$8(),
      };
  }

  const error$7 = () => {
      const Sizable = {
          string: { unit: "à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
          file: { unit: "à¹„à¸šà¸•à¹Œ", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
          array: { unit: "à¸£à¸²à¸¢à¸à¸²à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
          set: { unit: "à¸£à¸²à¸¢à¸à¸²à¸£", verb: "à¸„à¸§à¸£à¸¡à¸µ" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸•à¸±à¸§à¹€à¸¥à¸‚ (NaN)" : "à¸•à¸±à¸§à¹€à¸¥à¸‚";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "à¸­à¸²à¸£à¹Œà¹€à¸£à¸¢à¹Œ (Array)";
                  }
                  if (data === null) {
                      return "à¹„à¸¡à¹ˆà¸¡à¸µà¸„à¹ˆà¸² (null)";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸›à¹‰à¸­à¸™",
          email: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆà¸­à¸µà¹€à¸¡à¸¥",
          url: "URL",
          emoji: "à¸­à¸´à¹‚à¸¡à¸ˆà¸´",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "à¸§à¸±à¸™à¸—à¸µà¹ˆà¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
          date: "à¸§à¸±à¸™à¸—à¸µà¹ˆà¹à¸šà¸š ISO",
          time: "à¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
          duration: "à¸Šà¹ˆà¸§à¸‡à¹€à¸§à¸¥à¸²à¹à¸šà¸š ISO",
          ipv4: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ IPv4",
          ipv6: "à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ IPv6",
          cidrv4: "à¸Šà¹ˆà¸§à¸‡ IP à¹à¸šà¸š IPv4",
          cidrv6: "à¸Šà¹ˆà¸§à¸‡ IP à¹à¸šà¸š IPv6",
          base64: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š Base64",
          base64url: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š Base64 à¸ªà¸³à¸«à¸£à¸±à¸š URL",
          json_string: "à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸šà¸š JSON",
          e164: "à¹€à¸šà¸­à¸£à¹Œà¹‚à¸—à¸£à¸¨à¸±à¸žà¸—à¹Œà¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡à¸›à¸£à¸°à¹€à¸—à¸¨ (E.164)",
          jwt: "à¹‚à¸—à¹€à¸„à¸™ JWT",
          template_literal: "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸µà¹ˆà¸›à¹‰à¸­à¸™",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `à¸›à¸£à¸°à¹€à¸ à¸—à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ ${issue.expected} à¹à¸•à¹ˆà¹„à¸”à¹‰à¸£à¸±à¸š ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `à¸„à¹ˆà¸²à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ ${stringifyPrimitive(issue.values[0])}`;
                  return `à¸•à¸±à¸§à¹€à¸¥à¸·à¸­à¸à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸„à¸§à¸£à¹€à¸›à¹‡à¸™à¸«à¸™à¸¶à¹ˆà¸‡à¹ƒà¸™ ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "à¹„à¸¡à¹ˆà¹€à¸à¸´à¸™" : "à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”: ${issue.origin ?? "à¸„à¹ˆà¸²"} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "à¸£à¸²à¸¢à¸à¸²à¸£"}`;
                  return `à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”: ${issue.origin ?? "à¸„à¹ˆà¸²"} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? "à¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢" : "à¸¡à¸²à¸à¸à¸§à¹ˆà¸²";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²à¸à¸³à¸«à¸™à¸”: ${issue.origin} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸²à¸à¸³à¸«à¸™à¸”: ${issue.origin} à¸„à¸§à¸£à¸¡à¸µ${adj} ${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸‚à¸¶à¹‰à¸™à¸•à¹‰à¸™à¸”à¹‰à¸§à¸¢ "${_issue.prefix}"`;
                  }
                  if (_issue.format === "ends_with")
                      return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¥à¸‡à¸—à¹‰à¸²à¸¢à¸”à¹‰à¸§à¸¢ "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸¡à¸µ "${_issue.includes}" à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡`;
                  if (_issue.format === "regex")
                      return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸•à¹‰à¸­à¸‡à¸•à¸£à¸‡à¸à¸±à¸šà¸£à¸¹à¸›à¹à¸šà¸šà¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸” ${_issue.pattern}`;
                  return `à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `à¸•à¸±à¸§à¹€à¸¥à¸‚à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™à¸ˆà¸³à¸™à¸§à¸™à¸—à¸µà¹ˆà¸«à¸²à¸£à¸”à¹‰à¸§à¸¢ ${issue.divisor} à¹„à¸”à¹‰à¸¥à¸‡à¸•à¸±à¸§`;
              case "unrecognized_keys":
                  return `à¸žà¸šà¸„à¸µà¸¢à¹Œà¸—à¸µà¹ˆà¹„à¸¡à¹ˆà¸£à¸¹à¹‰à¸ˆà¸±à¸: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `à¸„à¸µà¸¢à¹Œà¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸™ ${issue.origin}`;
              case "invalid_union":
                  return "à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: à¹„à¸¡à¹ˆà¸•à¸£à¸‡à¸à¸±à¸šà¸£à¸¹à¸›à¹à¸šà¸šà¸¢à¸¹à¹€à¸™à¸µà¸¢à¸™à¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸”à¹„à¸§à¹‰";
              case "invalid_element":
                  return `à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¹ƒà¸™ ${issue.origin}`;
              default:
                  return `à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡`;
          }
      };
  };
  function th () {
      return {
          localeError: error$7(),
      };
  }

  const parsedType = (data) => {
      const t = typeof data;
      switch (t) {
          case "number": {
              return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
              if (Array.isArray(data)) {
                  return "array";
              }
              if (data === null) {
                  return "null";
              }
              if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                  return data.constructor.name;
              }
          }
      }
      return t;
  };
  const error$6 = () => {
      const Sizable = {
          string: { unit: "karakter", verb: "olmalÄ±" },
          file: { unit: "bayt", verb: "olmalÄ±" },
          array: { unit: "Ã¶ÄŸe", verb: "olmalÄ±" },
          set: { unit: "Ã¶ÄŸe", verb: "olmalÄ±" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const Nouns = {
          regex: "girdi",
          email: "e-posta adresi",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO tarih ve saat",
          date: "ISO tarih",
          time: "ISO saat",
          duration: "ISO sÃ¼re",
          ipv4: "IPv4 adresi",
          ipv6: "IPv6 adresi",
          cidrv4: "IPv4 aralÄ±ÄŸÄ±",
          cidrv6: "IPv6 aralÄ±ÄŸÄ±",
          base64: "base64 ile ÅŸifrelenmiÅŸ metin",
          base64url: "base64url ile ÅŸifrelenmiÅŸ metin",
          json_string: "JSON dizesi",
          e164: "E.164 sayÄ±sÄ±",
          jwt: "JWT",
          template_literal: "Åžablon dizesi",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `GeÃ§ersiz deÄŸer: beklenen ${issue.expected}, alÄ±nan ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `GeÃ§ersiz deÄŸer: beklenen ${stringifyPrimitive(issue.values[0])}`;
                  return `GeÃ§ersiz seÃ§enek: aÅŸaÄŸÄ±dakilerden biri olmalÄ±: ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Ã‡ok bÃ¼yÃ¼k: beklenen ${issue.origin ?? "deÄŸer"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Ã¶ÄŸe"}`;
                  return `Ã‡ok bÃ¼yÃ¼k: beklenen ${issue.origin ?? "deÄŸer"} ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Ã‡ok kÃ¼Ã§Ã¼k: beklenen ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  return `Ã‡ok kÃ¼Ã§Ã¼k: beklenen ${issue.origin} ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `GeÃ§ersiz metin: "${_issue.prefix}" ile baÅŸlamalÄ±`;
                  if (_issue.format === "ends_with")
                      return `GeÃ§ersiz metin: "${_issue.suffix}" ile bitmeli`;
                  if (_issue.format === "includes")
                      return `GeÃ§ersiz metin: "${_issue.includes}" iÃ§ermeli`;
                  if (_issue.format === "regex")
                      return `GeÃ§ersiz metin: ${_issue.pattern} desenine uymalÄ±`;
                  return `GeÃ§ersiz ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `GeÃ§ersiz sayÄ±: ${issue.divisor} ile tam bÃ¶lÃ¼nebilmeli`;
              case "unrecognized_keys":
                  return `TanÄ±nmayan anahtar${issue.keys.length > 1 ? "lar" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `${issue.origin} iÃ§inde geÃ§ersiz anahtar`;
              case "invalid_union":
                  return "GeÃ§ersiz deÄŸer";
              case "invalid_element":
                  return `${issue.origin} iÃ§inde geÃ§ersiz deÄŸer`;
              default:
                  return `GeÃ§ersiz deÄŸer`;
          }
      };
  };
  function tr () {
      return {
          localeError: error$6(),
      };
  }

  const error$5 = () => {
      const Sizable = {
          string: { unit: "ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
          file: { unit: "Ð±Ð°Ð¹Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
          array: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
          set: { unit: "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²", verb: "Ð¼Ð°Ñ‚Ð¸Ð¼Ðµ" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Ñ‡Ð¸ÑÐ»Ð¾";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "Ð¼Ð°ÑÐ¸Ð²";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–",
          email: "Ð°Ð´Ñ€ÐµÑÐ° ÐµÐ»ÐµÐºÑ‚Ñ€Ð¾Ð½Ð½Ð¾Ñ— Ð¿Ð¾ÑˆÑ‚Ð¸",
          url: "URL",
          emoji: "ÐµÐ¼Ð¾Ð´Ð·Ñ–",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "Ð´Ð°Ñ‚Ð° Ñ‚Ð° Ñ‡Ð°Ñ ISO",
          date: "Ð´Ð°Ñ‚Ð° ISO",
          time: "Ñ‡Ð°Ñ ISO",
          duration: "Ñ‚Ñ€Ð¸Ð²Ð°Ð»Ñ–ÑÑ‚ÑŒ ISO",
          ipv4: "Ð°Ð´Ñ€ÐµÑÐ° IPv4",
          ipv6: "Ð°Ð´Ñ€ÐµÑÐ° IPv6",
          cidrv4: "Ð´Ñ–Ð°Ð¿Ð°Ð·Ð¾Ð½ IPv4",
          cidrv6: "Ð´Ñ–Ð°Ð¿Ð°Ð·Ð¾Ð½ IPv6",
          base64: "Ñ€ÑÐ´Ð¾Ðº Ñƒ ÐºÐ¾Ð´ÑƒÐ²Ð°Ð½Ð½Ñ– base64",
          base64url: "Ñ€ÑÐ´Ð¾Ðº Ñƒ ÐºÐ¾Ð´ÑƒÐ²Ð°Ð½Ð½Ñ– base64url",
          json_string: "Ñ€ÑÐ´Ð¾Ðº JSON",
          e164: "Ð½Ð¾Ð¼ÐµÑ€ E.164",
          jwt: "JWT",
          template_literal: "Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${issue.expected}, Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¾ ${parsedType(issue.input)}`;
              // return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${issue.expected}, Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð½Ð¾ ${util.getParsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ ${stringifyPrimitive(issue.values[0])}`;
                  return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð° Ð¾Ð¿Ñ†Ñ–Ñ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ Ð¾Ð´Ð½Ðµ Ð· ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð²ÐµÐ»Ð¸ÐºÐµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "ÐµÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ–Ð²"}`;
                  return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð²ÐµÐ»Ð¸ÐºÐµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue.origin ?? "Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ"} Ð±ÑƒÐ´Ðµ ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð¼Ð°Ð»Ðµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `Ð—Ð°Ð½Ð°Ð´Ñ‚Ð¾ Ð¼Ð°Ð»Ðµ: Ð¾Ñ‡Ñ–ÐºÑƒÑ”Ñ‚ÑŒÑÑ, Ñ‰Ð¾ ${issue.origin} Ð±ÑƒÐ´Ðµ ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð¿Ð¾Ñ‡Ð¸Ð½Ð°Ñ‚Ð¸ÑÑ Ð· "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð·Ð°ÐºÑ–Ð½Ñ‡ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Ð½Ð° "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð¼Ñ–ÑÑ‚Ð¸Ñ‚Ð¸ "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ Ñ€ÑÐ´Ð¾Ðº: Ð¿Ð¾Ð²Ð¸Ð½ÐµÐ½ Ð²Ñ–Ð´Ð¿Ð¾Ð²Ñ–Ð´Ð°Ñ‚Ð¸ ÑˆÐ°Ð±Ð»Ð¾Ð½Ñƒ ${_issue.pattern}`;
                  return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ðµ Ñ‡Ð¸ÑÐ»Ð¾: Ð¿Ð¾Ð²Ð¸Ð½Ð½Ð¾ Ð±ÑƒÑ‚Ð¸ ÐºÑ€Ð°Ñ‚Ð½Ð¸Ð¼ ${issue.divisor}`;
              case "unrecognized_keys":
                  return `ÐÐµÑ€Ð¾Ð·Ð¿Ñ–Ð·Ð½Ð°Ð½Ð¸Ð¹ ÐºÐ»ÑŽÑ‡${issue.keys.length > 1 ? "Ñ–" : ""}: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ÐºÐ»ÑŽÑ‡ Ñƒ ${issue.origin}`;
              case "invalid_union":
                  return "ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–";
              case "invalid_element":
                  return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ Ñƒ ${issue.origin}`;
              default:
                  return `ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ– Ð²Ñ…Ñ–Ð´Ð½Ñ– Ð´Ð°Ð½Ñ–`;
          }
      };
  };
  function ua () {
      return {
          localeError: error$5(),
      };
  }

  const error$4 = () => {
      const Sizable = {
          string: { unit: "Ø­Ø±ÙˆÙ", verb: "ÛÙˆÙ†Ø§" },
          file: { unit: "Ø¨Ø§Ø¦Ù¹Ø³", verb: "ÛÙˆÙ†Ø§" },
          array: { unit: "Ø¢Ø¦Ù¹Ù…Ø²", verb: "ÛÙˆÙ†Ø§" },
          set: { unit: "Ø¢Ø¦Ù¹Ù…Ø²", verb: "ÛÙˆÙ†Ø§" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "Ù†Ù…Ø¨Ø±";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "Ø¢Ø±Û’";
                  }
                  if (data === null) {
                      return "Ù†Ù„";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "Ø§Ù† Ù¾Ù¹",
          email: "Ø§ÛŒ Ù…ÛŒÙ„ Ø§ÛŒÚˆØ±ÛŒØ³",
          url: "ÛŒÙˆ Ø¢Ø± Ø§ÛŒÙ„",
          emoji: "Ø§ÛŒÙ…ÙˆØ¬ÛŒ",
          uuid: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
          uuidv4: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ ÙˆÛŒ 4",
          uuidv6: "ÛŒÙˆ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ ÙˆÛŒ 6",
          nanoid: "Ù†ÛŒÙ†Ùˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
          guid: "Ø¬ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
          cuid: "Ø³ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
          cuid2: "Ø³ÛŒ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ 2",
          ulid: "ÛŒÙˆ Ø§ÛŒÙ„ Ø¢Ø¦ÛŒ ÚˆÛŒ",
          xid: "Ø§ÛŒÚ©Ø³ Ø¢Ø¦ÛŒ ÚˆÛŒ",
          ksuid: "Ú©Û’ Ø§ÛŒØ³ ÛŒÙˆ Ø¢Ø¦ÛŒ ÚˆÛŒ",
          datetime: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ÚˆÛŒÙ¹ Ù¹Ø§Ø¦Ù…",
          date: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ØªØ§Ø±ÛŒØ®",
          time: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ ÙˆÙ‚Øª",
          duration: "Ø¢Ø¦ÛŒ Ø§ÛŒØ³ Ø§Ùˆ Ù…Ø¯Øª",
          ipv4: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 4 Ø§ÛŒÚˆØ±ÛŒØ³",
          ipv6: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 6 Ø§ÛŒÚˆØ±ÛŒØ³",
          cidrv4: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 4 Ø±ÛŒÙ†Ø¬",
          cidrv6: "Ø¢Ø¦ÛŒ Ù¾ÛŒ ÙˆÛŒ 6 Ø±ÛŒÙ†Ø¬",
          base64: "Ø¨ÛŒØ³ 64 Ø§Ù† Ú©ÙˆÚˆÚˆ Ø³Ù¹Ø±Ù†Ú¯",
          base64url: "Ø¨ÛŒØ³ 64 ÛŒÙˆ Ø¢Ø± Ø§ÛŒÙ„ Ø§Ù† Ú©ÙˆÚˆÚˆ Ø³Ù¹Ø±Ù†Ú¯",
          json_string: "Ø¬Û’ Ø§ÛŒØ³ Ø§Ùˆ Ø§ÛŒÙ† Ø³Ù¹Ø±Ù†Ú¯",
          e164: "Ø§ÛŒ 164 Ù†Ù…Ø¨Ø±",
          jwt: "Ø¬Û’ ÚˆØ¨Ù„ÛŒÙˆ Ù¹ÛŒ",
          template_literal: "Ø§Ù† Ù¾Ù¹",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹: ${issue.expected} Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§ØŒ ${parsedType(issue.input)} Ù…ÙˆØµÙˆÙ„ ÛÙˆØ§`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹: ${stringifyPrimitive(issue.values[0])} Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
                  return `ØºÙ„Ø· Ø¢Ù¾Ø´Ù†: ${joinValues(issue.values, "|")} Ù…ÛŒÚº Ø³Û’ Ø§ÛŒÚ© Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `Ø¨ÛØª Ø¨Ú‘Ø§: ${issue.origin ?? "ÙˆÛŒÙ„ÛŒÙˆ"} Ú©Û’ ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Ø¹Ù†Ø§ØµØ±"} ÛÙˆÙ†Û’ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Û’`;
                  return `Ø¨ÛØª Ø¨Ú‘Ø§: ${issue.origin ?? "ÙˆÛŒÙ„ÛŒÙˆ"} Ú©Ø§ ${adj}${issue.maximum.toString()} ÛÙˆÙ†Ø§ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `Ø¨ÛØª Ú†Ú¾ÙˆÙ¹Ø§: ${issue.origin} Ú©Û’ ${adj}${issue.minimum.toString()} ${sizing.unit} ÛÙˆÙ†Û’ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Û’`;
                  }
                  return `Ø¨ÛØª Ú†Ú¾ÙˆÙ¹Ø§: ${issue.origin} Ú©Ø§ ${adj}${issue.minimum.toString()} ÛÙˆÙ†Ø§ Ù…ØªÙˆÙ‚Ø¹ ØªÚ¾Ø§`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.prefix}" Ø³Û’ Ø´Ø±ÙˆØ¹ ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
                  }
                  if (_issue.format === "ends_with")
                      return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.suffix}" Ù¾Ø± Ø®ØªÙ… ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
                  if (_issue.format === "includes")
                      return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: "${_issue.includes}" Ø´Ø§Ù…Ù„ ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
                  if (_issue.format === "regex")
                      return `ØºÙ„Ø· Ø³Ù¹Ø±Ù†Ú¯: Ù¾ÛŒÙ¹Ø±Ù† ${_issue.pattern} Ø³Û’ Ù…ÛŒÚ† ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
                  return `ØºÙ„Ø· ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `ØºÙ„Ø· Ù†Ù…Ø¨Ø±: ${issue.divisor} Ú©Ø§ Ù…Ø¶Ø§Ø¹Ù ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’`;
              case "unrecognized_keys":
                  return `ØºÛŒØ± ØªØ³Ù„ÛŒÙ… Ø´Ø¯Û Ú©ÛŒ${issue.keys.length > 1 ? "Ø²" : ""}: ${joinValues(issue.keys, "ØŒ ")}`;
              case "invalid_key":
                  return `${issue.origin} Ù…ÛŒÚº ØºÙ„Ø· Ú©ÛŒ`;
              case "invalid_union":
                  return "ØºÙ„Ø· Ø§Ù† Ù¾Ù¹";
              case "invalid_element":
                  return `${issue.origin} Ù…ÛŒÚº ØºÙ„Ø· ÙˆÛŒÙ„ÛŒÙˆ`;
              default:
                  return `ØºÙ„Ø· Ø§Ù† Ù¾Ù¹`;
          }
      };
  };
  function ur () {
      return {
          localeError: error$4(),
      };
  }

  const error$3 = () => {
      const Sizable = {
          string: { unit: "kÃ½ tá»±", verb: "cÃ³" },
          file: { unit: "byte", verb: "cÃ³" },
          array: { unit: "pháº§n tá»­", verb: "cÃ³" },
          set: { unit: "pháº§n tá»­", verb: "cÃ³" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "sá»‘";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "máº£ng";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "Ä‘áº§u vÃ o",
          email: "Ä‘á»‹a chá»‰ email",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ngÃ y giá» ISO",
          date: "ngÃ y ISO",
          time: "giá» ISO",
          duration: "khoáº£ng thá»i gian ISO",
          ipv4: "Ä‘á»‹a chá»‰ IPv4",
          ipv6: "Ä‘á»‹a chá»‰ IPv6",
          cidrv4: "dáº£i IPv4",
          cidrv6: "dáº£i IPv6",
          base64: "chuá»—i mÃ£ hÃ³a base64",
          base64url: "chuá»—i mÃ£ hÃ³a base64url",
          json_string: "chuá»—i JSON",
          e164: "sá»‘ E.164",
          jwt: "JWT",
          template_literal: "Ä‘áº§u vÃ o",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `Äáº§u vÃ o khÃ´ng há»£p lá»‡: mong Ä‘á»£i ${issue.expected}, nháº­n Ä‘Æ°á»£c ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `Äáº§u vÃ o khÃ´ng há»£p lá»‡: mong Ä‘á»£i ${stringifyPrimitive(issue.values[0])}`;
                  return `TÃ¹y chá»n khÃ´ng há»£p lá»‡: mong Ä‘á»£i má»™t trong cÃ¡c giÃ¡ trá»‹ ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `QuÃ¡ lá»›n: mong Ä‘á»£i ${issue.origin ?? "giÃ¡ trá»‹"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "pháº§n tá»­"}`;
                  return `QuÃ¡ lá»›n: mong Ä‘á»£i ${issue.origin ?? "giÃ¡ trá»‹"} ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `QuÃ¡ nhá»: mong Ä‘á»£i ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `QuÃ¡ nhá»: mong Ä‘á»£i ${issue.origin} ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i báº¯t Ä‘áº§u báº±ng "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i káº¿t thÃºc báº±ng "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i bao gá»“m "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `Chuá»—i khÃ´ng há»£p lá»‡: pháº£i khá»›p vá»›i máº«u ${_issue.pattern}`;
                  return `${Nouns[_issue.format] ?? issue.format} khÃ´ng há»£p lá»‡`;
              }
              case "not_multiple_of":
                  return `Sá»‘ khÃ´ng há»£p lá»‡: pháº£i lÃ  bá»™i sá»‘ cá»§a ${issue.divisor}`;
              case "unrecognized_keys":
                  return `KhÃ³a khÃ´ng Ä‘Æ°á»£c nháº­n dáº¡ng: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `KhÃ³a khÃ´ng há»£p lá»‡ trong ${issue.origin}`;
              case "invalid_union":
                  return "Äáº§u vÃ o khÃ´ng há»£p lá»‡";
              case "invalid_element":
                  return `GiÃ¡ trá»‹ khÃ´ng há»£p lá»‡ trong ${issue.origin}`;
              default:
                  return `Äáº§u vÃ o khÃ´ng há»£p lá»‡`;
          }
      };
  };
  function vi () {
      return {
          localeError: error$3(),
      };
  }

  const error$2 = () => {
      const Sizable = {
          string: { unit: "å­—ç¬¦", verb: "åŒ…å«" },
          file: { unit: "å­—èŠ‚", verb: "åŒ…å«" },
          array: { unit: "é¡¹", verb: "åŒ…å«" },
          set: { unit: "é¡¹", verb: "åŒ…å«" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "éžæ•°å­—(NaN)" : "æ•°å­—";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "æ•°ç»„";
                  }
                  if (data === null) {
                      return "ç©ºå€¼(null)";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "è¾“å…¥",
          email: "ç”µå­é‚®ä»¶",
          url: "URL",
          emoji: "è¡¨æƒ…ç¬¦å·",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISOæ—¥æœŸæ—¶é—´",
          date: "ISOæ—¥æœŸ",
          time: "ISOæ—¶é—´",
          duration: "ISOæ—¶é•¿",
          ipv4: "IPv4åœ°å€",
          ipv6: "IPv6åœ°å€",
          cidrv4: "IPv4ç½‘æ®µ",
          cidrv6: "IPv6ç½‘æ®µ",
          base64: "base64ç¼–ç å­—ç¬¦ä¸²",
          base64url: "base64urlç¼–ç å­—ç¬¦ä¸²",
          json_string: "JSONå­—ç¬¦ä¸²",
          e164: "E.164å·ç ",
          jwt: "JWT",
          template_literal: "è¾“å…¥",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `æ— æ•ˆè¾“å…¥ï¼šæœŸæœ› ${issue.expected}ï¼Œå®žé™…æŽ¥æ”¶ ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `æ— æ•ˆè¾“å…¥ï¼šæœŸæœ› ${stringifyPrimitive(issue.values[0])}`;
                  return `æ— æ•ˆé€‰é¡¹ï¼šæœŸæœ›ä»¥ä¸‹ä¹‹ä¸€ ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `æ•°å€¼è¿‡å¤§ï¼šæœŸæœ› ${issue.origin ?? "å€¼"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "ä¸ªå…ƒç´ "}`;
                  return `æ•°å€¼è¿‡å¤§ï¼šæœŸæœ› ${issue.origin ?? "å€¼"} ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `æ•°å€¼è¿‡å°ï¼šæœŸæœ› ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `æ•°å€¼è¿‡å°ï¼šæœŸæœ› ${issue.origin} ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»ä»¥ "${_issue.prefix}" å¼€å¤´`;
                  if (_issue.format === "ends_with")
                      return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»ä»¥ "${_issue.suffix}" ç»“å°¾`;
                  if (_issue.format === "includes")
                      return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»åŒ…å« "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `æ— æ•ˆå­—ç¬¦ä¸²ï¼šå¿…é¡»æ»¡è¶³æ­£åˆ™è¡¨è¾¾å¼ ${_issue.pattern}`;
                  return `æ— æ•ˆ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `æ— æ•ˆæ•°å­—ï¼šå¿…é¡»æ˜¯ ${issue.divisor} çš„å€æ•°`;
              case "unrecognized_keys":
                  return `å‡ºçŽ°æœªçŸ¥çš„é”®(key): ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `${issue.origin} ä¸­çš„é”®(key)æ— æ•ˆ`;
              case "invalid_union":
                  return "æ— æ•ˆè¾“å…¥";
              case "invalid_element":
                  return `${issue.origin} ä¸­åŒ…å«æ— æ•ˆå€¼(value)`;
              default:
                  return `æ— æ•ˆè¾“å…¥`;
          }
      };
  };
  function zhCN () {
      return {
          localeError: error$2(),
      };
  }

  const error$1 = () => {
      const Sizable = {
          string: { unit: "å­—å…ƒ", verb: "æ“æœ‰" },
          file: { unit: "ä½å…ƒçµ„", verb: "æ“æœ‰" },
          array: { unit: "é …ç›®", verb: "æ“æœ‰" },
          set: { unit: "é …ç›®", verb: "æ“æœ‰" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "number";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "array";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "è¼¸å…¥",
          email: "éƒµä»¶åœ°å€",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "ISO æ—¥æœŸæ™‚é–“",
          date: "ISO æ—¥æœŸ",
          time: "ISO æ™‚é–“",
          duration: "ISO æœŸé–“",
          ipv4: "IPv4 ä½å€",
          ipv6: "IPv6 ä½å€",
          cidrv4: "IPv4 ç¯„åœ",
          cidrv6: "IPv6 ç¯„åœ",
          base64: "base64 ç·¨ç¢¼å­—ä¸²",
          base64url: "base64url ç·¨ç¢¼å­—ä¸²",
          json_string: "JSON å­—ä¸²",
          e164: "E.164 æ•¸å€¼",
          jwt: "JWT",
          template_literal: "è¼¸å…¥",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ç„¡æ•ˆçš„è¼¸å…¥å€¼ï¼šé æœŸç‚º ${issue.expected}ï¼Œä½†æ”¶åˆ° ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `ç„¡æ•ˆçš„è¼¸å…¥å€¼ï¼šé æœŸç‚º ${stringifyPrimitive(issue.values[0])}`;
                  return `ç„¡æ•ˆçš„é¸é …ï¼šé æœŸç‚ºä»¥ä¸‹å…¶ä¸­ä¹‹ä¸€ ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `æ•¸å€¼éŽå¤§ï¼šé æœŸ ${issue.origin ?? "å€¼"} æ‡‰ç‚º ${adj}${issue.maximum.toString()} ${sizing.unit ?? "å€‹å…ƒç´ "}`;
                  return `æ•¸å€¼éŽå¤§ï¼šé æœŸ ${issue.origin ?? "å€¼"} æ‡‰ç‚º ${adj}${issue.maximum.toString()}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing) {
                      return `æ•¸å€¼éŽå°ï¼šé æœŸ ${issue.origin} æ‡‰ç‚º ${adj}${issue.minimum.toString()} ${sizing.unit}`;
                  }
                  return `æ•¸å€¼éŽå°ï¼šé æœŸ ${issue.origin} æ‡‰ç‚º ${adj}${issue.minimum.toString()}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with") {
                      return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆä»¥ "${_issue.prefix}" é–‹é ­`;
                  }
                  if (_issue.format === "ends_with")
                      return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆä»¥ "${_issue.suffix}" çµå°¾`;
                  if (_issue.format === "includes")
                      return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆåŒ…å« "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `ç„¡æ•ˆçš„å­—ä¸²ï¼šå¿…é ˆç¬¦åˆæ ¼å¼ ${_issue.pattern}`;
                  return `ç„¡æ•ˆçš„ ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `ç„¡æ•ˆçš„æ•¸å­—ï¼šå¿…é ˆç‚º ${issue.divisor} çš„å€æ•¸`;
              case "unrecognized_keys":
                  return `ç„¡æ³•è­˜åˆ¥çš„éµå€¼${issue.keys.length > 1 ? "å€‘" : ""}ï¼š${joinValues(issue.keys, "ã€")}`;
              case "invalid_key":
                  return `${issue.origin} ä¸­æœ‰ç„¡æ•ˆçš„éµå€¼`;
              case "invalid_union":
                  return "ç„¡æ•ˆçš„è¼¸å…¥å€¼";
              case "invalid_element":
                  return `${issue.origin} ä¸­æœ‰ç„¡æ•ˆçš„å€¼`;
              default:
                  return `ç„¡æ•ˆçš„è¼¸å…¥å€¼`;
          }
      };
  };
  function zhTW () {
      return {
          localeError: error$1(),
      };
  }

  const error = () => {
      const Sizable = {
          string: { unit: "Ã mi", verb: "nÃ­" },
          file: { unit: "bytes", verb: "nÃ­" },
          array: { unit: "nkan", verb: "nÃ­" },
          set: { unit: "nkan", verb: "nÃ­" },
      };
      function getSizing(origin) {
          return Sizable[origin] ?? null;
      }
      const parsedType = (data) => {
          const t = typeof data;
          switch (t) {
              case "number": {
                  return Number.isNaN(data) ? "NaN" : "ná»ÌmbÃ ";
              }
              case "object": {
                  if (Array.isArray(data)) {
                      return "akopá»";
                  }
                  if (data === null) {
                      return "null";
                  }
                  if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
                      return data.constructor.name;
                  }
              }
          }
          return t;
      };
      const Nouns = {
          regex: "áº¹Ì€rá» Ã¬bÃ¡wá»lÃ©",
          email: "Ã dÃ­ráº¹ÌsÃ¬ Ã¬máº¹ÌlÃ¬",
          url: "URL",
          emoji: "emoji",
          uuid: "UUID",
          uuidv4: "UUIDv4",
          uuidv6: "UUIDv6",
          nanoid: "nanoid",
          guid: "GUID",
          cuid: "cuid",
          cuid2: "cuid2",
          ulid: "ULID",
          xid: "XID",
          ksuid: "KSUID",
          datetime: "Ã kÃ³kÃ² ISO",
          date: "á»já»Ì ISO",
          time: "Ã kÃ³kÃ² ISO",
          duration: "Ã kÃ³kÃ² tÃ³ pÃ© ISO",
          ipv4: "Ã dÃ­ráº¹ÌsÃ¬ IPv4",
          ipv6: "Ã dÃ­ráº¹ÌsÃ¬ IPv6",
          cidrv4: "Ã gbÃ¨gbÃ¨ IPv4",
          cidrv6: "Ã gbÃ¨gbÃ¨ IPv6",
          base64: "á»Ì€rá»Ì€ tÃ­ a ká»Ì nÃ­ base64",
          base64url: "á»Ì€rá»Ì€ base64url",
          json_string: "á»Ì€rá»Ì€ JSON",
          e164: "ná»ÌmbÃ  E.164",
          jwt: "JWT",
          template_literal: "áº¹Ì€rá» Ã¬bÃ¡wá»lÃ©",
      };
      return (issue) => {
          switch (issue.code) {
              case "invalid_type":
                  return `ÃŒbÃ¡wá»lÃ© aá¹£Ã¬á¹£e: a nÃ­ lÃ¡ti fi ${issue.expected}, Ã má»Ì€ a rÃ­ ${parsedType(issue.input)}`;
              case "invalid_value":
                  if (issue.values.length === 1)
                      return `ÃŒbÃ¡wá»lÃ© aá¹£Ã¬á¹£e: a nÃ­ lÃ¡ti fi ${stringifyPrimitive(issue.values[0])}`;
                  return `Ã€á¹£Ã yÃ n aá¹£Ã¬á¹£e: yan á»Ì€kan lÃ¡ra ${joinValues(issue.values, "|")}`;
              case "too_big": {
                  const adj = issue.inclusive ? "<=" : "<";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `TÃ³ pá»Ì€ jÃ¹: a nÃ­ lÃ¡ti jáº¹Ì pÃ© ${issue.origin ?? "iye"} ${sizing.verb} ${adj}${issue.maximum} ${sizing.unit}`;
                  return `TÃ³ pá»Ì€ jÃ¹: a nÃ­ lÃ¡ti jáº¹Ì ${adj}${issue.maximum}`;
              }
              case "too_small": {
                  const adj = issue.inclusive ? ">=" : ">";
                  const sizing = getSizing(issue.origin);
                  if (sizing)
                      return `KÃ©rÃ© ju: a nÃ­ lÃ¡ti jáº¹Ì pÃ© ${issue.origin} ${sizing.verb} ${adj}${issue.minimum} ${sizing.unit}`;
                  return `KÃ©rÃ© ju: a nÃ­ lÃ¡ti jáº¹Ì ${adj}${issue.minimum}`;
              }
              case "invalid_format": {
                  const _issue = issue;
                  if (_issue.format === "starts_with")
                      return `á»ŒÌ€rá»Ì€ aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ báº¹Ì€ráº¹Ì€ páº¹Ì€lÃº "${_issue.prefix}"`;
                  if (_issue.format === "ends_with")
                      return `á»ŒÌ€rá»Ì€ aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ parÃ­ páº¹Ì€lÃº "${_issue.suffix}"`;
                  if (_issue.format === "includes")
                      return `á»ŒÌ€rá»Ì€ aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ nÃ­ "${_issue.includes}"`;
                  if (_issue.format === "regex")
                      return `á»ŒÌ€rá»Ì€ aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ bÃ¡ Ã páº¹áº¹ráº¹ mu ${_issue.pattern}`;
                  return `Aá¹£Ã¬á¹£e: ${Nouns[_issue.format] ?? issue.format}`;
              }
              case "not_multiple_of":
                  return `Ná»ÌmbÃ  aá¹£Ã¬á¹£e: gbá»Ìdá»Ì€ jáº¹Ì Ã¨yÃ  pÃ­pÃ­n ti ${issue.divisor}`;
              case "unrecognized_keys":
                  return `Bá»tÃ¬nÃ¬ Ã Ã¬má»Ì€: ${joinValues(issue.keys, ", ")}`;
              case "invalid_key":
                  return `Bá»tÃ¬nÃ¬ aá¹£Ã¬á¹£e nÃ­nÃº ${issue.origin}`;
              case "invalid_union":
                  return "ÃŒbÃ¡wá»lÃ© aá¹£Ã¬á¹£e";
              case "invalid_element":
                  return `Iye aá¹£Ã¬á¹£e nÃ­nÃº ${issue.origin}`;
              default:
                  return "ÃŒbÃ¡wá»lÃ© aá¹£Ã¬á¹£e";
          }
      };
  };
  function yo () {
      return {
          localeError: error(),
      };
  }

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ar: ar,
    az: az,
    be: be,
    ca: ca,
    cs: cs,
    da: da,
    de: de,
    en: en,
    eo: eo,
    es: es,
    fa: fa,
    fi: fi,
    fr: fr,
    frCA: frCA,
    he: he,
    hu: hu,
    id: id,
    is: is,
    it: it,
    ja: ja,
    kh: kh,
    ko: ko,
    mk: mk,
    ms: ms,
    nl: nl,
    no: no,
    ota: ota,
    pl: pl,
    ps: ps,
    pt: pt,
    ru: ru,
    sl: sl,
    sv: sv,
    ta: ta,
    th: th,
    tr: tr,
    ua: ua,
    ur: ur,
    vi: vi,
    yo: yo,
    zhCN: zhCN,
    zhTW: zhTW
  });

  const $output = Symbol("ZodOutput");
  const $input = Symbol("ZodInput");
  class $ZodRegistry {
      constructor() {
          this._map = new Map();
          this._idmap = new Map();
      }
      add(schema, ..._meta) {
          const meta = _meta[0];
          this._map.set(schema, meta);
          if (meta && typeof meta === "object" && "id" in meta) {
              if (this._idmap.has(meta.id)) {
                  throw new Error(`ID ${meta.id} already exists in the registry`);
              }
              this._idmap.set(meta.id, schema);
          }
          return this;
      }
      clear() {
          this._map = new Map();
          this._idmap = new Map();
          return this;
      }
      remove(schema) {
          const meta = this._map.get(schema);
          if (meta && typeof meta === "object" && "id" in meta) {
              this._idmap.delete(meta.id);
          }
          this._map.delete(schema);
          return this;
      }
      get(schema) {
          // return this._map.get(schema) as any;
          // inherit metadata
          const p = schema._zod.parent;
          if (p) {
              const pm = { ...(this.get(p) ?? {}) };
              delete pm.id; // do not inherit id
              const f = { ...pm, ...this._map.get(schema) };
              return Object.keys(f).length ? f : undefined;
          }
          return this._map.get(schema);
      }
      has(schema) {
          return this._map.has(schema);
      }
  }
  // registries
  function registry() {
      return new $ZodRegistry();
  }
  const globalRegistry = /*@__PURE__*/ registry();

  function _string(Class, params) {
      return new Class({
          type: "string",
          ...normalizeParams(params),
      });
  }
  function _coercedString(Class, params) {
      return new Class({
          type: "string",
          coerce: true,
          ...normalizeParams(params),
      });
  }
  function _email(Class, params) {
      return new Class({
          type: "string",
          format: "email",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _guid(Class, params) {
      return new Class({
          type: "string",
          format: "guid",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _uuid(Class, params) {
      return new Class({
          type: "string",
          format: "uuid",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _uuidv4(Class, params) {
      return new Class({
          type: "string",
          format: "uuid",
          check: "string_format",
          abort: false,
          version: "v4",
          ...normalizeParams(params),
      });
  }
  function _uuidv6(Class, params) {
      return new Class({
          type: "string",
          format: "uuid",
          check: "string_format",
          abort: false,
          version: "v6",
          ...normalizeParams(params),
      });
  }
  function _uuidv7(Class, params) {
      return new Class({
          type: "string",
          format: "uuid",
          check: "string_format",
          abort: false,
          version: "v7",
          ...normalizeParams(params),
      });
  }
  function _url(Class, params) {
      return new Class({
          type: "string",
          format: "url",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _emoji(Class, params) {
      return new Class({
          type: "string",
          format: "emoji",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _nanoid(Class, params) {
      return new Class({
          type: "string",
          format: "nanoid",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _cuid(Class, params) {
      return new Class({
          type: "string",
          format: "cuid",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _cuid2(Class, params) {
      return new Class({
          type: "string",
          format: "cuid2",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _ulid(Class, params) {
      return new Class({
          type: "string",
          format: "ulid",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _xid(Class, params) {
      return new Class({
          type: "string",
          format: "xid",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _ksuid(Class, params) {
      return new Class({
          type: "string",
          format: "ksuid",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _ipv4(Class, params) {
      return new Class({
          type: "string",
          format: "ipv4",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _ipv6(Class, params) {
      return new Class({
          type: "string",
          format: "ipv6",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _cidrv4(Class, params) {
      return new Class({
          type: "string",
          format: "cidrv4",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _cidrv6(Class, params) {
      return new Class({
          type: "string",
          format: "cidrv6",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _base64(Class, params) {
      return new Class({
          type: "string",
          format: "base64",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _base64url(Class, params) {
      return new Class({
          type: "string",
          format: "base64url",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _e164(Class, params) {
      return new Class({
          type: "string",
          format: "e164",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  function _jwt(Class, params) {
      return new Class({
          type: "string",
          format: "jwt",
          check: "string_format",
          abort: false,
          ...normalizeParams(params),
      });
  }
  const TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6,
  };
  function _isoDateTime(Class, params) {
      return new Class({
          type: "string",
          format: "datetime",
          check: "string_format",
          offset: false,
          local: false,
          precision: null,
          ...normalizeParams(params),
      });
  }
  function _isoDate(Class, params) {
      return new Class({
          type: "string",
          format: "date",
          check: "string_format",
          ...normalizeParams(params),
      });
  }
  function _isoTime(Class, params) {
      return new Class({
          type: "string",
          format: "time",
          check: "string_format",
          precision: null,
          ...normalizeParams(params),
      });
  }
  function _isoDuration(Class, params) {
      return new Class({
          type: "string",
          format: "duration",
          check: "string_format",
          ...normalizeParams(params),
      });
  }
  function _number(Class, params) {
      return new Class({
          type: "number",
          checks: [],
          ...normalizeParams(params),
      });
  }
  function _coercedNumber(Class, params) {
      return new Class({
          type: "number",
          coerce: true,
          checks: [],
          ...normalizeParams(params),
      });
  }
  function _int(Class, params) {
      return new Class({
          type: "number",
          check: "number_format",
          abort: false,
          format: "safeint",
          ...normalizeParams(params),
      });
  }
  function _float32(Class, params) {
      return new Class({
          type: "number",
          check: "number_format",
          abort: false,
          format: "float32",
          ...normalizeParams(params),
      });
  }
  function _float64(Class, params) {
      return new Class({
          type: "number",
          check: "number_format",
          abort: false,
          format: "float64",
          ...normalizeParams(params),
      });
  }
  function _int32(Class, params) {
      return new Class({
          type: "number",
          check: "number_format",
          abort: false,
          format: "int32",
          ...normalizeParams(params),
      });
  }
  function _uint32(Class, params) {
      return new Class({
          type: "number",
          check: "number_format",
          abort: false,
          format: "uint32",
          ...normalizeParams(params),
      });
  }
  function _boolean(Class, params) {
      return new Class({
          type: "boolean",
          ...normalizeParams(params),
      });
  }
  function _coercedBoolean(Class, params) {
      return new Class({
          type: "boolean",
          coerce: true,
          ...normalizeParams(params),
      });
  }
  function _bigint(Class, params) {
      return new Class({
          type: "bigint",
          ...normalizeParams(params),
      });
  }
  function _coercedBigint(Class, params) {
      return new Class({
          type: "bigint",
          coerce: true,
          ...normalizeParams(params),
      });
  }
  function _int64(Class, params) {
      return new Class({
          type: "bigint",
          check: "bigint_format",
          abort: false,
          format: "int64",
          ...normalizeParams(params),
      });
  }
  function _uint64(Class, params) {
      return new Class({
          type: "bigint",
          check: "bigint_format",
          abort: false,
          format: "uint64",
          ...normalizeParams(params),
      });
  }
  function _symbol(Class, params) {
      return new Class({
          type: "symbol",
          ...normalizeParams(params),
      });
  }
  function _undefined$1(Class, params) {
      return new Class({
          type: "undefined",
          ...normalizeParams(params),
      });
  }
  function _null$1(Class, params) {
      return new Class({
          type: "null",
          ...normalizeParams(params),
      });
  }
  function _any(Class) {
      return new Class({
          type: "any",
      });
  }
  function _unknown(Class) {
      return new Class({
          type: "unknown",
      });
  }
  function _never(Class, params) {
      return new Class({
          type: "never",
          ...normalizeParams(params),
      });
  }
  function _void$1(Class, params) {
      return new Class({
          type: "void",
          ...normalizeParams(params),
      });
  }
  function _date(Class, params) {
      return new Class({
          type: "date",
          ...normalizeParams(params),
      });
  }
  function _coercedDate(Class, params) {
      return new Class({
          type: "date",
          coerce: true,
          ...normalizeParams(params),
      });
  }
  function _nan(Class, params) {
      return new Class({
          type: "nan",
          ...normalizeParams(params),
      });
  }
  function _lt(value, params) {
      return new $ZodCheckLessThan({
          check: "less_than",
          ...normalizeParams(params),
          value,
          inclusive: false,
      });
  }
  function _lte(value, params) {
      return new $ZodCheckLessThan({
          check: "less_than",
          ...normalizeParams(params),
          value,
          inclusive: true,
      });
  }
  function _gt(value, params) {
      return new $ZodCheckGreaterThan({
          check: "greater_than",
          ...normalizeParams(params),
          value,
          inclusive: false,
      });
  }
  function _gte(value, params) {
      return new $ZodCheckGreaterThan({
          check: "greater_than",
          ...normalizeParams(params),
          value,
          inclusive: true,
      });
  }
  function _positive(params) {
      return _gt(0, params);
  }
  // negative
  function _negative(params) {
      return _lt(0, params);
  }
  // nonpositive
  function _nonpositive(params) {
      return _lte(0, params);
  }
  // nonnegative
  function _nonnegative(params) {
      return _gte(0, params);
  }
  function _multipleOf(value, params) {
      return new $ZodCheckMultipleOf({
          check: "multiple_of",
          ...normalizeParams(params),
          value,
      });
  }
  function _maxSize(maximum, params) {
      return new $ZodCheckMaxSize({
          check: "max_size",
          ...normalizeParams(params),
          maximum,
      });
  }
  function _minSize(minimum, params) {
      return new $ZodCheckMinSize({
          check: "min_size",
          ...normalizeParams(params),
          minimum,
      });
  }
  function _size(size, params) {
      return new $ZodCheckSizeEquals({
          check: "size_equals",
          ...normalizeParams(params),
          size,
      });
  }
  function _maxLength(maximum, params) {
      const ch = new $ZodCheckMaxLength({
          check: "max_length",
          ...normalizeParams(params),
          maximum,
      });
      return ch;
  }
  function _minLength(minimum, params) {
      return new $ZodCheckMinLength({
          check: "min_length",
          ...normalizeParams(params),
          minimum,
      });
  }
  function _length(length, params) {
      return new $ZodCheckLengthEquals({
          check: "length_equals",
          ...normalizeParams(params),
          length,
      });
  }
  function _regex(pattern, params) {
      return new $ZodCheckRegex({
          check: "string_format",
          format: "regex",
          ...normalizeParams(params),
          pattern,
      });
  }
  function _lowercase(params) {
      return new $ZodCheckLowerCase({
          check: "string_format",
          format: "lowercase",
          ...normalizeParams(params),
      });
  }
  function _uppercase(params) {
      return new $ZodCheckUpperCase({
          check: "string_format",
          format: "uppercase",
          ...normalizeParams(params),
      });
  }
  function _includes(includes, params) {
      return new $ZodCheckIncludes({
          check: "string_format",
          format: "includes",
          ...normalizeParams(params),
          includes,
      });
  }
  function _startsWith(prefix, params) {
      return new $ZodCheckStartsWith({
          check: "string_format",
          format: "starts_with",
          ...normalizeParams(params),
          prefix,
      });
  }
  function _endsWith(suffix, params) {
      return new $ZodCheckEndsWith({
          check: "string_format",
          format: "ends_with",
          ...normalizeParams(params),
          suffix,
      });
  }
  function _property(property, schema, params) {
      return new $ZodCheckProperty({
          check: "property",
          property,
          schema,
          ...normalizeParams(params),
      });
  }
  function _mime(types, params) {
      return new $ZodCheckMimeType({
          check: "mime_type",
          mime: types,
          ...normalizeParams(params),
      });
  }
  function _overwrite(tx) {
      return new $ZodCheckOverwrite({
          check: "overwrite",
          tx,
      });
  }
  // normalize
  function _normalize(form) {
      return _overwrite((input) => input.normalize(form));
  }
  // trim
  function _trim() {
      return _overwrite((input) => input.trim());
  }
  // toLowerCase
  function _toLowerCase() {
      return _overwrite((input) => input.toLowerCase());
  }
  // toUpperCase
  function _toUpperCase() {
      return _overwrite((input) => input.toUpperCase());
  }
  function _array(Class, element, params) {
      return new Class({
          type: "array",
          element,
          // get element() {
          //   return element;
          // },
          ...normalizeParams(params),
      });
  }
  function _union(Class, options, params) {
      return new Class({
          type: "union",
          options,
          ...normalizeParams(params),
      });
  }
  function _discriminatedUnion(Class, discriminator, options, params) {
      return new Class({
          type: "union",
          options,
          discriminator,
          ...normalizeParams(params),
      });
  }
  function _intersection(Class, left, right) {
      return new Class({
          type: "intersection",
          left,
          right,
      });
  }
  // export function _tuple(
  //   Class: util.SchemaClass<schemas.$ZodTuple>,
  //   items: [],
  //   params?: string | $ZodTupleParams
  // ): schemas.$ZodTuple<[], null>;
  function _tuple(Class, items, _paramsOrRest, _params) {
      const hasRest = _paramsOrRest instanceof $ZodType;
      const params = hasRest ? _params : _paramsOrRest;
      const rest = hasRest ? _paramsOrRest : null;
      return new Class({
          type: "tuple",
          items,
          rest,
          ...normalizeParams(params),
      });
  }
  function _record(Class, keyType, valueType, params) {
      return new Class({
          type: "record",
          keyType,
          valueType,
          ...normalizeParams(params),
      });
  }
  function _map(Class, keyType, valueType, params) {
      return new Class({
          type: "map",
          keyType,
          valueType,
          ...normalizeParams(params),
      });
  }
  function _set(Class, valueType, params) {
      return new Class({
          type: "set",
          valueType,
          ...normalizeParams(params),
      });
  }
  function _enum$1(Class, values, params) {
      const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
      // if (Array.isArray(values)) {
      //   for (const value of values) {
      //     entries[value] = value;
      //   }
      // } else {
      //   Object.assign(entries, values);
      // }
      // const entries: util.EnumLike = {};
      // for (const val of values) {
      //   entries[val] = val;
      // }
      return new Class({
          type: "enum",
          entries,
          ...normalizeParams(params),
      });
  }
  /** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
   *
   * ```ts
   * enum Colors { red, green, blue }
   * z.enum(Colors);
   * ```
   */
  function _nativeEnum(Class, entries, params) {
      return new Class({
          type: "enum",
          entries,
          ...normalizeParams(params),
      });
  }
  function _literal(Class, value, params) {
      return new Class({
          type: "literal",
          values: Array.isArray(value) ? value : [value],
          ...normalizeParams(params),
      });
  }
  function _file(Class, params) {
      return new Class({
          type: "file",
          ...normalizeParams(params),
      });
  }
  function _transform(Class, fn) {
      return new Class({
          type: "transform",
          transform: fn,
      });
  }
  function _optional(Class, innerType) {
      return new Class({
          type: "optional",
          innerType,
      });
  }
  function _nullable(Class, innerType) {
      return new Class({
          type: "nullable",
          innerType,
      });
  }
  function _default$1(Class, innerType, defaultValue) {
      return new Class({
          type: "default",
          innerType,
          get defaultValue() {
              return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
          },
      });
  }
  function _nonoptional(Class, innerType, params) {
      return new Class({
          type: "nonoptional",
          innerType,
          ...normalizeParams(params),
      });
  }
  function _success(Class, innerType) {
      return new Class({
          type: "success",
          innerType,
      });
  }
  function _catch$1(Class, innerType, catchValue) {
      return new Class({
          type: "catch",
          innerType,
          catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
      });
  }
  function _pipe(Class, in_, out) {
      return new Class({
          type: "pipe",
          in: in_,
          out,
      });
  }
  function _readonly(Class, innerType) {
      return new Class({
          type: "readonly",
          innerType,
      });
  }
  function _templateLiteral(Class, parts, params) {
      return new Class({
          type: "template_literal",
          parts,
          ...normalizeParams(params),
      });
  }
  function _lazy(Class, getter) {
      return new Class({
          type: "lazy",
          getter,
      });
  }
  function _promise(Class, innerType) {
      return new Class({
          type: "promise",
          innerType,
      });
  }
  function _custom(Class, fn, _params) {
      const norm = normalizeParams(_params);
      norm.abort ?? (norm.abort = true); // default to abort:false
      const schema = new Class({
          type: "custom",
          check: "custom",
          fn: fn,
          ...norm,
      });
      return schema;
  }
  // same as _custom but defaults to abort:false
  function _refine(Class, fn, _params) {
      const schema = new Class({
          type: "custom",
          check: "custom",
          fn: fn,
          ...normalizeParams(_params),
      });
      return schema;
  }
  function _superRefine(fn) {
      const ch = _check((payload) => {
          payload.addIssue = (issue$1) => {
              if (typeof issue$1 === "string") {
                  payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
              }
              else {
                  // for Zod 3 backwards compatibility
                  const _issue = issue$1;
                  if (_issue.fatal)
                      _issue.continue = false;
                  _issue.code ?? (_issue.code = "custom");
                  _issue.input ?? (_issue.input = payload.value);
                  _issue.inst ?? (_issue.inst = ch);
                  _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...
                  payload.issues.push(issue(_issue));
              }
          };
          return fn(payload.value, payload);
      });
      return ch;
  }
  function _check(fn, params) {
      const ch = new $ZodCheck({
          check: "custom",
          ...normalizeParams(params),
      });
      ch._zod.check = fn;
      return ch;
  }
  function _stringbool(Classes, _params) {
      const params = normalizeParams(_params);
      let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
      let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
      if (params.case !== "sensitive") {
          truthyArray = truthyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
          falsyArray = falsyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
      }
      const truthySet = new Set(truthyArray);
      const falsySet = new Set(falsyArray);
      const _Codec = Classes.Codec ?? $ZodCodec;
      const _Boolean = Classes.Boolean ?? $ZodBoolean;
      const _String = Classes.String ?? $ZodString;
      const stringSchema = new _String({ type: "string", error: params.error });
      const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
      const codec = new _Codec({
          type: "pipe",
          in: stringSchema,
          out: booleanSchema,
          transform: ((input, payload) => {
              let data = input;
              if (params.case !== "sensitive")
                  data = data.toLowerCase();
              if (truthySet.has(data)) {
                  return true;
              }
              else if (falsySet.has(data)) {
                  return false;
              }
              else {
                  payload.issues.push({
                      code: "invalid_value",
                      expected: "stringbool",
                      values: [...truthySet, ...falsySet],
                      input: payload.value,
                      inst: codec,
                      continue: false,
                  });
                  return {};
              }
          }),
          reverseTransform: ((input, _payload) => {
              if (input === true) {
                  return truthyArray[0] || "true";
              }
              else {
                  return falsyArray[0] || "false";
              }
          }),
          error: params.error,
      });
      return codec;
  }
  function _stringFormat(Class, format, fnOrRegex, _params = {}) {
      const params = normalizeParams(_params);
      const def = {
          ...normalizeParams(_params),
          check: "string_format",
          type: "string",
          format,
          fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
          ...params,
      };
      if (fnOrRegex instanceof RegExp) {
          def.pattern = fnOrRegex;
      }
      const inst = new Class(def);
      return inst;
  }

  class JSONSchemaGenerator {
      constructor(params) {
          this.counter = 0;
          this.metadataRegistry = params?.metadata ?? globalRegistry;
          this.target = params?.target ?? "draft-2020-12";
          this.unrepresentable = params?.unrepresentable ?? "throw";
          this.override = params?.override ?? (() => { });
          this.io = params?.io ?? "output";
          this.seen = new Map();
      }
      process(schema, _params = { path: [], schemaPath: [] }) {
          var _a;
          const def = schema._zod.def;
          const formatMap = {
              guid: "uuid",
              url: "uri",
              datetime: "date-time",
              json_string: "json-string",
              regex: "", // do not set
          };
          // check for schema in seens
          const seen = this.seen.get(schema);
          if (seen) {
              seen.count++;
              // check if cycle
              const isCycle = _params.schemaPath.includes(schema);
              if (isCycle) {
                  seen.cycle = _params.path;
              }
              return seen.schema;
          }
          // initialize
          const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
          this.seen.set(schema, result);
          // custom method overrides default behavior
          const overrideSchema = schema._zod.toJSONSchema?.();
          if (overrideSchema) {
              result.schema = overrideSchema;
          }
          else {
              const params = {
                  ..._params,
                  schemaPath: [..._params.schemaPath, schema],
                  path: _params.path,
              };
              const parent = schema._zod.parent;
              if (parent) {
                  // schema was cloned from another schema
                  result.ref = parent;
                  this.process(parent, params);
                  this.seen.get(parent).isParent = true;
              }
              else {
                  const _json = result.schema;
                  switch (def.type) {
                      case "string": {
                          const json = _json;
                          json.type = "string";
                          const { minimum, maximum, format, patterns, contentEncoding } = schema._zod
                              .bag;
                          if (typeof minimum === "number")
                              json.minLength = minimum;
                          if (typeof maximum === "number")
                              json.maxLength = maximum;
                          // custom pattern overrides format
                          if (format) {
                              json.format = formatMap[format] ?? format;
                              if (json.format === "")
                                  delete json.format; // empty format is not valid
                          }
                          if (contentEncoding)
                              json.contentEncoding = contentEncoding;
                          if (patterns && patterns.size > 0) {
                              const regexes = [...patterns];
                              if (regexes.length === 1)
                                  json.pattern = regexes[0].source;
                              else if (regexes.length > 1) {
                                  result.schema.allOf = [
                                      ...regexes.map((regex) => ({
                                          ...(this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0"
                                              ? { type: "string" }
                                              : {}),
                                          pattern: regex.source,
                                      })),
                                  ];
                              }
                          }
                          break;
                      }
                      case "number": {
                          const json = _json;
                          const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                          if (typeof format === "string" && format.includes("int"))
                              json.type = "integer";
                          else
                              json.type = "number";
                          if (typeof exclusiveMinimum === "number") {
                              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                  json.minimum = exclusiveMinimum;
                                  json.exclusiveMinimum = true;
                              }
                              else {
                                  json.exclusiveMinimum = exclusiveMinimum;
                              }
                          }
                          if (typeof minimum === "number") {
                              json.minimum = minimum;
                              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                                  if (exclusiveMinimum >= minimum)
                                      delete json.minimum;
                                  else
                                      delete json.exclusiveMinimum;
                              }
                          }
                          if (typeof exclusiveMaximum === "number") {
                              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                  json.maximum = exclusiveMaximum;
                                  json.exclusiveMaximum = true;
                              }
                              else {
                                  json.exclusiveMaximum = exclusiveMaximum;
                              }
                          }
                          if (typeof maximum === "number") {
                              json.maximum = maximum;
                              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                                  if (exclusiveMaximum <= maximum)
                                      delete json.maximum;
                                  else
                                      delete json.exclusiveMaximum;
                              }
                          }
                          if (typeof multipleOf === "number")
                              json.multipleOf = multipleOf;
                          break;
                      }
                      case "boolean": {
                          const json = _json;
                          json.type = "boolean";
                          break;
                      }
                      case "bigint": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("BigInt cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "symbol": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Symbols cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "null": {
                          if (this.target === "openapi-3.0") {
                              _json.type = "string";
                              _json.nullable = true;
                              _json.enum = [null];
                          }
                          else
                              _json.type = "null";
                          break;
                      }
                      case "any": {
                          break;
                      }
                      case "unknown": {
                          break;
                      }
                      case "undefined": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Undefined cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "void": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Void cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "never": {
                          _json.not = {};
                          break;
                      }
                      case "date": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Date cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "array": {
                          const json = _json;
                          const { minimum, maximum } = schema._zod.bag;
                          if (typeof minimum === "number")
                              json.minItems = minimum;
                          if (typeof maximum === "number")
                              json.maxItems = maximum;
                          json.type = "array";
                          json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                          break;
                      }
                      case "object": {
                          const json = _json;
                          json.type = "object";
                          json.properties = {};
                          const shape = def.shape; // params.shapeCache.get(schema)!;
                          for (const key in shape) {
                              json.properties[key] = this.process(shape[key], {
                                  ...params,
                                  path: [...params.path, "properties", key],
                              });
                          }
                          // required keys
                          const allKeys = new Set(Object.keys(shape));
                          // const optionalKeys = new Set(def.optional);
                          const requiredKeys = new Set([...allKeys].filter((key) => {
                              const v = def.shape[key]._zod;
                              if (this.io === "input") {
                                  return v.optin === undefined;
                              }
                              else {
                                  return v.optout === undefined;
                              }
                          }));
                          if (requiredKeys.size > 0) {
                              json.required = Array.from(requiredKeys);
                          }
                          // catchall
                          if (def.catchall?._zod.def.type === "never") {
                              // strict
                              json.additionalProperties = false;
                          }
                          else if (!def.catchall) {
                              // regular
                              if (this.io === "output")
                                  json.additionalProperties = false;
                          }
                          else if (def.catchall) {
                              json.additionalProperties = this.process(def.catchall, {
                                  ...params,
                                  path: [...params.path, "additionalProperties"],
                              });
                          }
                          break;
                      }
                      case "union": {
                          const json = _json;
                          const options = def.options.map((x, i) => this.process(x, {
                              ...params,
                              path: [...params.path, "anyOf", i],
                          }));
                          json.anyOf = options;
                          break;
                      }
                      case "intersection": {
                          const json = _json;
                          const a = this.process(def.left, {
                              ...params,
                              path: [...params.path, "allOf", 0],
                          });
                          const b = this.process(def.right, {
                              ...params,
                              path: [...params.path, "allOf", 1],
                          });
                          const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                          const allOf = [
                              ...(isSimpleIntersection(a) ? a.allOf : [a]),
                              ...(isSimpleIntersection(b) ? b.allOf : [b]),
                          ];
                          json.allOf = allOf;
                          break;
                      }
                      case "tuple": {
                          const json = _json;
                          json.type = "array";
                          const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
                          const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
                          const prefixItems = def.items.map((x, i) => this.process(x, {
                              ...params,
                              path: [...params.path, prefixPath, i],
                          }));
                          const rest = def.rest
                              ? this.process(def.rest, {
                                  ...params,
                                  path: [...params.path, restPath, ...(this.target === "openapi-3.0" ? [def.items.length] : [])],
                              })
                              : null;
                          if (this.target === "draft-2020-12") {
                              json.prefixItems = prefixItems;
                              if (rest) {
                                  json.items = rest;
                              }
                          }
                          else if (this.target === "openapi-3.0") {
                              json.items = {
                                  anyOf: prefixItems,
                              };
                              if (rest) {
                                  json.items.anyOf.push(rest);
                              }
                              json.minItems = prefixItems.length;
                              if (!rest) {
                                  json.maxItems = prefixItems.length;
                              }
                          }
                          else {
                              json.items = prefixItems;
                              if (rest) {
                                  json.additionalItems = rest;
                              }
                          }
                          // length
                          const { minimum, maximum } = schema._zod.bag;
                          if (typeof minimum === "number")
                              json.minItems = minimum;
                          if (typeof maximum === "number")
                              json.maxItems = maximum;
                          break;
                      }
                      case "record": {
                          const json = _json;
                          json.type = "object";
                          if (this.target === "draft-7" || this.target === "draft-2020-12") {
                              json.propertyNames = this.process(def.keyType, {
                                  ...params,
                                  path: [...params.path, "propertyNames"],
                              });
                          }
                          json.additionalProperties = this.process(def.valueType, {
                              ...params,
                              path: [...params.path, "additionalProperties"],
                          });
                          break;
                      }
                      case "map": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Map cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "set": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Set cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "enum": {
                          const json = _json;
                          const values = getEnumValues(def.entries);
                          // Number enums can have both string and number values
                          if (values.every((v) => typeof v === "number"))
                              json.type = "number";
                          if (values.every((v) => typeof v === "string"))
                              json.type = "string";
                          json.enum = values;
                          break;
                      }
                      case "literal": {
                          const json = _json;
                          const vals = [];
                          for (const val of def.values) {
                              if (val === undefined) {
                                  if (this.unrepresentable === "throw") {
                                      throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                                  }
                              }
                              else if (typeof val === "bigint") {
                                  if (this.unrepresentable === "throw") {
                                      throw new Error("BigInt literals cannot be represented in JSON Schema");
                                  }
                                  else {
                                      vals.push(Number(val));
                                  }
                              }
                              else {
                                  vals.push(val);
                              }
                          }
                          if (vals.length === 0) ;
                          else if (vals.length === 1) {
                              const val = vals[0];
                              json.type = val === null ? "null" : typeof val;
                              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                  json.enum = [val];
                              }
                              else {
                                  json.const = val;
                              }
                          }
                          else {
                              if (vals.every((v) => typeof v === "number"))
                                  json.type = "number";
                              if (vals.every((v) => typeof v === "string"))
                                  json.type = "string";
                              if (vals.every((v) => typeof v === "boolean"))
                                  json.type = "string";
                              if (vals.every((v) => v === null))
                                  json.type = "null";
                              json.enum = vals;
                          }
                          break;
                      }
                      case "file": {
                          const json = _json;
                          const file = {
                              type: "string",
                              format: "binary",
                              contentEncoding: "binary",
                          };
                          const { minimum, maximum, mime } = schema._zod.bag;
                          if (minimum !== undefined)
                              file.minLength = minimum;
                          if (maximum !== undefined)
                              file.maxLength = maximum;
                          if (mime) {
                              if (mime.length === 1) {
                                  file.contentMediaType = mime[0];
                                  Object.assign(json, file);
                              }
                              else {
                                  json.anyOf = mime.map((m) => {
                                      const mFile = { ...file, contentMediaType: m };
                                      return mFile;
                                  });
                              }
                          }
                          else {
                              Object.assign(json, file);
                          }
                          // if (this.unrepresentable === "throw") {
                          //   throw new Error("File cannot be represented in JSON Schema");
                          // }
                          break;
                      }
                      case "transform": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Transforms cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "nullable": {
                          const inner = this.process(def.innerType, params);
                          if (this.target === "openapi-3.0") {
                              result.ref = def.innerType;
                              _json.nullable = true;
                          }
                          else {
                              _json.anyOf = [inner, { type: "null" }];
                          }
                          break;
                      }
                      case "nonoptional": {
                          this.process(def.innerType, params);
                          result.ref = def.innerType;
                          break;
                      }
                      case "success": {
                          const json = _json;
                          json.type = "boolean";
                          break;
                      }
                      case "default": {
                          this.process(def.innerType, params);
                          result.ref = def.innerType;
                          _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                          break;
                      }
                      case "prefault": {
                          this.process(def.innerType, params);
                          result.ref = def.innerType;
                          if (this.io === "input")
                              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                          break;
                      }
                      case "catch": {
                          // use conditionals
                          this.process(def.innerType, params);
                          result.ref = def.innerType;
                          let catchValue;
                          try {
                              catchValue = def.catchValue(undefined);
                          }
                          catch {
                              throw new Error("Dynamic catch values are not supported in JSON Schema");
                          }
                          _json.default = catchValue;
                          break;
                      }
                      case "nan": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("NaN cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "template_literal": {
                          const json = _json;
                          const pattern = schema._zod.pattern;
                          if (!pattern)
                              throw new Error("Pattern not found in template literal");
                          json.type = "string";
                          json.pattern = pattern.source;
                          break;
                      }
                      case "pipe": {
                          const innerType = this.io === "input" ? (def.in._zod.def.type === "transform" ? def.out : def.in) : def.out;
                          this.process(innerType, params);
                          result.ref = innerType;
                          break;
                      }
                      case "readonly": {
                          this.process(def.innerType, params);
                          result.ref = def.innerType;
                          _json.readOnly = true;
                          break;
                      }
                      // passthrough types
                      case "promise": {
                          this.process(def.innerType, params);
                          result.ref = def.innerType;
                          break;
                      }
                      case "optional": {
                          this.process(def.innerType, params);
                          result.ref = def.innerType;
                          break;
                      }
                      case "lazy": {
                          const innerType = schema._zod.innerType;
                          this.process(innerType, params);
                          result.ref = innerType;
                          break;
                      }
                      case "custom": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Custom types cannot be represented in JSON Schema");
                          }
                          break;
                      }
                      case "function": {
                          if (this.unrepresentable === "throw") {
                              throw new Error("Function types cannot be represented in JSON Schema");
                          }
                          break;
                      }
                  }
              }
          }
          // metadata
          const meta = this.metadataRegistry.get(schema);
          if (meta)
              Object.assign(result.schema, meta);
          if (this.io === "input" && isTransforming(schema)) {
              // examples/defaults only apply to output type of pipe
              delete result.schema.examples;
              delete result.schema.default;
          }
          // set prefault as default
          if (this.io === "input" && result.schema._prefault)
              (_a = result.schema).default ?? (_a.default = result.schema._prefault);
          delete result.schema._prefault;
          // pulling fresh from this.seen in case it was overwritten
          const _result = this.seen.get(schema);
          return _result.schema;
      }
      emit(schema, _params) {
          const params = {
              cycles: _params?.cycles ?? "ref",
              reused: _params?.reused ?? "inline",
              // unrepresentable: _params?.unrepresentable ?? "throw",
              // uri: _params?.uri ?? ((id) => `${id}`),
              external: _params?.external ?? undefined,
          };
          // iterate over seen map;
          const root = this.seen.get(schema);
          if (!root)
              throw new Error("Unprocessed schema. This is a bug in Zod.");
          // initialize result with root schema fields
          // Object.assign(result, seen.cached);
          // returns a ref to the schema
          // defId will be empty if the ref points to an external schema (or #)
          const makeURI = (entry) => {
              // comparing the seen objects because sometimes
              // multiple schemas map to the same seen object.
              // e.g. lazy
              // external is configured
              const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
              if (params.external) {
                  const externalId = params.external.registry.get(entry[0])?.id; // ?? "__shared";// `__schema${this.counter++}`;
                  // check if schema is in the external registry
                  const uriGenerator = params.external.uri ?? ((id) => id);
                  if (externalId) {
                      return { ref: uriGenerator(externalId) };
                  }
                  // otherwise, add to __shared
                  const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
                  entry[1].defId = id; // set defId so it will be reused if needed
                  return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
              }
              if (entry[1] === root) {
                  return { ref: "#" };
              }
              // self-contained schema
              const uriPrefix = `#`;
              const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
              const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
              return { defId, ref: defUriPrefix + defId };
          };
          // stored cached version in `def` property
          // remove all properties, set $ref
          const extractToDef = (entry) => {
              // if the schema is already a reference, do not extract it
              if (entry[1].schema.$ref) {
                  return;
              }
              const seen = entry[1];
              const { ref, defId } = makeURI(entry);
              seen.def = { ...seen.schema };
              // defId won't be set if the schema is a reference to an external schema
              if (defId)
                  seen.defId = defId;
              // wipe away all properties except $ref
              const schema = seen.schema;
              for (const key in schema) {
                  delete schema[key];
              }
              schema.$ref = ref;
          };
          // throw on cycles
          // break cycles
          if (params.cycles === "throw") {
              for (const entry of this.seen.entries()) {
                  const seen = entry[1];
                  if (seen.cycle) {
                      throw new Error("Cycle detected: " +
                          `#/${seen.cycle?.join("/")}/<root>` +
                          '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
                  }
              }
          }
          // extract schemas into $defs
          for (const entry of this.seen.entries()) {
              const seen = entry[1];
              // convert root schema to # $ref
              if (schema === entry[0]) {
                  extractToDef(entry); // this has special handling for the root schema
                  continue;
              }
              // extract schemas that are in the external registry
              if (params.external) {
                  const ext = params.external.registry.get(entry[0])?.id;
                  if (schema !== entry[0] && ext) {
                      extractToDef(entry);
                      continue;
                  }
              }
              // extract schemas with `id` meta
              const id = this.metadataRegistry.get(entry[0])?.id;
              if (id) {
                  extractToDef(entry);
                  continue;
              }
              // break cycles
              if (seen.cycle) {
                  // any
                  extractToDef(entry);
                  continue;
              }
              // extract reused schemas
              if (seen.count > 1) {
                  if (params.reused === "ref") {
                      extractToDef(entry);
                      // biome-ignore lint:
                      continue;
                  }
              }
          }
          // flatten _refs
          const flattenRef = (zodSchema, params) => {
              const seen = this.seen.get(zodSchema);
              const schema = seen.def ?? seen.schema;
              const _cached = { ...schema };
              // already seen
              if (seen.ref === null) {
                  return;
              }
              // flatten ref if defined
              const ref = seen.ref;
              seen.ref = null; // prevent recursion
              if (ref) {
                  flattenRef(ref, params);
                  // merge referenced schema into current
                  const refSchema = this.seen.get(ref).schema;
                  if (refSchema.$ref &&
                      (params.target === "draft-7" || params.target === "draft-4" || params.target === "openapi-3.0")) {
                      schema.allOf = schema.allOf ?? [];
                      schema.allOf.push(refSchema);
                  }
                  else {
                      Object.assign(schema, refSchema);
                      Object.assign(schema, _cached); // prevent overwriting any fields in the original schema
                  }
              }
              // execute overrides
              if (!seen.isParent)
                  this.override({
                      zodSchema: zodSchema,
                      jsonSchema: schema,
                      path: seen.path ?? [],
                  });
          };
          for (const entry of [...this.seen.entries()].reverse()) {
              flattenRef(entry[0], { target: this.target });
          }
          const result = {};
          if (this.target === "draft-2020-12") {
              result.$schema = "https://json-schema.org/draft/2020-12/schema";
          }
          else if (this.target === "draft-7") {
              result.$schema = "http://json-schema.org/draft-07/schema#";
          }
          else if (this.target === "draft-4") {
              result.$schema = "http://json-schema.org/draft-04/schema#";
          }
          else if (this.target === "openapi-3.0") ;
          else {
              // @ts-ignore
              console.warn(`Invalid target: ${this.target}`);
          }
          if (params.external?.uri) {
              const id = params.external.registry.get(schema)?.id;
              if (!id)
                  throw new Error("Schema is missing an `id` property");
              result.$id = params.external.uri(id);
          }
          Object.assign(result, root.def);
          // build defs object
          const defs = params.external?.defs ?? {};
          for (const entry of this.seen.entries()) {
              const seen = entry[1];
              if (seen.def && seen.defId) {
                  defs[seen.defId] = seen.def;
              }
          }
          // set definitions in result
          if (params.external) ;
          else {
              if (Object.keys(defs).length > 0) {
                  if (this.target === "draft-2020-12") {
                      result.$defs = defs;
                  }
                  else {
                      result.definitions = defs;
                  }
              }
          }
          try {
              // this "finalizes" this schema and ensures all cycles are removed
              // each call to .emit() is functionally independent
              // though the seen map is shared
              return JSON.parse(JSON.stringify(result));
          }
          catch (_err) {
              throw new Error("Error converting schema to JSON.");
          }
      }
  }
  function toJSONSchema(input, _params) {
      if (input instanceof $ZodRegistry) {
          const gen = new JSONSchemaGenerator(_params);
          const defs = {};
          for (const entry of input._idmap.entries()) {
              const [_, schema] = entry;
              gen.process(schema);
          }
          const schemas = {};
          const external = {
              registry: input,
              uri: _params?.uri,
              defs,
          };
          for (const entry of input._idmap.entries()) {
              const [key, schema] = entry;
              schemas[key] = gen.emit(schema, {
                  ..._params,
                  external,
              });
          }
          if (Object.keys(defs).length > 0) {
              const defsSegment = gen.target === "draft-2020-12" ? "$defs" : "definitions";
              schemas.__shared = {
                  [defsSegment]: defs,
              };
          }
          return { schemas };
      }
      const gen = new JSONSchemaGenerator(_params);
      gen.process(input);
      return gen.emit(input, _params);
  }
  function isTransforming(_schema, _ctx) {
      const ctx = _ctx ?? { seen: new Set() };
      if (ctx.seen.has(_schema))
          return false;
      ctx.seen.add(_schema);
      const schema = _schema;
      const def = schema._zod.def;
      switch (def.type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean":
          case "date":
          case "symbol":
          case "undefined":
          case "null":
          case "any":
          case "unknown":
          case "never":
          case "void":
          case "literal":
          case "enum":
          case "nan":
          case "file":
          case "template_literal":
              return false;
          case "array": {
              return isTransforming(def.element, ctx);
          }
          case "object": {
              for (const key in def.shape) {
                  if (isTransforming(def.shape[key], ctx))
                      return true;
              }
              return false;
          }
          case "union": {
              for (const option of def.options) {
                  if (isTransforming(option, ctx))
                      return true;
              }
              return false;
          }
          case "intersection": {
              return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
          }
          case "tuple": {
              for (const item of def.items) {
                  if (isTransforming(item, ctx))
                      return true;
              }
              if (def.rest && isTransforming(def.rest, ctx))
                  return true;
              return false;
          }
          case "record": {
              return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
          }
          case "map": {
              return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
          }
          case "set": {
              return isTransforming(def.valueType, ctx);
          }
          // inner types
          case "promise":
          case "optional":
          case "nonoptional":
          case "nullable":
          case "readonly":
              return isTransforming(def.innerType, ctx);
          case "lazy":
              return isTransforming(def.getter(), ctx);
          case "default": {
              return isTransforming(def.innerType, ctx);
          }
          case "prefault": {
              return isTransforming(def.innerType, ctx);
          }
          case "custom": {
              return false;
          }
          case "transform": {
              return true;
          }
          case "pipe": {
              return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
          }
          case "success": {
              return false;
          }
          case "catch": {
              return false;
          }
          case "function": {
              return false;
          }
      }
      throw new Error(`Unknown schema type: ${def.type}`);
  }

  var jsonSchema$1 = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    $ZodAny: $ZodAny,
    $ZodArray: $ZodArray,
    $ZodAsyncError: $ZodAsyncError,
    $ZodBase64: $ZodBase64,
    $ZodBase64URL: $ZodBase64URL,
    $ZodBigInt: $ZodBigInt,
    $ZodBigIntFormat: $ZodBigIntFormat,
    $ZodBoolean: $ZodBoolean,
    $ZodCIDRv4: $ZodCIDRv4,
    $ZodCIDRv6: $ZodCIDRv6,
    $ZodCUID: $ZodCUID,
    $ZodCUID2: $ZodCUID2,
    $ZodCatch: $ZodCatch,
    $ZodCheck: $ZodCheck,
    $ZodCheckBigIntFormat: $ZodCheckBigIntFormat,
    $ZodCheckEndsWith: $ZodCheckEndsWith,
    $ZodCheckGreaterThan: $ZodCheckGreaterThan,
    $ZodCheckIncludes: $ZodCheckIncludes,
    $ZodCheckLengthEquals: $ZodCheckLengthEquals,
    $ZodCheckLessThan: $ZodCheckLessThan,
    $ZodCheckLowerCase: $ZodCheckLowerCase,
    $ZodCheckMaxLength: $ZodCheckMaxLength,
    $ZodCheckMaxSize: $ZodCheckMaxSize,
    $ZodCheckMimeType: $ZodCheckMimeType,
    $ZodCheckMinLength: $ZodCheckMinLength,
    $ZodCheckMinSize: $ZodCheckMinSize,
    $ZodCheckMultipleOf: $ZodCheckMultipleOf,
    $ZodCheckNumberFormat: $ZodCheckNumberFormat,
    $ZodCheckOverwrite: $ZodCheckOverwrite,
    $ZodCheckProperty: $ZodCheckProperty,
    $ZodCheckRegex: $ZodCheckRegex,
    $ZodCheckSizeEquals: $ZodCheckSizeEquals,
    $ZodCheckStartsWith: $ZodCheckStartsWith,
    $ZodCheckStringFormat: $ZodCheckStringFormat,
    $ZodCheckUpperCase: $ZodCheckUpperCase,
    $ZodCodec: $ZodCodec,
    $ZodCustom: $ZodCustom,
    $ZodCustomStringFormat: $ZodCustomStringFormat,
    $ZodDate: $ZodDate,
    $ZodDefault: $ZodDefault,
    $ZodDiscriminatedUnion: $ZodDiscriminatedUnion,
    $ZodE164: $ZodE164,
    $ZodEmail: $ZodEmail,
    $ZodEmoji: $ZodEmoji,
    $ZodEncodeError: $ZodEncodeError,
    $ZodEnum: $ZodEnum,
    $ZodError: $ZodError,
    $ZodFile: $ZodFile,
    $ZodFunction: $ZodFunction,
    $ZodGUID: $ZodGUID,
    $ZodIPv4: $ZodIPv4,
    $ZodIPv6: $ZodIPv6,
    $ZodISODate: $ZodISODate,
    $ZodISODateTime: $ZodISODateTime,
    $ZodISODuration: $ZodISODuration,
    $ZodISOTime: $ZodISOTime,
    $ZodIntersection: $ZodIntersection,
    $ZodJWT: $ZodJWT,
    $ZodKSUID: $ZodKSUID,
    $ZodLazy: $ZodLazy,
    $ZodLiteral: $ZodLiteral,
    $ZodMap: $ZodMap,
    $ZodNaN: $ZodNaN,
    $ZodNanoID: $ZodNanoID,
    $ZodNever: $ZodNever,
    $ZodNonOptional: $ZodNonOptional,
    $ZodNull: $ZodNull,
    $ZodNullable: $ZodNullable,
    $ZodNumber: $ZodNumber,
    $ZodNumberFormat: $ZodNumberFormat,
    $ZodObject: $ZodObject,
    $ZodObjectJIT: $ZodObjectJIT,
    $ZodOptional: $ZodOptional,
    $ZodPipe: $ZodPipe,
    $ZodPrefault: $ZodPrefault,
    $ZodPromise: $ZodPromise,
    $ZodReadonly: $ZodReadonly,
    $ZodRealError: $ZodRealError,
    $ZodRecord: $ZodRecord,
    $ZodRegistry: $ZodRegistry,
    $ZodSet: $ZodSet,
    $ZodString: $ZodString,
    $ZodStringFormat: $ZodStringFormat,
    $ZodSuccess: $ZodSuccess,
    $ZodSymbol: $ZodSymbol,
    $ZodTemplateLiteral: $ZodTemplateLiteral,
    $ZodTransform: $ZodTransform,
    $ZodTuple: $ZodTuple,
    $ZodType: $ZodType,
    $ZodULID: $ZodULID,
    $ZodURL: $ZodURL,
    $ZodUUID: $ZodUUID,
    $ZodUndefined: $ZodUndefined,
    $ZodUnion: $ZodUnion,
    $ZodUnknown: $ZodUnknown,
    $ZodVoid: $ZodVoid,
    $ZodXID: $ZodXID,
    $brand: $brand,
    $constructor: $constructor,
    $input: $input,
    $output: $output,
    Doc: Doc,
    JSONSchema: jsonSchema$1,
    JSONSchemaGenerator: JSONSchemaGenerator,
    NEVER: NEVER,
    TimePrecision: TimePrecision,
    _any: _any,
    _array: _array,
    _base64: _base64,
    _base64url: _base64url,
    _bigint: _bigint,
    _boolean: _boolean,
    _catch: _catch$1,
    _check: _check,
    _cidrv4: _cidrv4,
    _cidrv6: _cidrv6,
    _coercedBigint: _coercedBigint,
    _coercedBoolean: _coercedBoolean,
    _coercedDate: _coercedDate,
    _coercedNumber: _coercedNumber,
    _coercedString: _coercedString,
    _cuid: _cuid,
    _cuid2: _cuid2,
    _custom: _custom,
    _date: _date,
    _decode: _decode,
    _decodeAsync: _decodeAsync,
    _default: _default$1,
    _discriminatedUnion: _discriminatedUnion,
    _e164: _e164,
    _email: _email,
    _emoji: _emoji,
    _encode: _encode,
    _encodeAsync: _encodeAsync,
    _endsWith: _endsWith,
    _enum: _enum$1,
    _file: _file,
    _float32: _float32,
    _float64: _float64,
    _gt: _gt,
    _gte: _gte,
    _guid: _guid,
    _includes: _includes,
    _int: _int,
    _int32: _int32,
    _int64: _int64,
    _intersection: _intersection,
    _ipv4: _ipv4,
    _ipv6: _ipv6,
    _isoDate: _isoDate,
    _isoDateTime: _isoDateTime,
    _isoDuration: _isoDuration,
    _isoTime: _isoTime,
    _jwt: _jwt,
    _ksuid: _ksuid,
    _lazy: _lazy,
    _length: _length,
    _literal: _literal,
    _lowercase: _lowercase,
    _lt: _lt,
    _lte: _lte,
    _map: _map,
    _max: _lte,
    _maxLength: _maxLength,
    _maxSize: _maxSize,
    _mime: _mime,
    _min: _gte,
    _minLength: _minLength,
    _minSize: _minSize,
    _multipleOf: _multipleOf,
    _nan: _nan,
    _nanoid: _nanoid,
    _nativeEnum: _nativeEnum,
    _negative: _negative,
    _never: _never,
    _nonnegative: _nonnegative,
    _nonoptional: _nonoptional,
    _nonpositive: _nonpositive,
    _normalize: _normalize,
    _null: _null$1,
    _nullable: _nullable,
    _number: _number,
    _optional: _optional,
    _overwrite: _overwrite,
    _parse: _parse$1,
    _parseAsync: _parseAsync,
    _pipe: _pipe,
    _positive: _positive,
    _promise: _promise,
    _property: _property,
    _readonly: _readonly,
    _record: _record,
    _refine: _refine,
    _regex: _regex,
    _safeDecode: _safeDecode,
    _safeDecodeAsync: _safeDecodeAsync,
    _safeEncode: _safeEncode,
    _safeEncodeAsync: _safeEncodeAsync,
    _safeParse: _safeParse,
    _safeParseAsync: _safeParseAsync,
    _set: _set,
    _size: _size,
    _startsWith: _startsWith,
    _string: _string,
    _stringFormat: _stringFormat,
    _stringbool: _stringbool,
    _success: _success,
    _superRefine: _superRefine,
    _symbol: _symbol,
    _templateLiteral: _templateLiteral,
    _toLowerCase: _toLowerCase,
    _toUpperCase: _toUpperCase,
    _transform: _transform,
    _trim: _trim,
    _tuple: _tuple,
    _uint32: _uint32,
    _uint64: _uint64,
    _ulid: _ulid,
    _undefined: _undefined$1,
    _union: _union,
    _unknown: _unknown,
    _uppercase: _uppercase,
    _url: _url,
    _uuid: _uuid,
    _uuidv4: _uuidv4,
    _uuidv6: _uuidv6,
    _uuidv7: _uuidv7,
    _void: _void$1,
    _xid: _xid,
    clone: clone,
    config: config,
    decode: decode$1,
    decodeAsync: decodeAsync$1,
    encode: encode$1,
    encodeAsync: encodeAsync$1,
    flattenError: flattenError,
    formatError: formatError,
    globalConfig: globalConfig,
    globalRegistry: globalRegistry,
    isValidBase64: isValidBase64,
    isValidBase64URL: isValidBase64URL,
    isValidJWT: isValidJWT,
    locales: index$1,
    parse: parse$1,
    parseAsync: parseAsync$1,
    prettifyError: prettifyError,
    regexes: regexes,
    registry: registry,
    safeDecode: safeDecode$1,
    safeDecodeAsync: safeDecodeAsync$1,
    safeEncode: safeEncode$1,
    safeEncodeAsync: safeEncodeAsync$1,
    safeParse: safeParse$1,
    safeParseAsync: safeParseAsync$1,
    toDotPath: toDotPath,
    toJSONSchema: toJSONSchema,
    treeifyError: treeifyError,
    util: util,
    version: version
  });

  const ZodISODateTime = /*@__PURE__*/ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function datetime(params) {
      return _isoDateTime(ZodISODateTime, params);
  }
  const ZodISODate = /*@__PURE__*/ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function date$2(params) {
      return _isoDate(ZodISODate, params);
  }
  const ZodISOTime = /*@__PURE__*/ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function time(params) {
      return _isoTime(ZodISOTime, params);
  }
  const ZodISODuration = /*@__PURE__*/ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function duration(params) {
      return _isoDuration(ZodISODuration, params);
  }

  var iso = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ZodISODate: ZodISODate,
    ZodISODateTime: ZodISODateTime,
    ZodISODuration: ZodISODuration,
    ZodISOTime: ZodISOTime,
    date: date$2,
    datetime: datetime,
    duration: duration,
    time: time
  });

  const initializer = (inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
          format: {
              value: (mapper) => formatError(inst, mapper),
              // enumerable: false,
          },
          flatten: {
              value: (mapper) => flattenError(inst, mapper),
              // enumerable: false,
          },
          addIssue: {
              value: (issue) => {
                  inst.issues.push(issue);
                  inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
              },
              // enumerable: false,
          },
          addIssues: {
              value: (issues) => {
                  inst.issues.push(...issues);
                  inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
              },
              // enumerable: false,
          },
          isEmpty: {
              get() {
                  return inst.issues.length === 0;
              },
              // enumerable: false,
          },
      });
      // Object.defineProperty(inst, "isEmpty", {
      //   get() {
      //     return inst.issues.length === 0;
      //   },
      // });
  };
  const ZodError = $constructor("ZodError", initializer);
  const ZodRealError = $constructor("ZodError", initializer, {
      Parent: Error,
  });
  // /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */
  // export type ErrorMapCtx = core.$ZodErrorMapCtx;

  const parse = /* @__PURE__ */ _parse$1(ZodRealError);
  const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
  const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
  const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  // Codec functions
  const encode = /* @__PURE__ */ _encode(ZodRealError);
  const decode = /* @__PURE__ */ _decode(ZodRealError);
  const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
  const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
  const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
  const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
  const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
  const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

  const ZodType = /*@__PURE__*/ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      inst.def = def;
      inst.type = def.type;
      Object.defineProperty(inst, "_def", { value: def });
      // base methods
      inst.check = (...checks) => {
          return inst.clone({
              ...def,
              checks: [
                  ...(def.checks ?? []),
                  ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch),
              ],
          }
          // { parent: true }
          );
      };
      inst.clone = (def, params) => clone(inst, def, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta) => {
          reg.add(inst, meta);
          return inst;
      });
      // parsing
      inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
      inst.spa = inst.safeParseAsync;
      // encoding/decoding
      inst.encode = (data, params) => encode(inst, data, params);
      inst.decode = (data, params) => decode(inst, data, params);
      inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
      inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
      inst.safeEncode = (data, params) => safeEncode(inst, data, params);
      inst.safeDecode = (data, params) => safeDecode(inst, data, params);
      inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
      inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
      // refinements
      inst.refine = (check, params) => inst.check(refine(check, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      // wrappers
      inst.optional = () => optional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def) => _default(inst, def);
      inst.prefault = (def) => prefault(inst, def);
      // inst.coalesce = (def, params) => coalesce(inst, def, params);
      inst.catch = (params) => _catch(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      // meta
      inst.describe = (description) => {
          const cl = inst.clone();
          globalRegistry.add(cl, { description });
          return cl;
      };
      Object.defineProperty(inst, "description", {
          get() {
              return globalRegistry.get(inst)?.description;
          },
          configurable: true,
      });
      inst.meta = (...args) => {
          if (args.length === 0) {
              return globalRegistry.get(inst);
          }
          const cl = inst.clone();
          globalRegistry.add(cl, args[0]);
          return cl;
      };
      // helpers
      inst.isOptional = () => inst.safeParse(undefined).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
  });
  /** @internal */
  const _ZodString = /*@__PURE__*/ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      // validations
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (...args) => inst.check(_startsWith(...args));
      inst.endsWith = (...args) => inst.check(_endsWith(...args));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      // transforms
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
  });
  const ZodString = /*@__PURE__*/ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      // iso
      inst.datetime = (params) => inst.check(datetime(params));
      inst.date = (params) => inst.check(date$2(params));
      inst.time = (params) => inst.check(time(params));
      inst.duration = (params) => inst.check(duration(params));
  });
  function string$1(params) {
      return _string(ZodString, params);
  }
  const ZodStringFormat = /*@__PURE__*/ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
  });
  const ZodEmail = /*@__PURE__*/ $constructor("ZodEmail", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function email(params) {
      return _email(ZodEmail, params);
  }
  const ZodGUID = /*@__PURE__*/ $constructor("ZodGUID", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function guid(params) {
      return _guid(ZodGUID, params);
  }
  const ZodUUID = /*@__PURE__*/ $constructor("ZodUUID", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function uuid(params) {
      return _uuid(ZodUUID, params);
  }
  function uuidv4(params) {
      return _uuidv4(ZodUUID, params);
  }
  // ZodUUIDv6
  function uuidv6(params) {
      return _uuidv6(ZodUUID, params);
  }
  // ZodUUIDv7
  function uuidv7(params) {
      return _uuidv7(ZodUUID, params);
  }
  const ZodURL = /*@__PURE__*/ $constructor("ZodURL", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function url(params) {
      return _url(ZodURL, params);
  }
  function httpUrl(params) {
      return _url(ZodURL, {
          protocol: /^https?$/,
          hostname: domain,
          ...normalizeParams(params),
      });
  }
  const ZodEmoji = /*@__PURE__*/ $constructor("ZodEmoji", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function emoji(params) {
      return _emoji(ZodEmoji, params);
  }
  const ZodNanoID = /*@__PURE__*/ $constructor("ZodNanoID", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function nanoid(params) {
      return _nanoid(ZodNanoID, params);
  }
  const ZodCUID = /*@__PURE__*/ $constructor("ZodCUID", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function cuid(params) {
      return _cuid(ZodCUID, params);
  }
  const ZodCUID2 = /*@__PURE__*/ $constructor("ZodCUID2", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function cuid2(params) {
      return _cuid2(ZodCUID2, params);
  }
  const ZodULID = /*@__PURE__*/ $constructor("ZodULID", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function ulid(params) {
      return _ulid(ZodULID, params);
  }
  const ZodXID = /*@__PURE__*/ $constructor("ZodXID", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function xid(params) {
      return _xid(ZodXID, params);
  }
  const ZodKSUID = /*@__PURE__*/ $constructor("ZodKSUID", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function ksuid(params) {
      return _ksuid(ZodKSUID, params);
  }
  const ZodIPv4 = /*@__PURE__*/ $constructor("ZodIPv4", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function ipv4(params) {
      return _ipv4(ZodIPv4, params);
  }
  const ZodIPv6 = /*@__PURE__*/ $constructor("ZodIPv6", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function ipv6(params) {
      return _ipv6(ZodIPv6, params);
  }
  const ZodCIDRv4 = /*@__PURE__*/ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function cidrv4(params) {
      return _cidrv4(ZodCIDRv4, params);
  }
  const ZodCIDRv6 = /*@__PURE__*/ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function cidrv6(params) {
      return _cidrv6(ZodCIDRv6, params);
  }
  const ZodBase64 = /*@__PURE__*/ $constructor("ZodBase64", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function base64(params) {
      return _base64(ZodBase64, params);
  }
  const ZodBase64URL = /*@__PURE__*/ $constructor("ZodBase64URL", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function base64url(params) {
      return _base64url(ZodBase64URL, params);
  }
  const ZodE164 = /*@__PURE__*/ $constructor("ZodE164", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function e164(params) {
      return _e164(ZodE164, params);
  }
  const ZodJWT = /*@__PURE__*/ $constructor("ZodJWT", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function jwt(params) {
      return _jwt(ZodJWT, params);
  }
  const ZodCustomStringFormat = /*@__PURE__*/ $constructor("ZodCustomStringFormat", (inst, def) => {
      // ZodStringFormat.init(inst, def);
      $ZodCustomStringFormat.init(inst, def);
      ZodStringFormat.init(inst, def);
  });
  function stringFormat(format, fnOrRegex, _params = {}) {
      return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
  }
  function hostname(_params) {
      return _stringFormat(ZodCustomStringFormat, "hostname", hostname$1, _params);
  }
  function hex(_params) {
      return _stringFormat(ZodCustomStringFormat, "hex", hex$1, _params);
  }
  function hash(alg, params) {
      const enc = params?.enc ?? "hex";
      const format = `${alg}_${enc}`;
      const regex = regexes[format];
      if (!regex)
          throw new Error(`Unrecognized hash format: ${format}`);
      return _stringFormat(ZodCustomStringFormat, format, regex, params);
  }
  const ZodNumber = /*@__PURE__*/ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType.init(inst, def);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      // inst.finite = (params) => inst.check(core.finite(params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue =
          Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue =
          Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
  });
  function number$1(params) {
      return _number(ZodNumber, params);
  }
  const ZodNumberFormat = /*@__PURE__*/ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber.init(inst, def);
  });
  function int(params) {
      return _int(ZodNumberFormat, params);
  }
  function float32(params) {
      return _float32(ZodNumberFormat, params);
  }
  function float64(params) {
      return _float64(ZodNumberFormat, params);
  }
  function int32(params) {
      return _int32(ZodNumberFormat, params);
  }
  function uint32(params) {
      return _uint32(ZodNumberFormat, params);
  }
  const ZodBoolean = /*@__PURE__*/ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType.init(inst, def);
  });
  function boolean$1(params) {
      return _boolean(ZodBoolean, params);
  }
  const ZodBigInt = /*@__PURE__*/ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType.init(inst, def);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
  });
  function bigint$1(params) {
      return _bigint(ZodBigInt, params);
  }
  const ZodBigIntFormat = /*@__PURE__*/ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt.init(inst, def);
  });
  // int64
  function int64(params) {
      return _int64(ZodBigIntFormat, params);
  }
  // uint64
  function uint64(params) {
      return _uint64(ZodBigIntFormat, params);
  }
  const ZodSymbol = /*@__PURE__*/ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType.init(inst, def);
  });
  function symbol$3(params) {
      return _symbol(ZodSymbol, params);
  }
  const ZodUndefined = /*@__PURE__*/ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType.init(inst, def);
  });
  function _undefined(params) {
      return _undefined$1(ZodUndefined, params);
  }
  const ZodNull = /*@__PURE__*/ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType.init(inst, def);
  });
  function _null(params) {
      return _null$1(ZodNull, params);
  }
  const ZodAny = /*@__PURE__*/ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType.init(inst, def);
  });
  function any() {
      return _any(ZodAny);
  }
  const ZodUnknown = /*@__PURE__*/ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType.init(inst, def);
  });
  function unknown() {
      return _unknown(ZodUnknown);
  }
  const ZodNever = /*@__PURE__*/ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType.init(inst, def);
  });
  function never(params) {
      return _never(ZodNever, params);
  }
  const ZodVoid = /*@__PURE__*/ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType.init(inst, def);
  });
  function _void(params) {
      return _void$1(ZodVoid, params);
  }
  const ZodDate = /*@__PURE__*/ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
  function date$1(params) {
      return _date(ZodDate, params);
  }
  const ZodArray = /*@__PURE__*/ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
      inst.unwrap = () => inst.element;
  });
  function array(element, params) {
      return _array(ZodArray, element, params);
  }
  // .keyof
  function keyof(schema) {
      const shape = schema._zod.def.shape;
      return _enum(Object.keys(shape));
  }
  const ZodObject = /*@__PURE__*/ $constructor("ZodObject", (inst, def) => {
      $ZodObjectJIT.init(inst, def);
      ZodType.init(inst, def);
      defineLazy(inst, "shape", () => def.shape);
      inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
      inst.extend = (incoming) => {
          return extend(inst, incoming);
      };
      inst.safeExtend = (incoming) => {
          return safeExtend(inst, incoming);
      };
      inst.merge = (other) => merge(inst, other);
      inst.pick = (mask) => pick(inst, mask);
      inst.omit = (mask) => omit(inst, mask);
      inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
      inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
  });
  function object$1(shape, params) {
      const def = {
          type: "object",
          get shape() {
              assignProp(this, "shape", shape ? objectClone(shape) : {});
              return this.shape;
          },
          ...normalizeParams(params),
      };
      return new ZodObject(def);
  }
  // strictObject
  function strictObject(shape, params) {
      return new ZodObject({
          type: "object",
          get shape() {
              assignProp(this, "shape", objectClone(shape));
              return this.shape;
          },
          catchall: never(),
          ...normalizeParams(params),
      });
  }
  // looseObject
  function looseObject(shape, params) {
      return new ZodObject({
          type: "object",
          get shape() {
              assignProp(this, "shape", objectClone(shape));
              return this.shape;
          },
          catchall: unknown(),
          ...normalizeParams(params),
      });
  }
  const ZodUnion = /*@__PURE__*/ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType.init(inst, def);
      inst.options = def.options;
  });
  function union(options, params) {
      return new ZodUnion({
          type: "union",
          options: options,
          ...normalizeParams(params),
      });
  }
  const ZodDiscriminatedUnion = /*@__PURE__*/ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
  });
  function discriminatedUnion(discriminator, options, params) {
      // const [options, params] = args;
      return new ZodDiscriminatedUnion({
          type: "union",
          options,
          discriminator,
          ...normalizeParams(params),
      });
  }
  const ZodIntersection = /*@__PURE__*/ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType.init(inst, def);
  });
  function intersection(left, right) {
      return new ZodIntersection({
          type: "intersection",
          left: left,
          right: right,
      });
  }
  const ZodTuple = /*@__PURE__*/ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType.init(inst, def);
      inst.rest = (rest) => inst.clone({
          ...inst._zod.def,
          rest: rest,
      });
  });
  function tuple(items, _paramsOrRest, _params) {
      const hasRest = _paramsOrRest instanceof $ZodType;
      const params = hasRest ? _params : _paramsOrRest;
      const rest = hasRest ? _paramsOrRest : null;
      return new ZodTuple({
          type: "tuple",
          items: items,
          rest,
          ...normalizeParams(params),
      });
  }
  const ZodRecord = /*@__PURE__*/ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
  });
  function record(keyType, valueType, params) {
      return new ZodRecord({
          type: "record",
          keyType,
          valueType: valueType,
          ...normalizeParams(params),
      });
  }
  // type alksjf = core.output<core.$ZodRecordKey>;
  function partialRecord(keyType, valueType, params) {
      const k = clone(keyType);
      k._zod.values = undefined;
      return new ZodRecord({
          type: "record",
          keyType: k,
          valueType: valueType,
          ...normalizeParams(params),
      });
  }
  const ZodMap = /*@__PURE__*/ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
  });
  function map(keyType, valueType, params) {
      return new ZodMap({
          type: "map",
          keyType: keyType,
          valueType: valueType,
          ...normalizeParams(params),
      });
  }
  const ZodSet = /*@__PURE__*/ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
  });
  function set(valueType, params) {
      return new ZodSet({
          type: "set",
          valueType: valueType,
          ...normalizeParams(params),
      });
  }
  const ZodEnum = /*@__PURE__*/ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
          const newEntries = {};
          for (const value of values) {
              if (keys.has(value)) {
                  newEntries[value] = def.entries[value];
              }
              else
                  throw new Error(`Key ${value} not found in enum`);
          }
          return new ZodEnum({
              ...def,
              checks: [],
              ...normalizeParams(params),
              entries: newEntries,
          });
      };
      inst.exclude = (values, params) => {
          const newEntries = { ...def.entries };
          for (const value of values) {
              if (keys.has(value)) {
                  delete newEntries[value];
              }
              else
                  throw new Error(`Key ${value} not found in enum`);
          }
          return new ZodEnum({
              ...def,
              checks: [],
              ...normalizeParams(params),
              entries: newEntries,
          });
      };
  });
  function _enum(values, params) {
      const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
      return new ZodEnum({
          type: "enum",
          entries,
          ...normalizeParams(params),
      });
  }
  /** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
   *
   * ```ts
   * enum Colors { red, green, blue }
   * z.enum(Colors);
   * ```
   */
  function nativeEnum(entries, params) {
      return new ZodEnum({
          type: "enum",
          entries,
          ...normalizeParams(params),
      });
  }
  const ZodLiteral = /*@__PURE__*/ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
          get() {
              if (def.values.length > 1) {
                  throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
              }
              return def.values[0];
          },
      });
  });
  function literal(value, params) {
      return new ZodLiteral({
          type: "literal",
          values: Array.isArray(value) ? value : [value],
          ...normalizeParams(params),
      });
  }
  const ZodFile = /*@__PURE__*/ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
  });
  function file(params) {
      return _file(ZodFile, params);
  }
  const ZodTransform = /*@__PURE__*/ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
          if (_ctx.direction === "backward") {
              throw new $ZodEncodeError(inst.constructor.name);
          }
          payload.addIssue = (issue$1) => {
              if (typeof issue$1 === "string") {
                  payload.issues.push(issue(issue$1, payload.value, def));
              }
              else {
                  // for Zod 3 backwards compatibility
                  const _issue = issue$1;
                  if (_issue.fatal)
                      _issue.continue = false;
                  _issue.code ?? (_issue.code = "custom");
                  _issue.input ?? (_issue.input = payload.value);
                  _issue.inst ?? (_issue.inst = inst);
                  // _issue.continue ??= true;
                  payload.issues.push(issue(_issue));
              }
          };
          const output = def.transform(payload.value, payload);
          if (output instanceof Promise) {
              return output.then((output) => {
                  payload.value = output;
                  return payload;
              });
          }
          payload.value = output;
          return payload;
      };
  });
  function transform(fn) {
      return new ZodTransform({
          type: "transform",
          transform: fn,
      });
  }
  const ZodOptional = /*@__PURE__*/ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
  });
  function optional(innerType) {
      return new ZodOptional({
          type: "optional",
          innerType: innerType,
      });
  }
  const ZodNullable = /*@__PURE__*/ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
  });
  function nullable(innerType) {
      return new ZodNullable({
          type: "nullable",
          innerType: innerType,
      });
  }
  // nullish
  function nullish(innerType) {
      return optional(nullable(innerType));
  }
  const ZodDefault = /*@__PURE__*/ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
  });
  function _default(innerType, defaultValue) {
      return new ZodDefault({
          type: "default",
          innerType: innerType,
          get defaultValue() {
              return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
          },
      });
  }
  const ZodPrefault = /*@__PURE__*/ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
  });
  function prefault(innerType, defaultValue) {
      return new ZodPrefault({
          type: "prefault",
          innerType: innerType,
          get defaultValue() {
              return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
          },
      });
  }
  const ZodNonOptional = /*@__PURE__*/ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
  });
  function nonoptional(innerType, params) {
      return new ZodNonOptional({
          type: "nonoptional",
          innerType: innerType,
          ...normalizeParams(params),
      });
  }
  const ZodSuccess = /*@__PURE__*/ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
  });
  function success(innerType) {
      return new ZodSuccess({
          type: "success",
          innerType: innerType,
      });
  }
  const ZodCatch = /*@__PURE__*/ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
  });
  function _catch(innerType, catchValue) {
      return new ZodCatch({
          type: "catch",
          innerType: innerType,
          catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
      });
  }
  const ZodNaN = /*@__PURE__*/ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType.init(inst, def);
  });
  function nan(params) {
      return _nan(ZodNaN, params);
  }
  const ZodPipe = /*@__PURE__*/ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
  });
  function pipe(in_, out) {
      return new ZodPipe({
          type: "pipe",
          in: in_,
          out: out,
          // ...util.normalizeParams(params),
      });
  }
  const ZodCodec = /*@__PURE__*/ $constructor("ZodCodec", (inst, def) => {
      ZodPipe.init(inst, def);
      $ZodCodec.init(inst, def);
  });
  function codec(in_, out, params) {
      return new ZodCodec({
          type: "pipe",
          in: in_,
          out: out,
          transform: params.decode,
          reverseTransform: params.encode,
      });
  }
  const ZodReadonly = /*@__PURE__*/ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
  });
  function readonly(innerType) {
      return new ZodReadonly({
          type: "readonly",
          innerType: innerType,
      });
  }
  const ZodTemplateLiteral = /*@__PURE__*/ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType.init(inst, def);
  });
  function templateLiteral(parts, params) {
      return new ZodTemplateLiteral({
          type: "template_literal",
          parts,
          ...normalizeParams(params),
      });
  }
  const ZodLazy = /*@__PURE__*/ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
  });
  function lazy(getter) {
      return new ZodLazy({
          type: "lazy",
          getter: getter,
      });
  }
  const ZodPromise = /*@__PURE__*/ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
  });
  function promise(innerType) {
      return new ZodPromise({
          type: "promise",
          innerType: innerType,
      });
  }
  const ZodFunction = /*@__PURE__*/ $constructor("ZodFunction", (inst, def) => {
      $ZodFunction.init(inst, def);
      ZodType.init(inst, def);
  });
  function _function(params) {
      return new ZodFunction({
          type: "function",
          input: Array.isArray(params?.input) ? tuple(params?.input) : (params?.input ?? array(unknown())),
          output: params?.output ?? unknown(),
      });
  }
  const ZodCustom = /*@__PURE__*/ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType.init(inst, def);
  });
  // custom checks
  function check(fn) {
      const ch = new $ZodCheck({
          check: "custom",
          // ...util.normalizeParams(params),
      });
      ch._zod.check = fn;
      return ch;
  }
  function custom(fn, _params) {
      return _custom(ZodCustom, fn ?? (() => true), _params);
  }
  function refine(fn, _params = {}) {
      return _refine(ZodCustom, fn, _params);
  }
  // superRefine
  function superRefine(fn) {
      return _superRefine(fn);
  }
  function _instanceof(cls, params = {
      error: `Input not instance of ${cls.name}`,
  }) {
      const inst = new ZodCustom({
          type: "custom",
          check: "custom",
          fn: (data) => data instanceof cls,
          abort: true,
          ...normalizeParams(params),
      });
      inst._zod.bag.Class = cls;
      return inst;
  }
  // stringbool
  const stringbool = (...args) => _stringbool({
      Codec: ZodCodec,
      Boolean: ZodBoolean,
      String: ZodString,
  }, ...args);
  function json(params) {
      const jsonSchema = lazy(() => {
          return union([string$1(params), number$1(), boolean$1(), _null(), array(jsonSchema), record(string$1(), jsonSchema)]);
      });
      return jsonSchema;
  }
  // preprocess
  // /** @deprecated Use `z.pipe()` and `z.transform()` instead. */
  function preprocess(fn, schema) {
      return pipe(transform(fn), schema);
  }

  // Zod 3 compat layer
  /** @deprecated Use the raw string literal codes instead, e.g. "invalid_type". */
  const ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom",
  };
  /** @deprecated Use `z.config(params)` instead. */
  function setErrorMap(map) {
      config({
          customError: map,
      });
  }
  /** @deprecated Use `z.config()` instead. */
  function getErrorMap() {
      return config().customError;
  }
  /** @deprecated Do not use. Stub definition, only included for zod-to-json-schema compatibility. */
  var ZodFirstPartyTypeKind$1;
  (function (ZodFirstPartyTypeKind) {
  })(ZodFirstPartyTypeKind$1 || (ZodFirstPartyTypeKind$1 = {}));

  function string(params) {
      return _coercedString(ZodString, params);
  }
  function number(params) {
      return _coercedNumber(ZodNumber, params);
  }
  function boolean(params) {
      return _coercedBoolean(ZodBoolean, params);
  }
  function bigint(params) {
      return _coercedBigint(ZodBigInt, params);
  }
  function date(params) {
      return _coercedDate(ZodDate, params);
  }

  var coerce = /*#__PURE__*/Object.freeze({
    __proto__: null,
    bigint: bigint,
    boolean: boolean,
    date: date,
    number: number,
    string: string
  });

  config(en());

  var z = /*#__PURE__*/Object.freeze({
    __proto__: null,
    $brand: $brand,
    $input: $input,
    $output: $output,
    NEVER: NEVER,
    TimePrecision: TimePrecision,
    ZodAny: ZodAny,
    ZodArray: ZodArray,
    ZodBase64: ZodBase64,
    ZodBase64URL: ZodBase64URL,
    ZodBigInt: ZodBigInt,
    ZodBigIntFormat: ZodBigIntFormat,
    ZodBoolean: ZodBoolean,
    ZodCIDRv4: ZodCIDRv4,
    ZodCIDRv6: ZodCIDRv6,
    ZodCUID: ZodCUID,
    ZodCUID2: ZodCUID2,
    ZodCatch: ZodCatch,
    ZodCodec: ZodCodec,
    ZodCustom: ZodCustom,
    ZodCustomStringFormat: ZodCustomStringFormat,
    ZodDate: ZodDate,
    ZodDefault: ZodDefault,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodE164: ZodE164,
    ZodEmail: ZodEmail,
    ZodEmoji: ZodEmoji,
    ZodEnum: ZodEnum,
    ZodError: ZodError,
    ZodFile: ZodFile,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind$1; },
    ZodFunction: ZodFunction,
    ZodGUID: ZodGUID,
    ZodIPv4: ZodIPv4,
    ZodIPv6: ZodIPv6,
    ZodISODate: ZodISODate,
    ZodISODateTime: ZodISODateTime,
    ZodISODuration: ZodISODuration,
    ZodISOTime: ZodISOTime,
    ZodIntersection: ZodIntersection,
    ZodIssueCode: ZodIssueCode,
    ZodJWT: ZodJWT,
    ZodKSUID: ZodKSUID,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodMap: ZodMap,
    ZodNaN: ZodNaN,
    ZodNanoID: ZodNanoID,
    ZodNever: ZodNever,
    ZodNonOptional: ZodNonOptional,
    ZodNull: ZodNull,
    ZodNullable: ZodNullable,
    ZodNumber: ZodNumber,
    ZodNumberFormat: ZodNumberFormat,
    ZodObject: ZodObject,
    ZodOptional: ZodOptional,
    ZodPipe: ZodPipe,
    ZodPrefault: ZodPrefault,
    ZodPromise: ZodPromise,
    ZodReadonly: ZodReadonly,
    ZodRealError: ZodRealError,
    ZodRecord: ZodRecord,
    ZodSet: ZodSet,
    ZodString: ZodString,
    ZodStringFormat: ZodStringFormat,
    ZodSuccess: ZodSuccess,
    ZodSymbol: ZodSymbol,
    ZodTemplateLiteral: ZodTemplateLiteral,
    ZodTransform: ZodTransform,
    ZodTuple: ZodTuple,
    ZodType: ZodType,
    ZodULID: ZodULID,
    ZodURL: ZodURL,
    ZodUUID: ZodUUID,
    ZodUndefined: ZodUndefined,
    ZodUnion: ZodUnion,
    ZodUnknown: ZodUnknown,
    ZodVoid: ZodVoid,
    ZodXID: ZodXID,
    _ZodString: _ZodString,
    _default: _default,
    _function: _function,
    any: any,
    array: array,
    base64: base64,
    base64url: base64url,
    bigint: bigint$1,
    boolean: boolean$1,
    catch: _catch,
    check: check,
    cidrv4: cidrv4,
    cidrv6: cidrv6,
    clone: clone,
    codec: codec,
    coerce: coerce,
    config: config,
    core: index,
    cuid: cuid,
    cuid2: cuid2,
    custom: custom,
    date: date$1,
    decode: decode,
    decodeAsync: decodeAsync,
    discriminatedUnion: discriminatedUnion,
    e164: e164,
    email: email,
    emoji: emoji,
    encode: encode,
    encodeAsync: encodeAsync,
    endsWith: _endsWith,
    enum: _enum,
    file: file,
    flattenError: flattenError,
    float32: float32,
    float64: float64,
    formatError: formatError,
    function: _function,
    getErrorMap: getErrorMap,
    globalRegistry: globalRegistry,
    gt: _gt,
    gte: _gte,
    guid: guid,
    hash: hash,
    hex: hex,
    hostname: hostname,
    httpUrl: httpUrl,
    includes: _includes,
    instanceof: _instanceof,
    int: int,
    int32: int32,
    int64: int64,
    intersection: intersection,
    ipv4: ipv4,
    ipv6: ipv6,
    iso: iso,
    json: json,
    jwt: jwt,
    keyof: keyof,
    ksuid: ksuid,
    lazy: lazy,
    length: _length,
    literal: literal,
    locales: index$1,
    looseObject: looseObject,
    lowercase: _lowercase,
    lt: _lt,
    lte: _lte,
    map: map,
    maxLength: _maxLength,
    maxSize: _maxSize,
    mime: _mime,
    minLength: _minLength,
    minSize: _minSize,
    multipleOf: _multipleOf,
    nan: nan,
    nanoid: nanoid,
    nativeEnum: nativeEnum,
    negative: _negative,
    never: never,
    nonnegative: _nonnegative,
    nonoptional: nonoptional,
    nonpositive: _nonpositive,
    normalize: _normalize,
    null: _null,
    nullable: nullable,
    nullish: nullish,
    number: number$1,
    object: object$1,
    optional: optional,
    overwrite: _overwrite,
    parse: parse,
    parseAsync: parseAsync,
    partialRecord: partialRecord,
    pipe: pipe,
    positive: _positive,
    prefault: prefault,
    preprocess: preprocess,
    prettifyError: prettifyError,
    promise: promise,
    property: _property,
    readonly: readonly,
    record: record,
    refine: refine,
    regex: _regex,
    regexes: regexes,
    registry: registry,
    safeDecode: safeDecode,
    safeDecodeAsync: safeDecodeAsync,
    safeEncode: safeEncode,
    safeEncodeAsync: safeEncodeAsync,
    safeParse: safeParse,
    safeParseAsync: safeParseAsync,
    set: set,
    setErrorMap: setErrorMap,
    size: _size,
    startsWith: _startsWith,
    strictObject: strictObject,
    string: string$1,
    stringFormat: stringFormat,
    stringbool: stringbool,
    success: success,
    superRefine: superRefine,
    symbol: symbol$3,
    templateLiteral: templateLiteral,
    toJSONSchema: toJSONSchema,
    toLowerCase: _toLowerCase,
    toUpperCase: _toUpperCase,
    transform: transform,
    treeifyError: treeifyError,
    trim: _trim,
    tuple: tuple,
    uint32: uint32,
    uint64: uint64,
    ulid: ulid,
    undefined: _undefined,
    union: union,
    unknown: unknown,
    uppercase: _uppercase,
    url: url,
    util: util,
    uuid: uuid,
    uuidv4: uuidv4,
    uuidv6: uuidv6,
    uuidv7: uuidv7,
    void: _void,
    xid: xid
  });

  var ZodFirstPartyTypeKind;
  (function (ZodFirstPartyTypeKind) {
      ZodFirstPartyTypeKind["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

  // src/combine-headers.ts
  function combineHeaders$1(...headers) {
    return headers.reduce(
      (combinedHeaders, currentHeaders) => ({
        ...combinedHeaders,
        ...currentHeaders != null ? currentHeaders : {}
      }),
      {}
    );
  }

  // src/delay.ts
  async function delay(delayInMs, options) {
    if (delayInMs == null) {
      return Promise.resolve();
    }
    const signal = options == null ? void 0 : options.abortSignal;
    return new Promise((resolve2, reject) => {
      if (signal == null ? void 0 : signal.aborted) {
        reject(createAbortError());
        return;
      }
      const timeoutId = setTimeout(() => {
        cleanup();
        resolve2();
      }, delayInMs);
      const cleanup = () => {
        clearTimeout(timeoutId);
        signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
      };
      const onAbort = () => {
        cleanup();
        reject(createAbortError());
      };
      signal == null ? void 0 : signal.addEventListener("abort", onAbort);
    });
  }
  function createAbortError() {
    return new DOMException("Delay was aborted", "AbortError");
  }

  // src/extract-response-headers.ts
  function extractResponseHeaders$1(response) {
    return Object.fromEntries([...response.headers]);
  }
  var createIdGenerator$1 = ({
    prefix,
    size = 16,
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    separator = "-"
  } = {}) => {
    const generator = () => {
      const alphabetLength = alphabet.length;
      const chars = new Array(size);
      for (let i = 0; i < size; i++) {
        chars[i] = alphabet[Math.random() * alphabetLength | 0];
      }
      return chars.join("");
    };
    if (prefix == null) {
      return generator;
    }
    if (alphabet.includes(separator)) {
      throw new InvalidArgumentError$2({
        argument: "separator",
        message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
      });
    }
    return () => `${prefix}${separator}${generator()}`;
  };
  var generateId$1 = createIdGenerator$1();

  // src/get-error-message.ts
  function getErrorMessage$1(error) {
    if (error == null) {
      return "unknown error";
    }
    if (typeof error === "string") {
      return error;
    }
    if (error instanceof Error) {
      return error.message;
    }
    return JSON.stringify(error);
  }

  // src/is-abort-error.ts
  function isAbortError$1(error) {
    return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
    error.name === "TimeoutError");
  }

  // src/handle-fetch-error.ts
  var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
  function handleFetchError({
    error,
    url,
    requestBodyValues
  }) {
    if (isAbortError$1(error)) {
      return error;
    }
    if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
      const cause = error.cause;
      if (cause != null) {
        return new APICallError$1({
          message: `Cannot connect to API: ${cause.message}`,
          cause,
          url,
          requestBodyValues,
          isRetryable: true
          // retry when network error
        });
      }
    }
    return error;
  }

  // src/remove-undefined-entries.ts
  function removeUndefinedEntries$1(record) {
    return Object.fromEntries(
      Object.entries(record).filter(([_key, value]) => value != null)
    );
  }

  // src/get-from-api.ts
  var getOriginalFetch = () => globalThis.fetch;
  var getFromApi = async ({
    url,
    headers = {},
    successfulResponseHandler,
    failedResponseHandler,
    abortSignal,
    fetch = getOriginalFetch()
  }) => {
    try {
      const response = await fetch(url, {
        method: "GET",
        headers: removeUndefinedEntries$1(headers),
        signal: abortSignal
      });
      const responseHeaders = extractResponseHeaders$1(response);
      if (!response.ok) {
        let errorInformation;
        try {
          errorInformation = await failedResponseHandler({
            response,
            url,
            requestBodyValues: {}
          });
        } catch (error) {
          if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
            throw error;
          }
          throw new APICallError$1({
            message: "Failed to process error response",
            cause: error,
            statusCode: response.status,
            url,
            responseHeaders,
            requestBodyValues: {}
          });
        }
        throw errorInformation.value;
      }
      try {
        return await successfulResponseHandler({
          response,
          url,
          requestBodyValues: {}
        });
      } catch (error) {
        if (error instanceof Error) {
          if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
            throw error;
          }
        }
        throw new APICallError$1({
          message: "Failed to process successful response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: {}
        });
      }
    } catch (error) {
      throw handleFetchError({ error, url, requestBodyValues: {} });
    }
  };

  // src/inject-json-instruction.ts
  var DEFAULT_SCHEMA_PREFIX = "JSON schema:";
  var DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.";
  var DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
  function injectJsonInstruction({
    prompt,
    schema,
    schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,
    schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX
  }) {
    return [
      prompt != null && prompt.length > 0 ? prompt : void 0,
      prompt != null && prompt.length > 0 ? "" : void 0,
      // add a newline if prompt is not null
      schemaPrefix,
      schema != null ? JSON.stringify(schema) : void 0,
      schemaSuffix
    ].filter((line) => line != null).join("\n");
  }
  function injectJsonInstructionIntoMessages({
    messages,
    schema,
    schemaPrefix,
    schemaSuffix
  }) {
    var _a, _b;
    const systemMessage = ((_a = messages[0]) == null ? void 0 : _a.role) === "system" ? { ...messages[0] } : { role: "system", content: "" };
    systemMessage.content = injectJsonInstruction({
      prompt: systemMessage.content,
      schema,
      schemaPrefix,
      schemaSuffix
    });
    return [
      systemMessage,
      ...((_b = messages[0]) == null ? void 0 : _b.role) === "system" ? messages.slice(1) : messages
    ];
  }

  // src/is-url-supported.ts
  function isUrlSupported({
    mediaType,
    url,
    supportedUrls
  }) {
    url = url.toLowerCase();
    mediaType = mediaType.toLowerCase();
    return Object.entries(supportedUrls).map(([key, value]) => {
      const mediaType2 = key.toLowerCase();
      return mediaType2 === "*" || mediaType2 === "*/*" ? { mediaTypePrefix: "", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\*/, ""), regexes: value };
    }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url));
  }
  function loadApiKey({
    apiKey,
    environmentVariableName,
    apiKeyParameterName = "apiKey",
    description
  }) {
    if (typeof apiKey === "string") {
      return apiKey;
    }
    if (apiKey != null) {
      throw new LoadAPIKeyError({
        message: `${description} API key must be a string.`
      });
    }
    if (typeof process === "undefined") {
      throw new LoadAPIKeyError({
        message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
      });
    }
    apiKey = process.env[environmentVariableName];
    if (apiKey == null) {
      throw new LoadAPIKeyError({
        message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
      });
    }
    if (typeof apiKey !== "string") {
      throw new LoadAPIKeyError({
        message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
      });
    }
    return apiKey;
  }

  // src/load-optional-setting.ts
  function loadOptionalSetting({
    settingValue,
    environmentVariableName
  }) {
    if (typeof settingValue === "string") {
      return settingValue;
    }
    if (settingValue != null || typeof process === "undefined") {
      return void 0;
    }
    settingValue = process.env[environmentVariableName];
    if (settingValue == null || typeof settingValue !== "string") {
      return void 0;
    }
    return settingValue;
  }

  // src/media-type-to-extension.ts
  function mediaTypeToExtension(mediaType) {
    var _a;
    const [_type, subtype = ""] = mediaType.toLowerCase().split("/");
    return (_a = {
      mpeg: "mp3",
      "x-wav": "wav",
      opus: "ogg",
      mp4: "m4a",
      "x-m4a": "m4a"
    }[subtype]) != null ? _a : subtype;
  }

  // src/secure-json-parse.ts
  var suspectProtoRx = /"__proto__"\s*:/;
  var suspectConstructorRx = /"constructor"\s*:/;
  function _parse(text) {
    const obj = JSON.parse(text);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
      return obj;
    }
    return filter(obj);
  }
  function filter(obj) {
    let next = [obj];
    while (next.length) {
      const nodes = next;
      next = [];
      for (const node of nodes) {
        if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
          throw new SyntaxError("Object contains forbidden prototype property");
        }
        if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
          throw new SyntaxError("Object contains forbidden prototype property");
        }
        for (const key in node) {
          const value = node[key];
          if (value && typeof value === "object") {
            next.push(value);
          }
        }
      }
    }
    return obj;
  }
  function secureJsonParse$1(text) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  var validatorSymbol$1 = Symbol.for("vercel.ai.validator");
  function validator$1(validate) {
    return { [validatorSymbol$1]: true, validate };
  }
  function isValidator$1(value) {
    return typeof value === "object" && value !== null && validatorSymbol$1 in value && value[validatorSymbol$1] === true && "validate" in value;
  }
  function asValidator$1(value) {
    return isValidator$1(value) ? value : standardSchemaValidator(value);
  }
  function standardSchemaValidator(standardSchema) {
    return validator$1(async (value) => {
      const result = await standardSchema["~standard"].validate(value);
      return result.issues == null ? { success: true, value: result.value } : {
        success: false,
        error: new TypeValidationError$1({
          value,
          cause: result.issues
        })
      };
    });
  }

  // src/validate-types.ts
  async function validateTypes$1({
    value,
    schema
  }) {
    const result = await safeValidateTypes$1({ value, schema });
    if (!result.success) {
      throw TypeValidationError$1.wrap({ value, cause: result.error });
    }
    return result.value;
  }
  async function safeValidateTypes$1({
    value,
    schema
  }) {
    const validator2 = asValidator$1(schema);
    try {
      if (validator2.validate == null) {
        return { success: true, value, rawValue: value };
      }
      const result = await validator2.validate(value);
      if (result.success) {
        return { success: true, value: result.value, rawValue: value };
      }
      return {
        success: false,
        error: TypeValidationError$1.wrap({ value, cause: result.error }),
        rawValue: value
      };
    } catch (error) {
      return {
        success: false,
        error: TypeValidationError$1.wrap({ value, cause: error }),
        rawValue: value
      };
    }
  }

  // src/parse-json.ts
  async function parseJSON$1({
    text,
    schema
  }) {
    try {
      const value = secureJsonParse$1(text);
      if (schema == null) {
        return value;
      }
      return validateTypes$1({ value, schema });
    } catch (error) {
      if (JSONParseError$1.isInstance(error) || TypeValidationError$1.isInstance(error)) {
        throw error;
      }
      throw new JSONParseError$1({ text, cause: error });
    }
  }
  async function safeParseJSON$1({
    text,
    schema
  }) {
    try {
      const value = secureJsonParse$1(text);
      if (schema == null) {
        return { success: true, value, rawValue: value };
      }
      return await safeValidateTypes$1({ value, schema });
    } catch (error) {
      return {
        success: false,
        error: JSONParseError$1.isInstance(error) ? error : new JSONParseError$1({ text, cause: error }),
        rawValue: void 0
      };
    }
  }
  function isParsableJson(input) {
    try {
      secureJsonParse$1(input);
      return true;
    } catch (e) {
      return false;
    }
  }
  function parseJsonEventStream({
    stream,
    schema
  }) {
    return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
      new TransformStream({
        async transform({ data }, controller) {
          if (data === "[DONE]") {
            return;
          }
          controller.enqueue(await safeParseJSON$1({ text: data, schema }));
        }
      })
    );
  }
  async function parseProviderOptions({
    provider,
    providerOptions,
    schema
  }) {
    if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
      return void 0;
    }
    const parsedProviderOptions = await safeValidateTypes$1({
      value: providerOptions[provider],
      schema
    });
    if (!parsedProviderOptions.success) {
      throw new InvalidArgumentError$2({
        argument: "providerOptions",
        message: `invalid ${provider} provider options`,
        cause: parsedProviderOptions.error
      });
    }
    return parsedProviderOptions.value;
  }
  var getOriginalFetch2$1 = () => globalThis.fetch;
  var postJsonToApi$1 = async ({
    url,
    headers,
    body,
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch
  }) => postToApi$1({
    url,
    headers: {
      "Content-Type": "application/json",
      ...headers
    },
    body: {
      content: JSON.stringify(body),
      values: body
    },
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch
  });
  var postFormDataToApi = async ({
    url,
    headers,
    formData,
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch
  }) => postToApi$1({
    url,
    headers,
    body: {
      content: formData,
      values: Object.fromEntries(formData.entries())
    },
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch
  });
  var postToApi$1 = async ({
    url,
    headers = {},
    body,
    successfulResponseHandler,
    failedResponseHandler,
    abortSignal,
    fetch = getOriginalFetch2$1()
  }) => {
    try {
      const response = await fetch(url, {
        method: "POST",
        headers: removeUndefinedEntries$1(headers),
        body: body.content,
        signal: abortSignal
      });
      const responseHeaders = extractResponseHeaders$1(response);
      if (!response.ok) {
        let errorInformation;
        try {
          errorInformation = await failedResponseHandler({
            response,
            url,
            requestBodyValues: body.values
          });
        } catch (error) {
          if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
            throw error;
          }
          throw new APICallError$1({
            message: "Failed to process error response",
            cause: error,
            statusCode: response.status,
            url,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
        throw errorInformation.value;
      }
      try {
        return await successfulResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (error instanceof Error) {
          if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
            throw error;
          }
        }
        throw new APICallError$1({
          message: "Failed to process successful response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
    } catch (error) {
      throw handleFetchError({ error, url, requestBodyValues: body.values });
    }
  };

  // src/types/tool.ts
  function tool(tool2) {
    return tool2;
  }

  // src/provider-defined-tool-factory.ts
  function createProviderDefinedToolFactory({
    id,
    name,
    inputSchema
  }) {
    return ({
      execute,
      outputSchema,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable,
      ...args
    }) => tool({
      type: "provider-defined",
      id,
      name,
      args,
      inputSchema,
      outputSchema,
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    });
  }
  function createProviderDefinedToolFactoryWithOutputSchema({
    id,
    name,
    inputSchema,
    outputSchema
  }) {
    return ({
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable,
      ...args
    }) => tool({
      type: "provider-defined",
      id,
      name,
      args,
      inputSchema,
      outputSchema,
      execute,
      toModelOutput,
      onInputStart,
      onInputDelta,
      onInputAvailable
    });
  }

  // src/resolve.ts
  async function resolve(value) {
    if (typeof value === "function") {
      value = value();
    }
    return Promise.resolve(value);
  }
  var createJsonErrorResponseHandler$1 = ({
    errorSchema,
    errorToMessage,
    isRetryable
  }) => async ({ response, url, requestBodyValues }) => {
    const responseBody = await response.text();
    const responseHeaders = extractResponseHeaders$1(response);
    if (responseBody.trim() === "") {
      return {
        responseHeaders,
        value: new APICallError$1({
          message: response.statusText,
          url,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response)
        })
      };
    }
    try {
      const parsedError = await parseJSON$1({
        text: responseBody,
        schema: errorSchema
      });
      return {
        responseHeaders,
        value: new APICallError$1({
          message: errorToMessage(parsedError),
          url,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          data: parsedError,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
        })
      };
    } catch (parseError) {
      return {
        responseHeaders,
        value: new APICallError$1({
          message: response.statusText,
          url,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response)
        })
      };
    }
  };
  var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
    const responseHeaders = extractResponseHeaders$1(response);
    if (response.body == null) {
      throw new EmptyResponseBodyError$1({});
    }
    return {
      responseHeaders,
      value: parseJsonEventStream({
        stream: response.body,
        schema: chunkSchema
      })
    };
  };
  var createJsonResponseHandler$1 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
    const responseBody = await response.text();
    const parsedResult = await safeParseJSON$1({
      text: responseBody,
      schema: responseSchema
    });
    const responseHeaders = extractResponseHeaders$1(response);
    if (!parsedResult.success) {
      throw new APICallError$1({
        message: "Invalid JSON response",
        cause: parsedResult.error,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        url,
        requestBodyValues
      });
    }
    return {
      responseHeaders,
      value: parsedResult.value,
      rawValue: parsedResult.rawValue
    };
  };
  var createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {
    const responseHeaders = extractResponseHeaders$1(response);
    if (!response.body) {
      throw new APICallError$1({
        message: "Response body is empty",
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody: void 0
      });
    }
    try {
      const buffer = await response.arrayBuffer();
      return {
        responseHeaders,
        value: new Uint8Array(buffer)
      };
    } catch (error) {
      throw new APICallError$1({
        message: "Failed to read response as array buffer",
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody: void 0,
        cause: error
      });
    }
  };

  // src/zod-to-json-schema/get-relative-path.ts
  var getRelativePath = (pathA, pathB) => {
    let i = 0;
    for (; i < pathA.length && i < pathB.length; i++) {
      if (pathA[i] !== pathB[i])
        break;
    }
    return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
  };

  // src/zod-to-json-schema/options.ts
  var ignoreOverride = Symbol(
    "Let zodToJsonSchema decide on which parser to use"
  );
  var defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
  var getDefaultOptions = (options) => typeof options === "string" ? {
    ...defaultOptions,
    name: options
  } : {
    ...defaultOptions,
    ...options
  };

  // src/zod-to-json-schema/parsers/any.ts
  function parseAnyDef() {
    return {};
  }
  function parseArrayDef(def, refs) {
    var _a, _b, _c;
    const res = {
      type: "array"
    };
    if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
      res.items = parseDef(def.type._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"]
      });
    }
    if (def.minLength) {
      res.minItems = def.minLength.value;
    }
    if (def.maxLength) {
      res.maxItems = def.maxLength.value;
    }
    if (def.exactLength) {
      res.minItems = def.exactLength.value;
      res.maxItems = def.exactLength.value;
    }
    return res;
  }

  // src/zod-to-json-schema/parsers/bigint.ts
  function parseBigintDef(def) {
    const res = {
      type: "integer",
      format: "int64"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          if (check.inclusive) {
            res.minimum = check.value;
          } else {
            res.exclusiveMinimum = check.value;
          }
          break;
        case "max":
          if (check.inclusive) {
            res.maximum = check.value;
          } else {
            res.exclusiveMaximum = check.value;
          }
          break;
        case "multipleOf":
          res.multipleOf = check.value;
          break;
      }
    }
    return res;
  }

  // src/zod-to-json-schema/parsers/boolean.ts
  function parseBooleanDef() {
    return { type: "boolean" };
  }

  // src/zod-to-json-schema/parsers/branded.ts
  function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
  }

  // src/zod-to-json-schema/parsers/catch.ts
  var parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };

  // src/zod-to-json-schema/parsers/date.ts
  function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
    if (Array.isArray(strategy)) {
      return {
        anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
      };
    }
    switch (strategy) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return integerDateParser(def);
    }
  }
  var integerDateParser = (def) => {
    const res = {
      type: "integer",
      format: "unix-time"
    };
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minimum = check.value;
          break;
        case "max":
          res.maximum = check.value;
          break;
      }
    }
    return res;
  };

  // src/zod-to-json-schema/parsers/default.ts
  function parseDefaultDef(_def, refs) {
    return {
      ...parseDef(_def.innerType._def, refs),
      default: _def.defaultValue()
    };
  }

  // src/zod-to-json-schema/parsers/effects.ts
  function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
  }

  // src/zod-to-json-schema/parsers/enum.ts
  function parseEnumDef(def) {
    return {
      type: "string",
      enum: Array.from(def.values)
    };
  }

  // src/zod-to-json-schema/parsers/intersection.ts
  var isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string")
      return false;
    return "allOf" in type;
  };
  function parseIntersectionDef(def, refs) {
    const allOf = [
      parseDef(def.left._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"]
      }),
      parseDef(def.right._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "1"]
      })
    ].filter((x) => !!x);
    const mergedAllOf = [];
    allOf.forEach((schema) => {
      if (isJsonSchema7AllOfType(schema)) {
        mergedAllOf.push(...schema.allOf);
      } else {
        let nestedSchema = schema;
        if ("additionalProperties" in schema && schema.additionalProperties === false) {
          const { additionalProperties, ...rest } = schema;
          nestedSchema = rest;
        }
        mergedAllOf.push(nestedSchema);
      }
    });
    return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
  }

  // src/zod-to-json-schema/parsers/literal.ts
  function parseLiteralDef(def) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
      return {
        type: Array.isArray(def.value) ? "array" : "object"
      };
    }
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      const: def.value
    };
  }

  // src/zod-to-json-schema/parsers/string.ts
  var emojiRegex = void 0;
  var zodPatterns = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
      if (emojiRegex === void 0) {
        emojiRegex = RegExp(
          "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
          "u"
        );
      }
      return emojiRegex;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  };
  function parseStringDef(def, refs) {
    const res = {
      type: "string"
    };
    if (def.checks) {
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
            break;
          case "max":
            res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat(res, "email", check.message, refs);
                break;
              case "format:idn-email":
                addFormat(res, "idn-email", check.message, refs);
                break;
              case "pattern:zod":
                addPattern(res, zodPatterns.email, check.message, refs);
                break;
            }
            break;
          case "url":
            addFormat(res, "uri", check.message, refs);
            break;
          case "uuid":
            addFormat(res, "uuid", check.message, refs);
            break;
          case "regex":
            addPattern(res, check.regex, check.message, refs);
            break;
          case "cuid":
            addPattern(res, zodPatterns.cuid, check.message, refs);
            break;
          case "cuid2":
            addPattern(res, zodPatterns.cuid2, check.message, refs);
            break;
          case "startsWith":
            addPattern(
              res,
              RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),
              check.message,
              refs
            );
            break;
          case "endsWith":
            addPattern(
              res,
              RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),
              check.message,
              refs
            );
            break;
          case "datetime":
            addFormat(res, "date-time", check.message, refs);
            break;
          case "date":
            addFormat(res, "date", check.message, refs);
            break;
          case "time":
            addFormat(res, "time", check.message, refs);
            break;
          case "duration":
            addFormat(res, "duration", check.message, refs);
            break;
          case "length":
            res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
            res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
            break;
          case "includes": {
            addPattern(
              res,
              RegExp(escapeLiteralCheckValue(check.value, refs)),
              check.message,
              refs
            );
            break;
          }
          case "ip": {
            if (check.version !== "v6") {
              addFormat(res, "ipv4", check.message, refs);
            }
            if (check.version !== "v4") {
              addFormat(res, "ipv6", check.message, refs);
            }
            break;
          }
          case "base64url":
            addPattern(res, zodPatterns.base64url, check.message, refs);
            break;
          case "jwt":
            addPattern(res, zodPatterns.jwt, check.message, refs);
            break;
          case "cidr": {
            if (check.version !== "v6") {
              addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
            }
            if (check.version !== "v4") {
              addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
            }
            break;
          }
          case "emoji":
            addPattern(res, zodPatterns.emoji(), check.message, refs);
            break;
          case "ulid": {
            addPattern(res, zodPatterns.ulid, check.message, refs);
            break;
          }
          case "base64": {
            switch (refs.base64Strategy) {
              case "format:binary": {
                addFormat(res, "binary", check.message, refs);
                break;
              }
              case "contentEncoding:base64": {
                res.contentEncoding = "base64";
                break;
              }
              case "pattern:zod": {
                addPattern(res, zodPatterns.base64, check.message, refs);
                break;
              }
            }
            break;
          }
          case "nanoid": {
            addPattern(res, zodPatterns.nanoid, check.message, refs);
          }
        }
      }
    }
    return res;
  }
  function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
  }
  var ALPHA_NUMERIC = new Set(
    "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
  );
  function escapeNonAlphaNumeric(source) {
    let result = "";
    for (let i = 0; i < source.length; i++) {
      if (!ALPHA_NUMERIC.has(source[i])) {
        result += "\\";
      }
      result += source[i];
    }
    return result;
  }
  function addFormat(schema, value, message, refs) {
    var _a;
    if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
      if (!schema.anyOf) {
        schema.anyOf = [];
      }
      if (schema.format) {
        schema.anyOf.push({
          format: schema.format
        });
        delete schema.format;
      }
      schema.anyOf.push({
        format: value,
        ...message && refs.errorMessages && { errorMessage: { format: message } }
      });
    } else {
      schema.format = value;
    }
  }
  function addPattern(schema, regex, message, refs) {
    var _a;
    if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
      if (!schema.allOf) {
        schema.allOf = [];
      }
      if (schema.pattern) {
        schema.allOf.push({
          pattern: schema.pattern
        });
        delete schema.pattern;
      }
      schema.allOf.push({
        pattern: stringifyRegExpWithFlags(regex, refs),
        ...message && refs.errorMessages && { errorMessage: { pattern: message } }
      });
    } else {
      schema.pattern = stringifyRegExpWithFlags(regex, refs);
    }
  }
  function stringifyRegExpWithFlags(regex, refs) {
    var _a;
    if (!refs.applyRegexFlags || !regex.flags) {
      return regex.source;
    }
    const flags = {
      i: regex.flags.includes("i"),
      // Case-insensitive
      m: regex.flags.includes("m"),
      // `^` and `$` matches adjacent to newline characters
      s: regex.flags.includes("s")
      // `.` matches newlines
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i = 0; i < source.length; i++) {
      if (isEscaped) {
        pattern += source[i];
        isEscaped = false;
        continue;
      }
      if (flags.i) {
        if (inCharGroup) {
          if (source[i].match(/[a-z]/)) {
            if (inCharRange) {
              pattern += source[i];
              pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
              inCharRange = false;
            } else if (source[i + 1] === "-" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
              pattern += source[i];
              inCharRange = true;
            } else {
              pattern += `${source[i]}${source[i].toUpperCase()}`;
            }
            continue;
          }
        } else if (source[i].match(/[a-z]/)) {
          pattern += `[${source[i]}${source[i].toUpperCase()}]`;
          continue;
        }
      }
      if (flags.m) {
        if (source[i] === "^") {
          pattern += `(^|(?<=[\r
]))`;
          continue;
        } else if (source[i] === "$") {
          pattern += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (flags.s && source[i] === ".") {
        pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
        continue;
      }
      pattern += source[i];
      if (source[i] === "\\") {
        isEscaped = true;
      } else if (inCharGroup && source[i] === "]") {
        inCharGroup = false;
      } else if (!inCharGroup && source[i] === "[") {
        inCharGroup = true;
      }
    }
    try {
      new RegExp(pattern);
    } catch (e) {
      console.warn(
        `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
      );
      return regex.source;
    }
    return pattern;
  }

  // src/zod-to-json-schema/parsers/record.ts
  function parseRecordDef(def, refs) {
    var _a, _b, _c, _d, _e, _f;
    const schema = {
      type: "object",
      additionalProperties: (_a = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      })) != null ? _a : refs.allowedAdditionalProperties
    };
    if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
      const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
      return {
        ...schema,
        propertyNames: keyType
      };
    } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        ...schema,
        propertyNames: {
          enum: def.keyType._def.values
        }
      };
    } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
      const { type, ...keyType } = parseBrandedDef(
        def.keyType._def,
        refs
      );
      return {
        ...schema,
        propertyNames: keyType
      };
    }
    return schema;
  }

  // src/zod-to-json-schema/parsers/map.ts
  function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
      return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"]
    }) || parseAnyDef();
    const values = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"]
    }) || parseAnyDef();
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [keys, values],
        minItems: 2,
        maxItems: 2
      }
    };
  }

  // src/zod-to-json-schema/parsers/native-enum.ts
  function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
      return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(
      new Set(actualValues.map((values) => typeof values))
    );
    return {
      type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
      enum: actualValues
    };
  }

  // src/zod-to-json-schema/parsers/never.ts
  function parseNeverDef() {
    return { not: parseAnyDef() };
  }

  // src/zod-to-json-schema/parsers/null.ts
  function parseNullDef() {
    return {
      type: "null"
    };
  }

  // src/zod-to-json-schema/parsers/union.ts
  var primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
  function parseUnionDef(def, refs) {
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every(
      (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)
    )) {
      const types = options.reduce((types2, x) => {
        const type = primitiveMappings[x._def.typeName];
        return type && !types2.includes(type) ? [...types2, type] : types2;
      }, []);
      return {
        type: types.length > 1 ? types : types[0]
      };
    } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
      const types = options.reduce(
        (acc, x) => {
          const type = typeof x._def.value;
          switch (type) {
            case "string":
            case "number":
            case "boolean":
              return [...acc, type];
            case "bigint":
              return [...acc, "integer"];
            case "object":
              if (x._def.value === null)
                return [...acc, "null"];
            case "symbol":
            case "undefined":
            case "function":
            default:
              return acc;
          }
        },
        []
      );
      if (types.length === options.length) {
        const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
        return {
          type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
          enum: options.reduce(
            (acc, x) => {
              return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
            },
            []
          )
        };
      }
    } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
      return {
        type: "string",
        enum: options.reduce(
          (acc, x) => [
            ...acc,
            ...x._def.values.filter((x2) => !acc.includes(x2))
          ],
          []
        )
      };
    }
    return asAnyOf(def, refs);
  }
  var asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
      (x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i}`]
      })
    ).filter(
      (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
    );
    return anyOf.length ? { anyOf } : void 0;
  };

  // src/zod-to-json-schema/parsers/nullable.ts
  function parseNullableDef(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
      def.innerType._def.typeName
    ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
      return {
        type: [
          primitiveMappings[def.innerType._def.typeName],
          "null"
        ]
      };
    }
    const base = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "0"]
    });
    return base && { anyOf: [base, { type: "null" }] };
  }

  // src/zod-to-json-schema/parsers/number.ts
  function parseNumberDef(def) {
    const res = {
      type: "number"
    };
    if (!def.checks)
      return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "int":
          res.type = "integer";
          break;
        case "min":
          if (check.inclusive) {
            res.minimum = check.value;
          } else {
            res.exclusiveMinimum = check.value;
          }
          break;
        case "max":
          if (check.inclusive) {
            res.maximum = check.value;
          } else {
            res.exclusiveMaximum = check.value;
          }
          break;
        case "multipleOf":
          res.multipleOf = check.value;
          break;
      }
    }
    return res;
  }

  // src/zod-to-json-schema/parsers/object.ts
  function parseObjectDef(def, refs) {
    const result = {
      type: "object",
      properties: {}
    };
    const required = [];
    const shape = def.shape();
    for (const propName in shape) {
      let propDef = shape[propName];
      if (propDef === void 0 || propDef._def === void 0) {
        continue;
      }
      const propOptional = safeIsOptional(propDef);
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0) {
        continue;
      }
      result.properties[propName] = parsedDef;
      if (!propOptional) {
        required.push(propName);
      }
    }
    if (required.length) {
      result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== void 0) {
      result.additionalProperties = additionalProperties;
    }
    return result;
  }
  function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
      return parseDef(def.catchall._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"]
      });
    }
    switch (def.unknownKeys) {
      case "passthrough":
        return refs.allowedAdditionalProperties;
      case "strict":
        return refs.rejectedAdditionalProperties;
      case "strip":
        return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
    }
  }
  function safeIsOptional(schema) {
    try {
      return schema.isOptional();
    } catch (e) {
      return true;
    }
  }

  // src/zod-to-json-schema/parsers/optional.ts
  var parseOptionalDef = (def, refs) => {
    var _a;
    if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
      return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", "1"]
    });
    return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
  };

  // src/zod-to-json-schema/parsers/pipeline.ts
  var parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
      return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
      return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    });
    const b = parseDef(def.out._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
    });
    return {
      allOf: [a, b].filter((x) => x !== void 0)
    };
  };

  // src/zod-to-json-schema/parsers/promise.ts
  function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
  }

  // src/zod-to-json-schema/parsers/set.ts
  function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
    const schema = {
      type: "array",
      uniqueItems: true,
      items
    };
    if (def.minSize) {
      schema.minItems = def.minSize.value;
    }
    if (def.maxSize) {
      schema.maxItems = def.maxSize.value;
    }
    return schema;
  }

  // src/zod-to-json-schema/parsers/tuple.ts
  function parseTupleDef(def, refs) {
    if (def.rest) {
      return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map(
          (x, i) => parseDef(x._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i}`]
          })
        ).reduce(
          (acc, x) => x === void 0 ? acc : [...acc, x],
          []
        ),
        additionalItems: parseDef(def.rest._def, {
          ...refs,
          currentPath: [...refs.currentPath, "additionalItems"]
        })
      };
    } else {
      return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map(
          (x, i) => parseDef(x._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i}`]
          })
        ).reduce(
          (acc, x) => x === void 0 ? acc : [...acc, x],
          []
        )
      };
    }
  }

  // src/zod-to-json-schema/parsers/undefined.ts
  function parseUndefinedDef() {
    return {
      not: parseAnyDef()
    };
  }

  // src/zod-to-json-schema/parsers/unknown.ts
  function parseUnknownDef() {
    return parseAnyDef();
  }

  // src/zod-to-json-schema/parsers/readonly.ts
  var parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };

  // src/zod-to-json-schema/select-parser.ts
  var selectParser = (def, typeName, refs) => {
    switch (typeName) {
      case ZodFirstPartyTypeKind.ZodString:
        return parseStringDef(def, refs);
      case ZodFirstPartyTypeKind.ZodNumber:
        return parseNumberDef(def);
      case ZodFirstPartyTypeKind.ZodObject:
        return parseObjectDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBigInt:
        return parseBigintDef(def);
      case ZodFirstPartyTypeKind.ZodBoolean:
        return parseBooleanDef();
      case ZodFirstPartyTypeKind.ZodDate:
        return parseDateDef(def, refs);
      case ZodFirstPartyTypeKind.ZodUndefined:
        return parseUndefinedDef();
      case ZodFirstPartyTypeKind.ZodNull:
        return parseNullDef();
      case ZodFirstPartyTypeKind.ZodArray:
        return parseArrayDef(def, refs);
      case ZodFirstPartyTypeKind.ZodUnion:
      case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
        return parseUnionDef(def, refs);
      case ZodFirstPartyTypeKind.ZodIntersection:
        return parseIntersectionDef(def, refs);
      case ZodFirstPartyTypeKind.ZodTuple:
        return parseTupleDef(def, refs);
      case ZodFirstPartyTypeKind.ZodRecord:
        return parseRecordDef(def, refs);
      case ZodFirstPartyTypeKind.ZodLiteral:
        return parseLiteralDef(def);
      case ZodFirstPartyTypeKind.ZodEnum:
        return parseEnumDef(def);
      case ZodFirstPartyTypeKind.ZodNativeEnum:
        return parseNativeEnumDef(def);
      case ZodFirstPartyTypeKind.ZodNullable:
        return parseNullableDef(def, refs);
      case ZodFirstPartyTypeKind.ZodOptional:
        return parseOptionalDef(def, refs);
      case ZodFirstPartyTypeKind.ZodMap:
        return parseMapDef(def, refs);
      case ZodFirstPartyTypeKind.ZodSet:
        return parseSetDef(def, refs);
      case ZodFirstPartyTypeKind.ZodLazy:
        return () => def.getter()._def;
      case ZodFirstPartyTypeKind.ZodPromise:
        return parsePromiseDef(def, refs);
      case ZodFirstPartyTypeKind.ZodNaN:
      case ZodFirstPartyTypeKind.ZodNever:
        return parseNeverDef();
      case ZodFirstPartyTypeKind.ZodEffects:
        return parseEffectsDef(def, refs);
      case ZodFirstPartyTypeKind.ZodAny:
        return parseAnyDef();
      case ZodFirstPartyTypeKind.ZodUnknown:
        return parseUnknownDef();
      case ZodFirstPartyTypeKind.ZodDefault:
        return parseDefaultDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBranded:
        return parseBrandedDef(def, refs);
      case ZodFirstPartyTypeKind.ZodReadonly:
        return parseReadonlyDef(def, refs);
      case ZodFirstPartyTypeKind.ZodCatch:
        return parseCatchDef(def, refs);
      case ZodFirstPartyTypeKind.ZodPipeline:
        return parsePipelineDef(def, refs);
      case ZodFirstPartyTypeKind.ZodFunction:
      case ZodFirstPartyTypeKind.ZodVoid:
      case ZodFirstPartyTypeKind.ZodSymbol:
        return void 0;
      default:
        return /* @__PURE__ */ ((_) => void 0)();
    }
  };

  // src/zod-to-json-schema/parse-def.ts
  function parseDef(def, refs, forceResolution = false) {
    var _a;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
      const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(
        refs,
        def,
        refs,
        seenItem,
        forceResolution
      );
      if (overrideResult !== ignoreOverride) {
        return overrideResult;
      }
    }
    if (seenItem && !forceResolution) {
      const seenSchema = get$ref(seenItem, refs);
      if (seenSchema !== void 0) {
        return seenSchema;
      }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
    if (jsonSchema2) {
      addMeta(def, refs, jsonSchema2);
    }
    if (refs.postProcess) {
      const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
      newItem.jsonSchema = jsonSchema2;
      return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema2;
    return jsonSchema2;
  }
  var get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
      case "root":
        return { $ref: item.path.join("/") };
      case "relative":
        return { $ref: getRelativePath(refs.currentPath, item.path) };
      case "none":
      case "seen": {
        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
          console.warn(
            `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
          );
          return parseAnyDef();
        }
        return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
      }
    }
  };
  var addMeta = (def, refs, jsonSchema2) => {
    if (def.description) {
      jsonSchema2.description = def.description;
    }
    return jsonSchema2;
  };

  // src/zod-to-json-schema/refs.ts
  var getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
    return {
      ..._options,
      currentPath,
      propertyPath: void 0,
      seen: new Map(
        Object.entries(_options.definitions).map(([name, def]) => [
          def._def,
          {
            def: def._def,
            path: [..._options.basePath, _options.definitionPath, name],
            // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
            jsonSchema: void 0
          }
        ])
      )
    };
  };

  // src/zod-to-json-schema/zod-to-json-schema.ts
  var zodToJsonSchema = (schema, options) => {
    var _a;
    const refs = getRefs(options);
    let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
      (acc, [name2, schema2]) => {
        var _a2;
        return {
          ...acc,
          [name2]: (_a2 = parseDef(
            schema2._def,
            {
              ...refs,
              currentPath: [...refs.basePath, refs.definitionPath, name2]
            },
            true
          )) != null ? _a2 : parseAnyDef()
        };
      },
      {}
    ) : void 0;
    const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = (_a = parseDef(
      schema._def,
      name === void 0 ? refs : {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name]
      },
      false
    )) != null ? _a : parseAnyDef();
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
      main.title = title;
    }
    const combined = name === void 0 ? definitions ? {
      ...main,
      [refs.definitionPath]: definitions
    } : main : {
      $ref: [
        ...refs.$refStrategy === "relative" ? [] : refs.basePath,
        refs.definitionPath,
        name
      ].join("/"),
      [refs.definitionPath]: {
        ...definitions,
        [name]: main
      }
    };
    combined.$schema = "http://json-schema.org/draft-07/schema#";
    return combined;
  };

  // src/zod-to-json-schema/index.ts
  var zod_to_json_schema_default = zodToJsonSchema;

  // src/zod-schema.ts
  function zod3Schema(zodSchema2, options) {
    var _a;
    const useReferences = (_a = void 0 ) != null ? _a : false;
    return jsonSchema(
      zod_to_json_schema_default(zodSchema2, {
        $refStrategy: useReferences ? "root" : "none"
      }),
      {
        validate: async (value) => {
          const result = await zodSchema2.safeParseAsync(value);
          return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
        }
      }
    );
  }
  function zod4Schema(zodSchema2, options) {
    var _a;
    const useReferences = (_a = void 0 ) != null ? _a : false;
    const z4JSONSchema = toJSONSchema(zodSchema2, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    });
    return jsonSchema(z4JSONSchema, {
      validate: async (value) => {
        const result = await safeParseAsync(zodSchema2, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    });
  }
  function isZod4Schema(zodSchema2) {
    return "_zod" in zodSchema2;
  }
  function zodSchema(zodSchema2, options) {
    if (isZod4Schema(zodSchema2)) {
      return zod4Schema(zodSchema2);
    } else {
      return zod3Schema(zodSchema2);
    }
  }

  // src/schema.ts
  var schemaSymbol = Symbol.for("vercel.ai.schema");
  function jsonSchema(jsonSchema2, {
    validate
  } = {}) {
    return {
      [schemaSymbol]: true,
      _type: void 0,
      // should never be used directly
      [validatorSymbol$1]: true,
      jsonSchema: jsonSchema2,
      validate
    };
  }
  function isSchema(value) {
    return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
  }
  function asSchema(schema) {
    return schema == null ? jsonSchema({
      properties: {},
      additionalProperties: false
    }) : isSchema(schema) ? schema : zodSchema(schema);
  }

  // src/uint8-utils.ts
  var { btoa: btoa$2, atob: atob$1 } = globalThis;
  function convertBase64ToUint8Array(base64String) {
    const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
    const latin1string = atob$1(base64Url);
    return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
  }
  function convertUint8ArrayToBase64$1(array) {
    let latin1string = "";
    for (let i = 0; i < array.length; i++) {
      latin1string += String.fromCodePoint(array[i]);
    }
    return btoa$2(latin1string);
  }
  function convertToBase64(value) {
    return value instanceof Uint8Array ? convertUint8ArrayToBase64$1(value) : value;
  }

  // src/without-trailing-slash.ts
  function withoutTrailingSlash$1(url) {
    return url == null ? void 0 : url.replace(/\/$/, "");
  }

  // src/is-async-iterable.ts
  function isAsyncIterable(obj) {
    return obj != null && typeof obj[Symbol.asyncIterator] === "function";
  }

  // src/types/execute-tool.ts
  async function* executeTool({
    execute,
    input,
    options
  }) {
    const result = execute(input, options);
    if (isAsyncIterable(result)) {
      let lastOutput;
      for await (const output of result) {
        lastOutput = output;
        yield { type: "preliminary", output };
      }
      yield { type: "final", output: lastOutput };
    } else {
      yield { type: "final", output: await result };
    }
  }

  // src/gateway-provider.ts

  // src/errors/gateway-error.ts
  var marker$2 = "vercel.ai.gateway.error";
  var symbol$2 = Symbol.for(marker$2);
  var _a$2, _b;
  var GatewayError = class _GatewayError extends (_b = Error, _a$2 = symbol$2, _b) {
    constructor({
      message,
      statusCode = 500,
      cause
    }) {
      super(message);
      this[_a$2] = true;
      this.statusCode = statusCode;
      this.cause = cause;
    }
    /**
     * Checks if the given error is a Gateway Error.
     * @param {unknown} error - The error to check.
     * @returns {boolean} True if the error is a Gateway Error, false otherwise.
     */
    static isInstance(error) {
      return _GatewayError.hasMarker(error);
    }
    static hasMarker(error) {
      return typeof error === "object" && error !== null && symbol$2 in error && error[symbol$2] === true;
    }
  };

  // src/errors/gateway-authentication-error.ts
  var name$2 = "GatewayAuthenticationError";
  var marker2$2 = `vercel.ai.gateway.error.${name$2}`;
  var symbol2$2 = Symbol.for(marker2$2);
  var _a2$2, _b2;
  var GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b2 = GatewayError, _a2$2 = symbol2$2, _b2) {
    constructor({
      message = "Authentication failed",
      statusCode = 401,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a2$2] = true;
      // used in isInstance
      this.name = name$2;
      this.type = "authentication_error";
    }
    static isInstance(error) {
      return GatewayError.hasMarker(error) && symbol2$2 in error;
    }
    /**
     * Creates a contextual error message when authentication fails
     */
    static createContextualError({
      apiKeyProvided,
      oidcTokenProvided,
      message = "Authentication failed",
      statusCode = 401,
      cause
    }) {
      let contextualMessage;
      if (apiKeyProvided) {
        contextualMessage = `AI Gateway authentication failed: Invalid API key provided.

The token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
      } else if (oidcTokenProvided) {
        contextualMessage = `AI Gateway authentication failed: Invalid OIDC token provided.

The token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.
- make sure your Vercel project settings have OIDC enabled
- if running locally with 'vercel dev', the token is automatically obtained and refreshed
- if running locally with your own dev server, run 'vercel env pull' to fetch the token
- in production/preview, the token is automatically obtained and refreshed

Alternative: Provide an API key via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
      } else {
        contextualMessage = `AI Gateway authentication failed: No authentication provided.

Provide either an API key or OIDC token.

API key instructions:

The token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

OIDC token instructions:

The token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.
- make sure your Vercel project settings have OIDC enabled
- if running locally with 'vercel dev', the token is automatically obtained and refreshed
- if running locally with your own dev server, run 'vercel env pull' to fetch the token
- in production/preview, the token is automatically obtained and refreshed`;
      }
      return new _GatewayAuthenticationError({
        message: contextualMessage,
        statusCode,
        cause
      });
    }
  };

  // src/errors/gateway-invalid-request-error.ts
  var name2$2 = "GatewayInvalidRequestError";
  var marker3$1 = `vercel.ai.gateway.error.${name2$2}`;
  var symbol3$1 = Symbol.for(marker3$1);
  var _a3$1, _b3;
  var GatewayInvalidRequestError = class extends (_b3 = GatewayError, _a3$1 = symbol3$1, _b3) {
    constructor({
      message = "Invalid request",
      statusCode = 400,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a3$1] = true;
      // used in isInstance
      this.name = name2$2;
      this.type = "invalid_request_error";
    }
    static isInstance(error) {
      return GatewayError.hasMarker(error) && symbol3$1 in error;
    }
  };

  // src/errors/gateway-rate-limit-error.ts
  var name3$1 = "GatewayRateLimitError";
  var marker4$2 = `vercel.ai.gateway.error.${name3$1}`;
  var symbol4$2 = Symbol.for(marker4$2);
  var _a4$2, _b4;
  var GatewayRateLimitError = class extends (_b4 = GatewayError, _a4$2 = symbol4$2, _b4) {
    constructor({
      message = "Rate limit exceeded",
      statusCode = 429,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a4$2] = true;
      // used in isInstance
      this.name = name3$1;
      this.type = "rate_limit_exceeded";
    }
    static isInstance(error) {
      return GatewayError.hasMarker(error) && symbol4$2 in error;
    }
  };
  var name4$1 = "GatewayModelNotFoundError";
  var marker5 = `vercel.ai.gateway.error.${name4$1}`;
  var symbol5 = Symbol.for(marker5);
  var modelNotFoundParamSchema = object$1({
    modelId: string$1()
  });
  var _a5, _b5;
  var GatewayModelNotFoundError = class extends (_b5 = GatewayError, _a5 = symbol5, _b5) {
    constructor({
      message = "Model not found",
      statusCode = 404,
      modelId,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a5] = true;
      // used in isInstance
      this.name = name4$1;
      this.type = "model_not_found";
      this.modelId = modelId;
    }
    static isInstance(error) {
      return GatewayError.hasMarker(error) && symbol5 in error;
    }
  };

  // src/errors/gateway-internal-server-error.ts
  var name5 = "GatewayInternalServerError";
  var marker6 = `vercel.ai.gateway.error.${name5}`;
  var symbol6 = Symbol.for(marker6);
  var _a6, _b6;
  var GatewayInternalServerError = class extends (_b6 = GatewayError, _a6 = symbol6, _b6) {
    constructor({
      message = "Internal server error",
      statusCode = 500,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a6] = true;
      // used in isInstance
      this.name = name5;
      this.type = "internal_server_error";
    }
    static isInstance(error) {
      return GatewayError.hasMarker(error) && symbol6 in error;
    }
  };

  // src/errors/gateway-response-error.ts
  var name6$1 = "GatewayResponseError";
  var marker7$2 = `vercel.ai.gateway.error.${name6$1}`;
  var symbol7$2 = Symbol.for(marker7$2);
  var _a7$2, _b7;
  var GatewayResponseError = class extends (_b7 = GatewayError, _a7$2 = symbol7$2, _b7) {
    constructor({
      message = "Invalid response from Gateway",
      statusCode = 502,
      response,
      validationError,
      cause
    } = {}) {
      super({ message, statusCode, cause });
      this[_a7$2] = true;
      // used in isInstance
      this.name = name6$1;
      this.type = "response_error";
      this.response = response;
      this.validationError = validationError;
    }
    static isInstance(error) {
      return GatewayError.hasMarker(error) && symbol7$2 in error;
    }
  };

  // src/errors/create-gateway-error.ts
  function createGatewayErrorFromResponse({
    response,
    statusCode,
    defaultMessage = "Gateway request failed",
    cause,
    authMethod
  }) {
    const parseResult = gatewayErrorResponseSchema.safeParse(response);
    if (!parseResult.success) {
      return new GatewayResponseError({
        message: `Invalid error response format: ${defaultMessage}`,
        statusCode,
        response,
        validationError: parseResult.error,
        cause
      });
    }
    const validatedResponse = parseResult.data;
    const errorType = validatedResponse.error.type;
    const message = validatedResponse.error.message;
    switch (errorType) {
      case "authentication_error":
        return GatewayAuthenticationError.createContextualError({
          apiKeyProvided: authMethod === "api-key",
          oidcTokenProvided: authMethod === "oidc",
          statusCode,
          cause
        });
      case "invalid_request_error":
        return new GatewayInvalidRequestError({ message, statusCode, cause });
      case "rate_limit_exceeded":
        return new GatewayRateLimitError({ message, statusCode, cause });
      case "model_not_found": {
        const modelResult = modelNotFoundParamSchema.safeParse(
          validatedResponse.error.param
        );
        return new GatewayModelNotFoundError({
          message,
          statusCode,
          modelId: modelResult.success ? modelResult.data.modelId : void 0,
          cause
        });
      }
      case "internal_server_error":
        return new GatewayInternalServerError({ message, statusCode, cause });
      default:
        return new GatewayInternalServerError({ message, statusCode, cause });
    }
  }
  var gatewayErrorResponseSchema = object$1({
    error: object$1({
      message: string$1(),
      type: string$1().nullish(),
      param: unknown().nullish(),
      code: union([string$1(), number$1()]).nullish()
    })
  });

  // src/errors/as-gateway-error.ts
  function asGatewayError(error, authMethod) {
    var _a8;
    if (GatewayError.isInstance(error)) {
      return error;
    }
    if (APICallError$1.isInstance(error)) {
      return createGatewayErrorFromResponse({
        response: extractApiCallResponse(error),
        statusCode: (_a8 = error.statusCode) != null ? _a8 : 500,
        defaultMessage: "Gateway request failed",
        cause: error,
        authMethod
      });
    }
    return createGatewayErrorFromResponse({
      response: {},
      statusCode: 500,
      defaultMessage: error instanceof Error ? `Gateway request failed: ${error.message}` : "Unknown Gateway error",
      cause: error,
      authMethod
    });
  }

  // src/errors/extract-api-call-response.ts
  function extractApiCallResponse(error) {
    if (error.data !== void 0) {
      return error.data;
    }
    if (error.responseBody != null) {
      try {
        return JSON.parse(error.responseBody);
      } catch (e) {
        return error.responseBody;
      }
    }
    return {};
  }
  var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
  function parseAuthMethod(headers) {
    const result = gatewayAuthMethodSchema.safeParse(
      headers[GATEWAY_AUTH_METHOD_HEADER]
    );
    return result.success ? result.data : void 0;
  }
  var gatewayAuthMethodSchema = union([
    literal("api-key"),
    literal("oidc")
  ]);
  var GatewayFetchMetadata = class {
    constructor(config) {
      this.config = config;
    }
    async getAvailableModels() {
      try {
        const { value } = await getFromApi({
          url: `${this.config.baseURL}/config`,
          headers: await resolve(this.config.headers()),
          successfulResponseHandler: createJsonResponseHandler$1(
            gatewayFetchMetadataSchema
          ),
          failedResponseHandler: createJsonErrorResponseHandler$1({
            errorSchema: any(),
            errorToMessage: (data) => data
          }),
          fetch: this.config.fetch
        });
        return value;
      } catch (error) {
        throw asGatewayError(error);
      }
    }
  };
  var gatewayLanguageModelSpecificationSchema = object$1({
    specificationVersion: literal("v2"),
    provider: string$1(),
    modelId: string$1()
  });
  var gatewayLanguageModelPricingSchema = object$1({
    input: string$1(),
    output: string$1(),
    input_cache_read: string$1().nullish(),
    input_cache_write: string$1().nullish()
  }).transform(({ input, output, input_cache_read, input_cache_write }) => ({
    input,
    output,
    ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
    ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
  }));
  var gatewayLanguageModelEntrySchema = object$1({
    id: string$1(),
    name: string$1(),
    description: string$1().nullish(),
    pricing: gatewayLanguageModelPricingSchema.nullish(),
    specification: gatewayLanguageModelSpecificationSchema,
    modelType: _enum(["language", "embedding", "image"]).nullish()
  });
  var gatewayFetchMetadataSchema = object$1({
    models: array(gatewayLanguageModelEntrySchema)
  });
  var GatewayLanguageModel = class {
    constructor(modelId, config) {
      this.modelId = modelId;
      this.config = config;
      this.specificationVersion = "v2";
      this.supportedUrls = { "*/*": [/.*/] };
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs(options) {
      const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
      return {
        args: this.maybeEncodeFileParts(optionsWithoutSignal),
        warnings: []
      };
    }
    async doGenerate(options) {
      const { args, warnings } = await this.getArgs(options);
      const { abortSignal } = options;
      const resolvedHeaders = await resolve(this.config.headers());
      try {
        const {
          responseHeaders,
          value: responseBody,
          rawValue: rawResponse
        } = await postJsonToApi$1({
          url: this.getUrl(),
          headers: combineHeaders$1(
            resolvedHeaders,
            options.headers,
            this.getModelConfigHeaders(this.modelId, false),
            await resolve(this.config.o11yHeaders)
          ),
          body: args,
          successfulResponseHandler: createJsonResponseHandler$1(any()),
          failedResponseHandler: createJsonErrorResponseHandler$1({
            errorSchema: any(),
            errorToMessage: (data) => data
          }),
          ...abortSignal && { abortSignal },
          fetch: this.config.fetch
        });
        return {
          ...responseBody,
          request: { body: args },
          response: { headers: responseHeaders, body: rawResponse },
          warnings
        };
      } catch (error) {
        throw asGatewayError(error, parseAuthMethod(resolvedHeaders));
      }
    }
    async doStream(options) {
      const { args, warnings } = await this.getArgs(options);
      const { abortSignal } = options;
      const resolvedHeaders = await resolve(this.config.headers());
      try {
        const { value: response, responseHeaders } = await postJsonToApi$1({
          url: this.getUrl(),
          headers: combineHeaders$1(
            resolvedHeaders,
            options.headers,
            this.getModelConfigHeaders(this.modelId, true),
            await resolve(this.config.o11yHeaders)
          ),
          body: args,
          successfulResponseHandler: createEventSourceResponseHandler(any()),
          failedResponseHandler: createJsonErrorResponseHandler$1({
            errorSchema: any(),
            errorToMessage: (data) => data
          }),
          ...abortSignal && { abortSignal },
          fetch: this.config.fetch
        });
        return {
          stream: response.pipeThrough(
            new TransformStream({
              start(controller) {
                if (warnings.length > 0) {
                  controller.enqueue({ type: "stream-start", warnings });
                }
              },
              transform(chunk, controller) {
                if (chunk.success) {
                  const streamPart = chunk.value;
                  if (streamPart.type === "raw" && !options.includeRawChunks) {
                    return;
                  }
                  if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string") {
                    streamPart.timestamp = new Date(streamPart.timestamp);
                  }
                  controller.enqueue(streamPart);
                } else {
                  controller.error(
                    chunk.error
                  );
                }
              }
            })
          ),
          request: { body: args },
          response: { headers: responseHeaders }
        };
      } catch (error) {
        throw asGatewayError(error, parseAuthMethod(resolvedHeaders));
      }
    }
    isFilePart(part) {
      return part && typeof part === "object" && "type" in part && part.type === "file";
    }
    /**
     * Encodes file parts in the prompt to base64. Mutates the passed options
     * instance directly to avoid copying the file data.
     * @param options - The options to encode.
     * @returns The options with the file parts encoded.
     */
    maybeEncodeFileParts(options) {
      for (const message of options.prompt) {
        for (const part of message.content) {
          if (this.isFilePart(part)) {
            const filePart = part;
            if (filePart.data instanceof Uint8Array) {
              const buffer = Uint8Array.from(filePart.data);
              const base64Data = Buffer.from(buffer).toString("base64");
              filePart.data = new URL(
                `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`
              );
            }
          }
        }
      }
      return options;
    }
    getUrl() {
      return `${this.config.baseURL}/language-model`;
    }
    getModelConfigHeaders(modelId, streaming) {
      return {
        "ai-language-model-specification-version": "2",
        "ai-language-model-id": modelId,
        "ai-language-model-streaming": String(streaming)
      };
    }
  };
  var GatewayEmbeddingModel = class {
    constructor(modelId, config) {
      this.modelId = modelId;
      this.config = config;
      this.specificationVersion = "v2";
      this.maxEmbeddingsPerCall = 2048;
      this.supportsParallelCalls = true;
    }
    get provider() {
      return this.config.provider;
    }
    async doEmbed({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      var _a8;
      const resolvedHeaders = await resolve(this.config.headers());
      try {
        const {
          responseHeaders,
          value: responseBody,
          rawValue
        } = await postJsonToApi$1({
          url: this.getUrl(),
          headers: combineHeaders$1(
            resolvedHeaders,
            headers != null ? headers : {},
            this.getModelConfigHeaders(),
            await resolve(this.config.o11yHeaders)
          ),
          body: {
            input: values.length === 1 ? values[0] : values,
            ...providerOptions != null ? providerOptions : {}
          },
          successfulResponseHandler: createJsonResponseHandler$1(
            gatewayEmbeddingResponseSchema
          ),
          failedResponseHandler: createJsonErrorResponseHandler$1({
            errorSchema: any(),
            errorToMessage: (data) => data
          }),
          ...abortSignal && { abortSignal },
          fetch: this.config.fetch
        });
        return {
          embeddings: responseBody.embeddings,
          usage: (_a8 = responseBody.usage) != null ? _a8 : void 0,
          providerMetadata: responseBody.providerMetadata,
          response: { headers: responseHeaders, body: rawValue }
        };
      } catch (error) {
        throw asGatewayError(error, parseAuthMethod(resolvedHeaders));
      }
    }
    getUrl() {
      return `${this.config.baseURL}/embedding-model`;
    }
    getModelConfigHeaders() {
      return {
        "ai-embedding-model-specification-version": "2",
        "ai-model-id": this.modelId
      };
    }
  };
  var gatewayEmbeddingResponseSchema = object$1({
    embeddings: array(array(number$1())),
    usage: object$1({ tokens: number$1() }).nullish(),
    providerMetadata: record(string$1(), record(string$1(), unknown())).optional()
  });

  // src/vercel-environment.ts
  async function getVercelOidcToken() {
    var _a8, _b8;
    const token = (_b8 = (_a8 = getContext().headers) == null ? void 0 : _a8["x-vercel-oidc-token"]) != null ? _b8 : process.env.VERCEL_OIDC_TOKEN;
    if (!token) {
      throw new GatewayAuthenticationError({
        message: "OIDC token not available",
        statusCode: 401
      });
    }
    return token;
  }
  async function getVercelRequestId() {
    var _a8;
    return (_a8 = getContext().headers) == null ? void 0 : _a8["x-vercel-id"];
  }
  var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
  function getContext() {
    var _a8, _b8, _c;
    const fromSymbol = globalThis;
    return (_c = (_b8 = (_a8 = fromSymbol[SYMBOL_FOR_REQ_CONTEXT]) == null ? void 0 : _a8.get) == null ? void 0 : _b8.call(_a8)) != null ? _c : {};
  }

  // src/gateway-provider.ts
  var AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
  function createGatewayProvider(options = {}) {
    var _a8, _b8;
    let pendingMetadata = null;
    let metadataCache = null;
    const cacheRefreshMillis = (_a8 = options.metadataCacheRefreshMillis) != null ? _a8 : 1e3 * 60 * 5;
    let lastFetchTime = 0;
    const baseURL = (_b8 = withoutTrailingSlash$1(options.baseURL)) != null ? _b8 : "https://ai-gateway.vercel.sh/v1/ai";
    const getHeaders = async () => {
      const auth = await getGatewayAuthToken(options);
      if (auth) {
        return {
          Authorization: `Bearer ${auth.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
          [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
          ...options.headers
        };
      }
      throw GatewayAuthenticationError.createContextualError({
        apiKeyProvided: false,
        oidcTokenProvided: false,
        statusCode: 401
      });
    };
    const createO11yHeaders = () => {
      const deploymentId = loadOptionalSetting({
        settingValue: void 0,
        environmentVariableName: "VERCEL_DEPLOYMENT_ID"
      });
      const environment = loadOptionalSetting({
        settingValue: void 0,
        environmentVariableName: "VERCEL_ENV"
      });
      const region = loadOptionalSetting({
        settingValue: void 0,
        environmentVariableName: "VERCEL_REGION"
      });
      return async () => {
        const requestId = await getVercelRequestId();
        return {
          ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
          ...environment && { "ai-o11y-environment": environment },
          ...region && { "ai-o11y-region": region },
          ...requestId && { "ai-o11y-request-id": requestId }
        };
      };
    };
    const createLanguageModel = (modelId) => {
      return new GatewayLanguageModel(modelId, {
        provider: "gateway",
        baseURL,
        headers: getHeaders,
        fetch: options.fetch,
        o11yHeaders: createO11yHeaders()
      });
    };
    const getAvailableModels = async () => {
      var _a9, _b9, _c;
      const now = (_c = (_b9 = (_a9 = options._internal) == null ? void 0 : _a9.currentDate) == null ? void 0 : _b9.call(_a9).getTime()) != null ? _c : Date.now();
      if (!pendingMetadata || now - lastFetchTime > cacheRefreshMillis) {
        lastFetchTime = now;
        pendingMetadata = new GatewayFetchMetadata({
          baseURL,
          headers: getHeaders,
          fetch: options.fetch
        }).getAvailableModels().then((metadata) => {
          metadataCache = metadata;
          return metadata;
        }).catch(async (error) => {
          throw asGatewayError(error, parseAuthMethod(await getHeaders()));
        });
      }
      return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
    };
    const provider = function(modelId) {
      if (new.target) {
        throw new Error(
          "The Gateway Provider model function cannot be called with the new keyword."
        );
      }
      return createLanguageModel(modelId);
    };
    provider.getAvailableModels = getAvailableModels;
    provider.imageModel = (modelId) => {
      throw new NoSuchModelError({ modelId, modelType: "imageModel" });
    };
    provider.languageModel = createLanguageModel;
    provider.textEmbeddingModel = (modelId) => {
      return new GatewayEmbeddingModel(modelId, {
        provider: "gateway",
        baseURL,
        headers: getHeaders,
        fetch: options.fetch,
        o11yHeaders: createO11yHeaders()
      });
    };
    return provider;
  }
  var gateway = createGatewayProvider();
  async function getGatewayAuthToken(options) {
    const apiKey = loadOptionalSetting({
      settingValue: options.apiKey,
      environmentVariableName: "AI_GATEWAY_API_KEY"
    });
    if (apiKey) {
      return {
        token: apiKey,
        authMethod: "api-key"
      };
    }
    try {
      const oidcToken = await getVercelOidcToken();
      return {
        token: oidcToken,
        authMethod: "oidc"
      };
    } catch (e) {
      return null;
    }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // Updates to this file should also be replicated to @opentelemetry/core too.
  /**
   * - globalThis (New standard)
   * - self (Will return the current window instance for supported browsers)
   * - window (fallback for older browser implementations)
   * - global (NodeJS implementation)
   * - <object> (When all else fails)
   */
  /** only globals that common to node and browsers are allowed */
  // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
  var _globalThis = typeof globalThis === 'object'
      ? globalThis
      : typeof self === 'object'
          ? self
          : typeof window === 'object'
              ? window
              : typeof global === 'object'
                  ? global
                  : {};

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // this is autogenerated file, see scripts/version-update.js
  var VERSION = '1.9.0';

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  /**
   * Create a function to test an API version to see if it is compatible with the provided ownVersion.
   *
   * The returned function has the following semantics:
   * - Exact match is always compatible
   * - Major versions must match exactly
   *    - 1.x package cannot use global 2.x package
   *    - 2.x package cannot use global 1.x package
   * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
   *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
   *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
   * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
   * - Patch and build tag differences are not considered at this time
   *
   * @param ownVersion version which should be checked against
   */
  function _makeCompatibilityCheck(ownVersion) {
      var acceptedVersions = new Set([ownVersion]);
      var rejectedVersions = new Set();
      var myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
          // we cannot guarantee compatibility so we always return noop
          return function () { return false; };
      }
      var ownVersionParsed = {
          major: +myVersionMatch[1],
          minor: +myVersionMatch[2],
          patch: +myVersionMatch[3],
          prerelease: myVersionMatch[4],
      };
      // if ownVersion has a prerelease tag, versions must match exactly
      if (ownVersionParsed.prerelease != null) {
          return function isExactmatch(globalVersion) {
              return globalVersion === ownVersion;
          };
      }
      function _reject(v) {
          rejectedVersions.add(v);
          return false;
      }
      function _accept(v) {
          acceptedVersions.add(v);
          return true;
      }
      return function isCompatible(globalVersion) {
          if (acceptedVersions.has(globalVersion)) {
              return true;
          }
          if (rejectedVersions.has(globalVersion)) {
              return false;
          }
          var globalVersionMatch = globalVersion.match(re);
          if (!globalVersionMatch) {
              // cannot parse other version
              // we cannot guarantee compatibility so we always noop
              return _reject(globalVersion);
          }
          var globalVersionParsed = {
              major: +globalVersionMatch[1],
              minor: +globalVersionMatch[2],
              patch: +globalVersionMatch[3],
              prerelease: globalVersionMatch[4],
          };
          // if globalVersion has a prerelease tag, versions must match exactly
          if (globalVersionParsed.prerelease != null) {
              return _reject(globalVersion);
          }
          // major versions must match
          if (ownVersionParsed.major !== globalVersionParsed.major) {
              return _reject(globalVersion);
          }
          if (ownVersionParsed.major === 0) {
              if (ownVersionParsed.minor === globalVersionParsed.minor &&
                  ownVersionParsed.patch <= globalVersionParsed.patch) {
                  return _accept(globalVersion);
              }
              return _reject(globalVersion);
          }
          if (ownVersionParsed.minor <= globalVersionParsed.minor) {
              return _accept(globalVersion);
          }
          return _reject(globalVersion);
      };
  }
  /**
   * Test an API version to see if it is compatible with this API.
   *
   * - Exact match is always compatible
   * - Major versions must match exactly
   *    - 1.x package cannot use global 2.x package
   *    - 2.x package cannot use global 1.x package
   * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
   *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
   *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
   * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
   * - Patch and build tag differences are not considered at this time
   *
   * @param version version of the API requesting an instance of the global API
   */
  var isCompatible = _makeCompatibilityCheck(VERSION);

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var major = VERSION.split('.')[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
  var _global = _globalThis;
  function registerGlobal(type, instance, diag, allowOverride) {
      var _a;
      if (allowOverride === void 0) { allowOverride = false; }
      var api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
          version: VERSION,
      });
      if (!allowOverride && api[type]) {
          // already registered an API of this type
          var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
          diag.error(err.stack || err.message);
          return false;
      }
      if (api.version !== VERSION) {
          // All registered APIs must be of the same version exactly
          var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
          diag.error(err.stack || err.message);
          return false;
      }
      api[type] = instance;
      diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
      return true;
  }
  function getGlobal(type) {
      var _a, _b;
      var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!globalVersion || !isCompatible(globalVersion)) {
          return;
      }
      return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
  }
  function unregisterGlobal(type, diag) {
      diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
      var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
          delete api[type];
      }
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __read$3 = (window && window.__read) || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  };
  var __spreadArray$3 = (window && window.__spreadArray) || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  };
  /**
   * Component Logger which is meant to be used as part of any component which
   * will add automatically additional namespace in front of the log message.
   * It will then forward all message to global diag logger
   * @example
   * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
   * cLogger.debug('test');
   * // @opentelemetry/instrumentation-http test
   */
  var DiagComponentLogger = /** @class */ (function () {
      function DiagComponentLogger(props) {
          this._namespace = props.namespace || 'DiagComponentLogger';
      }
      DiagComponentLogger.prototype.debug = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return logProxy('debug', this._namespace, args);
      };
      DiagComponentLogger.prototype.error = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return logProxy('error', this._namespace, args);
      };
      DiagComponentLogger.prototype.info = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return logProxy('info', this._namespace, args);
      };
      DiagComponentLogger.prototype.warn = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return logProxy('warn', this._namespace, args);
      };
      DiagComponentLogger.prototype.verbose = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return logProxy('verbose', this._namespace, args);
      };
      return DiagComponentLogger;
  }());
  function logProxy(funcName, namespace, args) {
      var logger = getGlobal('diag');
      // shortcut if logger not set
      if (!logger) {
          return;
      }
      args.unshift(namespace);
      return logger[funcName].apply(logger, __spreadArray$3([], __read$3(args), false));
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Defines the available internal logging levels for the diagnostic logger, the numeric values
   * of the levels are defined to match the original values from the initial LogLevel to avoid
   * compatibility/migration issues for any implementation that assume the numeric ordering.
   */
  var DiagLogLevel;
  (function (DiagLogLevel) {
      /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
      DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
      /** Identifies an error scenario */
      DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
      /** Identifies a warning scenario */
      DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
      /** General informational log message */
      DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
      /** General debug log message */
      DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
      /**
       * Detailed trace level logging should only be used for development, should only be set
       * in a development environment.
       */
      DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
      /** Used to set the logging level to include all logging */
      DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
  })(DiagLogLevel || (DiagLogLevel = {}));

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function createLogLevelDiagLogger(maxLevel, logger) {
      if (maxLevel < DiagLogLevel.NONE) {
          maxLevel = DiagLogLevel.NONE;
      }
      else if (maxLevel > DiagLogLevel.ALL) {
          maxLevel = DiagLogLevel.ALL;
      }
      // In case the logger is null or undefined
      logger = logger || {};
      function _filterFunc(funcName, theLevel) {
          var theFunc = logger[funcName];
          if (typeof theFunc === 'function' && maxLevel >= theLevel) {
              return theFunc.bind(logger);
          }
          return function () { };
      }
      return {
          error: _filterFunc('error', DiagLogLevel.ERROR),
          warn: _filterFunc('warn', DiagLogLevel.WARN),
          info: _filterFunc('info', DiagLogLevel.INFO),
          debug: _filterFunc('debug', DiagLogLevel.DEBUG),
          verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),
      };
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __read$2 = (window && window.__read) || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  };
  var __spreadArray$2 = (window && window.__spreadArray) || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  };
  var API_NAME$2 = 'diag';
  /**
   * Singleton object which represents the entry point to the OpenTelemetry internal
   * diagnostic API
   */
  var DiagAPI = /** @class */ (function () {
      /**
       * Private internal constructor
       * @private
       */
      function DiagAPI() {
          function _logProxy(funcName) {
              return function () {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i] = arguments[_i];
                  }
                  var logger = getGlobal('diag');
                  // shortcut if logger not set
                  if (!logger)
                      return;
                  return logger[funcName].apply(logger, __spreadArray$2([], __read$2(args), false));
              };
          }
          // Using self local variable for minification purposes as 'this' cannot be minified
          var self = this;
          // DiagAPI specific functions
          var setLogger = function (logger, optionsOrLogLevel) {
              var _a, _b, _c;
              if (optionsOrLogLevel === void 0) { optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }; }
              if (logger === self) {
                  // There isn't much we can do here.
                  // Logging to the console might break the user application.
                  // Try to log to self. If a logger was previously registered it will receive the log.
                  var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                  self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
                  return false;
              }
              if (typeof optionsOrLogLevel === 'number') {
                  optionsOrLogLevel = {
                      logLevel: optionsOrLogLevel,
                  };
              }
              var oldLogger = getGlobal('diag');
              var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
              // There already is an logger registered. We'll let it know before overwriting it.
              if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                  var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : '<failed to generate stacktrace>';
                  oldLogger.warn("Current logger will be overwritten from " + stack);
                  newLogger.warn("Current logger will overwrite one already registered from " + stack);
              }
              return registerGlobal('diag', newLogger, self, true);
          };
          self.setLogger = setLogger;
          self.disable = function () {
              unregisterGlobal(API_NAME$2, self);
          };
          self.createComponentLogger = function (options) {
              return new DiagComponentLogger(options);
          };
          self.verbose = _logProxy('verbose');
          self.debug = _logProxy('debug');
          self.info = _logProxy('info');
          self.warn = _logProxy('warn');
          self.error = _logProxy('error');
      }
      /** Get the singleton instance of the DiagAPI API */
      DiagAPI.instance = function () {
          if (!this._instance) {
              this._instance = new DiagAPI();
          }
          return this._instance;
      };
      return DiagAPI;
  }());

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /** Get a key to uniquely identify a context value */
  function createContextKey(description) {
      // The specification states that for the same input, multiple calls should
      // return different keys. Due to the nature of the JS dependency management
      // system, this creates problems where multiple versions of some package
      // could hold different keys for the same property.
      //
      // Therefore, we use Symbol.for which returns the same key for the same input.
      return Symbol.for(description);
  }
  var BaseContext = /** @class */ (function () {
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      function BaseContext(parentContext) {
          // for minification
          var self = this;
          self._currentContext = parentContext ? new Map(parentContext) : new Map();
          self.getValue = function (key) { return self._currentContext.get(key); };
          self.setValue = function (key, value) {
              var context = new BaseContext(self._currentContext);
              context._currentContext.set(key, value);
              return context;
          };
          self.deleteValue = function (key) {
              var context = new BaseContext(self._currentContext);
              context._currentContext.delete(key);
              return context;
          };
      }
      return BaseContext;
  }());
  /** The root context is used as the default parent context when there is no active context */
  var ROOT_CONTEXT = new BaseContext();

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __read$1 = (window && window.__read) || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  };
  var __spreadArray$1 = (window && window.__spreadArray) || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  };
  var NoopContextManager = /** @class */ (function () {
      function NoopContextManager() {
      }
      NoopContextManager.prototype.active = function () {
          return ROOT_CONTEXT;
      };
      NoopContextManager.prototype.with = function (_context, fn, thisArg) {
          var args = [];
          for (var _i = 3; _i < arguments.length; _i++) {
              args[_i - 3] = arguments[_i];
          }
          return fn.call.apply(fn, __spreadArray$1([thisArg], __read$1(args), false));
      };
      NoopContextManager.prototype.bind = function (_context, target) {
          return target;
      };
      NoopContextManager.prototype.enable = function () {
          return this;
      };
      NoopContextManager.prototype.disable = function () {
          return this;
      };
      return NoopContextManager;
  }());

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var __read = (window && window.__read) || function (o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  };
  var __spreadArray = (window && window.__spreadArray) || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  };
  var API_NAME$1 = 'context';
  var NOOP_CONTEXT_MANAGER = new NoopContextManager();
  /**
   * Singleton object which represents the entry point to the OpenTelemetry Context API
   */
  var ContextAPI = /** @class */ (function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function ContextAPI() {
      }
      /** Get the singleton instance of the Context API */
      ContextAPI.getInstance = function () {
          if (!this._instance) {
              this._instance = new ContextAPI();
          }
          return this._instance;
      };
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
          return registerGlobal(API_NAME$1, contextManager, DiagAPI.instance());
      };
      /**
       * Get the currently active context
       */
      ContextAPI.prototype.active = function () {
          return this._getContextManager().active();
      };
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      ContextAPI.prototype.with = function (context, fn, thisArg) {
          var _a;
          var args = [];
          for (var _i = 3; _i < arguments.length; _i++) {
              args[_i - 3] = arguments[_i];
          }
          return (_a = this._getContextManager()).with.apply(_a, __spreadArray([context, fn, thisArg], __read(args), false));
      };
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      ContextAPI.prototype.bind = function (context, target) {
          return this._getContextManager().bind(context, target);
      };
      ContextAPI.prototype._getContextManager = function () {
          return getGlobal(API_NAME$1) || NOOP_CONTEXT_MANAGER;
      };
      /** Disable and remove the global context manager */
      ContextAPI.prototype.disable = function () {
          this._getContextManager().disable();
          unregisterGlobal(API_NAME$1, DiagAPI.instance());
      };
      return ContextAPI;
  }());

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var TraceFlags;
  (function (TraceFlags) {
      /** Represents no flag set. */
      TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
      /** Bit to represent whether trace is sampled in trace flags. */
      TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags || (TraceFlags = {}));

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var INVALID_SPANID = '0000000000000000';
  var INVALID_TRACEID = '00000000000000000000000000000000';
  var INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE,
  };

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * The NonRecordingSpan is the default {@link Span} that is used when no Span
   * implementation is available. All operations are no-op including context
   * propagation.
   */
  var NonRecordingSpan = /** @class */ (function () {
      function NonRecordingSpan(_spanContext) {
          if (_spanContext === void 0) { _spanContext = INVALID_SPAN_CONTEXT; }
          this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      NonRecordingSpan.prototype.spanContext = function () {
          return this._spanContext;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
          return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setAttributes = function (_attributes) {
          return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
          return this;
      };
      NonRecordingSpan.prototype.addLink = function (_link) {
          return this;
      };
      NonRecordingSpan.prototype.addLinks = function (_links) {
          return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.setStatus = function (_status) {
          return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.updateName = function (_name) {
          return this;
      };
      // By default does nothing
      NonRecordingSpan.prototype.end = function (_endTime) { };
      // isRecording always returns false for NonRecordingSpan.
      NonRecordingSpan.prototype.isRecording = function () {
          return false;
      };
      // By default does nothing
      NonRecordingSpan.prototype.recordException = function (_exception, _time) { };
      return NonRecordingSpan;
  }());

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * span key
   */
  var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
  /**
   * Return the span if one exists
   *
   * @param context context to get span from
   */
  function getSpan(context) {
      return context.getValue(SPAN_KEY) || undefined;
  }
  /**
   * Gets the span from the current context, if one exists.
   */
  function getActiveSpan() {
      return getSpan(ContextAPI.getInstance().active());
  }
  /**
   * Set the span on a context
   *
   * @param context context to use as parent
   * @param span span to set active
   */
  function setSpan(context, span) {
      return context.setValue(SPAN_KEY, span);
  }
  /**
   * Remove current span stored in the context
   *
   * @param context context to delete span from
   */
  function deleteSpan(context) {
      return context.deleteValue(SPAN_KEY);
  }
  /**
   * Wrap span context in a NoopSpan and set as span in a new
   * context
   *
   * @param context context to set active span on
   * @param spanContext span context to be wrapped
   */
  function setSpanContext(context, spanContext) {
      return setSpan(context, new NonRecordingSpan(spanContext));
  }
  /**
   * Get the span context of the span if it exists.
   *
   * @param context context to get values from
   */
  function getSpanContext(context) {
      var _a;
      return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
  }
  function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
  }
  /**
   * Returns true if this {@link SpanContext} is valid.
   * @return true if this {@link SpanContext} is valid.
   */
  function isSpanContextValid(spanContext) {
      return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
  }
  /**
   * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
   *
   * @param spanContext span context to be wrapped
   * @returns a new non-recording {@link Span} with the provided context
   */
  function wrapSpanContext(spanContext) {
      return new NonRecordingSpan(spanContext);
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var contextApi = ContextAPI.getInstance();
  /**
   * No-op implementations of {@link Tracer}.
   */
  var NoopTracer = /** @class */ (function () {
      function NoopTracer() {
      }
      // startSpan starts a noop span.
      NoopTracer.prototype.startSpan = function (name, options, context) {
          if (context === void 0) { context = contextApi.active(); }
          var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
          if (root) {
              return new NonRecordingSpan();
          }
          var parentFromContext = context && getSpanContext(context);
          if (isSpanContext(parentFromContext) &&
              isSpanContextValid(parentFromContext)) {
              return new NonRecordingSpan(parentFromContext);
          }
          else {
              return new NonRecordingSpan();
          }
      };
      NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
          var opts;
          var ctx;
          var fn;
          if (arguments.length < 2) {
              return;
          }
          else if (arguments.length === 2) {
              fn = arg2;
          }
          else if (arguments.length === 3) {
              opts = arg2;
              fn = arg3;
          }
          else {
              opts = arg2;
              ctx = arg3;
              fn = arg4;
          }
          var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
          var span = this.startSpan(name, opts, parentContext);
          var contextWithSpanSet = setSpan(parentContext, span);
          return contextApi.with(contextWithSpanSet, fn, undefined, span);
      };
      return NoopTracer;
  }());
  function isSpanContext(spanContext) {
      return (typeof spanContext === 'object' &&
          typeof spanContext['spanId'] === 'string' &&
          typeof spanContext['traceId'] === 'string' &&
          typeof spanContext['traceFlags'] === 'number');
  }

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var NOOP_TRACER = new NoopTracer();
  /**
   * Proxy tracer provided by the proxy tracer provider
   */
  var ProxyTracer = /** @class */ (function () {
      function ProxyTracer(_provider, name, version, options) {
          this._provider = _provider;
          this.name = name;
          this.version = version;
          this.options = options;
      }
      ProxyTracer.prototype.startSpan = function (name, options, context) {
          return this._getTracer().startSpan(name, options, context);
      };
      ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
          var tracer = this._getTracer();
          return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      ProxyTracer.prototype._getTracer = function () {
          if (this._delegate) {
              return this._delegate;
          }
          var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
          if (!tracer) {
              return NOOP_TRACER;
          }
          this._delegate = tracer;
          return this._delegate;
      };
      return ProxyTracer;
  }());

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * An implementation of the {@link TracerProvider} which returns an impotent
   * Tracer for all calls to `getTracer`.
   *
   * All operations are no-op.
   */
  var NoopTracerProvider = /** @class */ (function () {
      function NoopTracerProvider() {
      }
      NoopTracerProvider.prototype.getTracer = function (_name, _version, _options) {
          return new NoopTracer();
      };
      return NoopTracerProvider;
  }());

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
  /**
   * Tracer provider which provides {@link ProxyTracer}s.
   *
   * Before a delegate is set, tracers provided are NoOp.
   *   When a delegate is set, traces are provided from the delegate.
   *   When a delegate is set after tracers have already been provided,
   *   all tracers already provided will use the provided delegate implementation.
   */
  var ProxyTracerProvider = /** @class */ (function () {
      function ProxyTracerProvider() {
      }
      /**
       * Get a {@link ProxyTracer}
       */
      ProxyTracerProvider.prototype.getTracer = function (name, version, options) {
          var _a;
          return ((_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options));
      };
      ProxyTracerProvider.prototype.getDelegate = function () {
          var _a;
          return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      /**
       * Set the delegate tracer provider
       */
      ProxyTracerProvider.prototype.setDelegate = function (delegate) {
          this._delegate = delegate;
      };
      ProxyTracerProvider.prototype.getDelegateTracer = function (name, version, options) {
          var _a;
          return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider;
  }());

  /**
   * An enumeration of status codes.
   */
  var SpanStatusCode;
  (function (SpanStatusCode) {
      /**
       * The default status.
       */
      SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
      /**
       * The operation has been validated by an Application developer or
       * Operator to have completed successfully.
       */
      SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
      /**
       * The operation contains an error.
       */
      SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode || (SpanStatusCode = {}));

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var API_NAME = 'trace';
  /**
   * Singleton object which represents the entry point to the OpenTelemetry Tracing API
   */
  var TraceAPI = /** @class */ (function () {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      function TraceAPI() {
          this._proxyTracerProvider = new ProxyTracerProvider();
          this.wrapSpanContext = wrapSpanContext;
          this.isSpanContextValid = isSpanContextValid;
          this.deleteSpan = deleteSpan;
          this.getSpan = getSpan;
          this.getActiveSpan = getActiveSpan;
          this.getSpanContext = getSpanContext;
          this.setSpan = setSpan;
          this.setSpanContext = setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      TraceAPI.getInstance = function () {
          if (!this._instance) {
              this._instance = new TraceAPI();
          }
          return this._instance;
      };
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
          var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
          if (success) {
              this._proxyTracerProvider.setDelegate(provider);
          }
          return success;
      };
      /**
       * Returns the global tracer provider.
       */
      TraceAPI.prototype.getTracerProvider = function () {
          return getGlobal(API_NAME) || this._proxyTracerProvider;
      };
      /**
       * Returns a tracer from the global tracer provider.
       */
      TraceAPI.prototype.getTracer = function (name, version) {
          return this.getTracerProvider().getTracer(name, version);
      };
      /** Remove the global tracer provider */
      TraceAPI.prototype.disable = function () {
          unregisterGlobal(API_NAME, DiagAPI.instance());
          this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI;
  }());

  /*
   * Copyright The OpenTelemetry Authors
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  // Split module-level variable definition into separate files to allow
  // tree-shaking on each api instance.
  /** Entrypoint for trace API */
  var trace = TraceAPI.getInstance();

  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name17 in all)
      __defProp(target, name17, { get: all[name17], enumerable: true });
  };
  var name$1 = "AI_NoOutputSpecifiedError";
  var marker$1 = `vercel.ai.error.${name$1}`;
  var symbol$1 = Symbol.for(marker$1);
  var _a$1;
  var NoOutputSpecifiedError = class extends AISDKError$1 {
    // used in isInstance
    constructor({ message = "No output specified." } = {}) {
      super({ name: name$1, message });
      this[_a$1] = true;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker$1);
    }
  };
  _a$1 = symbol$1;

  // src/logger/log-warnings.ts
  function formatWarning(warning) {
    const prefix = "AI SDK Warning:";
    switch (warning.type) {
      case "unsupported-setting": {
        let message = `${prefix} The "${warning.setting}" setting is not supported by this model`;
        if (warning.details) {
          message += ` - ${warning.details}`;
        }
        return message;
      }
      case "unsupported-tool": {
        const toolName = "name" in warning.tool ? warning.tool.name : "unknown tool";
        let message = `${prefix} The tool "${toolName}" is not supported by this model`;
        if (warning.details) {
          message += ` - ${warning.details}`;
        }
        return message;
      }
      case "other": {
        return `${prefix} ${warning.message}`;
      }
      default: {
        return `${prefix} ${JSON.stringify(warning, null, 2)}`;
      }
    }
  }
  var FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
  var hasLoggedBefore = false;
  var logWarnings = (warnings) => {
    if (warnings.length === 0) {
      return;
    }
    const logger = globalThis.AI_SDK_LOG_WARNINGS;
    if (logger === false) {
      return;
    }
    if (typeof logger === "function") {
      logger(warnings);
      return;
    }
    if (!hasLoggedBefore) {
      hasLoggedBefore = true;
      console.info(FIRST_WARNING_INFO_MESSAGE);
    }
    for (const warning of warnings) {
      console.warn(formatWarning(warning));
    }
  };
  var name2$1 = "AI_InvalidArgumentError";
  var marker2$1 = `vercel.ai.error.${name2$1}`;
  var symbol2$1 = Symbol.for(marker2$1);
  var _a2$1;
  var InvalidArgumentError$1 = class InvalidArgumentError extends AISDKError$1 {
    constructor({
      parameter,
      value,
      message
    }) {
      super({
        name: name2$1,
        message: `Invalid argument for parameter ${parameter}: ${message}`
      });
      this[_a2$1] = true;
      this.parameter = parameter;
      this.value = value;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker2$1);
    }
  };
  _a2$1 = symbol2$1;
  var name4 = "AI_InvalidToolInputError";
  var marker4$1 = `vercel.ai.error.${name4}`;
  var symbol4$1 = Symbol.for(marker4$1);
  var _a4$1;
  var InvalidToolInputError = class extends AISDKError$1 {
    constructor({
      toolInput,
      toolName,
      cause,
      message = `Invalid input for tool ${toolName}: ${getErrorMessage$2(cause)}`
    }) {
      super({ name: name4, message, cause });
      this[_a4$1] = true;
      this.toolInput = toolInput;
      this.toolName = toolName;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker4$1);
    }
  };
  _a4$1 = symbol4$1;
  var name7 = "AI_NoObjectGeneratedError";
  var marker7$1 = `vercel.ai.error.${name7}`;
  var symbol7$1 = Symbol.for(marker7$1);
  var _a7$1;
  var NoObjectGeneratedError = class extends AISDKError$1 {
    constructor({
      message = "No object generated.",
      cause,
      text: text2,
      response,
      usage,
      finishReason
    }) {
      super({ name: name7, message, cause });
      this[_a7$1] = true;
      this.text = text2;
      this.response = response;
      this.usage = usage;
      this.finishReason = finishReason;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker7$1);
    }
  };
  _a7$1 = symbol7$1;
  var name8 = "AI_NoOutputGeneratedError";
  var marker8 = `vercel.ai.error.${name8}`;
  var symbol8 = Symbol.for(marker8);
  var _a8;
  var NoOutputGeneratedError = class extends AISDKError$1 {
    // used in isInstance
    constructor({
      message = "No output generated.",
      cause
    } = {}) {
      super({ name: name8, message, cause });
      this[_a8] = true;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker8);
    }
  };
  _a8 = symbol8;
  var name9 = "AI_NoSuchToolError";
  var marker9 = `vercel.ai.error.${name9}`;
  var symbol9 = Symbol.for(marker9);
  var _a9;
  var NoSuchToolError = class extends AISDKError$1 {
    constructor({
      toolName,
      availableTools = void 0,
      message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`
    }) {
      super({ name: name9, message });
      this[_a9] = true;
      this.toolName = toolName;
      this.availableTools = availableTools;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker9);
    }
  };
  _a9 = symbol9;
  var name10 = "AI_ToolCallRepairError";
  var marker10 = `vercel.ai.error.${name10}`;
  var symbol10 = Symbol.for(marker10);
  var _a10;
  var ToolCallRepairError = class extends AISDKError$1 {
    constructor({
      cause,
      originalError,
      message = `Error repairing tool call: ${getErrorMessage$2(cause)}`
    }) {
      super({ name: name10, message, cause });
      this[_a10] = true;
      this.originalError = originalError;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker10);
    }
  };
  _a10 = symbol10;
  var UnsupportedModelVersionError = class extends AISDKError$1 {
    constructor(options) {
      super({
        name: "AI_UnsupportedModelVersionError",
        message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
      });
      this.version = options.version;
      this.provider = options.provider;
      this.modelId = options.modelId;
    }
  };
  var name12$1 = "AI_InvalidMessageRoleError";
  var marker12$1 = `vercel.ai.error.${name12$1}`;
  var symbol12$1 = Symbol.for(marker12$1);
  var _a12$1;
  var InvalidMessageRoleError = class extends AISDKError$1 {
    constructor({
      role,
      message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`
    }) {
      super({ name: name12$1, message });
      this[_a12$1] = true;
      this.role = role;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker12$1);
    }
  };
  _a12$1 = symbol12$1;
  var name14 = "AI_DownloadError";
  var marker14$1 = `vercel.ai.error.${name14}`;
  var symbol14$1 = Symbol.for(marker14$1);
  var _a14$1;
  var DownloadError = class extends AISDKError$1 {
    constructor({
      url,
      statusCode,
      statusText,
      cause,
      message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`
    }) {
      super({ name: name14, message, cause });
      this[_a14$1] = true;
      this.url = url;
      this.statusCode = statusCode;
      this.statusText = statusText;
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker14$1);
    }
  };
  _a14$1 = symbol14$1;
  var name15 = "AI_RetryError";
  var marker15 = `vercel.ai.error.${name15}`;
  var symbol15 = Symbol.for(marker15);
  var _a15;
  var RetryError = class extends AISDKError$1 {
    constructor({
      message,
      reason,
      errors
    }) {
      super({ name: name15, message });
      this[_a15] = true;
      this.reason = reason;
      this.errors = errors;
      this.lastError = errors[errors.length - 1];
    }
    static isInstance(error) {
      return AISDKError$1.hasMarker(error, marker15);
    }
  };
  _a15 = symbol15;

  // src/model/resolve-model.ts
  function resolveLanguageModel(model) {
    if (typeof model !== "string") {
      if (model.specificationVersion !== "v2") {
        throw new UnsupportedModelVersionError({
          version: model.specificationVersion,
          provider: model.provider,
          modelId: model.modelId
        });
      }
      return model;
    }
    return getGlobalProvider().languageModel(model);
  }
  function getGlobalProvider() {
    var _a17;
    return (_a17 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a17 : gateway;
  }
  var imageMediaTypeSignatures = [
    {
      mediaType: "image/gif",
      bytesPrefix: [71, 73, 70],
      base64Prefix: "R0lG"
    },
    {
      mediaType: "image/png",
      bytesPrefix: [137, 80, 78, 71],
      base64Prefix: "iVBORw"
    },
    {
      mediaType: "image/jpeg",
      bytesPrefix: [255, 216],
      base64Prefix: "/9j/"
    },
    {
      mediaType: "image/webp",
      bytesPrefix: [82, 73, 70, 70],
      base64Prefix: "UklGRg"
    },
    {
      mediaType: "image/bmp",
      bytesPrefix: [66, 77],
      base64Prefix: "Qk"
    },
    {
      mediaType: "image/tiff",
      bytesPrefix: [73, 73, 42, 0],
      base64Prefix: "SUkqAA"
    },
    {
      mediaType: "image/tiff",
      bytesPrefix: [77, 77, 0, 42],
      base64Prefix: "TU0AKg"
    },
    {
      mediaType: "image/avif",
      bytesPrefix: [
        0,
        0,
        0,
        32,
        102,
        116,
        121,
        112,
        97,
        118,
        105,
        102
      ],
      base64Prefix: "AAAAIGZ0eXBhdmlm"
    },
    {
      mediaType: "image/heic",
      bytesPrefix: [
        0,
        0,
        0,
        32,
        102,
        116,
        121,
        112,
        104,
        101,
        105,
        99
      ],
      base64Prefix: "AAAAIGZ0eXBoZWlj"
    }
  ];
  var stripID3 = (data) => {
    const bytes = typeof data === "string" ? convertBase64ToUint8Array(data) : data;
    const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
    return bytes.slice(id3Size + 10);
  };
  function stripID3TagsIfPresent(data) {
    const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
    data[1] === 68 && // 'D'
    data[2] === 51;
    return hasId3 ? stripID3(data) : data;
  }
  function detectMediaType({
    data,
    signatures
  }) {
    const processedData = stripID3TagsIfPresent(data);
    for (const signature of signatures) {
      if (typeof processedData === "string" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(
        (byte, index) => processedData[index] === byte
      )) {
        return signature.mediaType;
      }
    }
    return void 0;
  }

  // src/util/download/download.ts
  var download = async ({ url }) => {
    var _a17;
    const urlText = url.toString();
    try {
      const response = await fetch(urlText);
      if (!response.ok) {
        throw new DownloadError({
          url: urlText,
          statusCode: response.status,
          statusText: response.statusText
        });
      }
      return {
        data: new Uint8Array(await response.arrayBuffer()),
        mediaType: (_a17 = response.headers.get("content-type")) != null ? _a17 : void 0
      };
    } catch (error) {
      if (DownloadError.isInstance(error)) {
        throw error;
      }
      throw new DownloadError({ url: urlText, cause: error });
    }
  };

  // src/util/download/download-function.ts
  var createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(
    requestedDownloads.map(
      async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)
    )
  );

  // src/prompt/split-data-url.ts
  function splitDataUrl(dataUrl) {
    try {
      const [header, base64Content] = dataUrl.split(",");
      return {
        mediaType: header.split(";")[0].split(":")[1],
        base64Content
      };
    } catch (error) {
      return {
        mediaType: void 0,
        base64Content: void 0
      };
    }
  }

  // src/prompt/data-content.ts
  var dataContentSchema = union([
    string$1(),
    _instanceof(Uint8Array),
    _instanceof(ArrayBuffer),
    custom(
      // Buffer might not be available in some environments such as CloudFlare:
      (value) => {
        var _a17, _b;
        return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;
      },
      { message: "Must be a Buffer" }
    )
  ]);
  function convertToLanguageModelV2DataContent(content) {
    if (content instanceof Uint8Array) {
      return { data: content, mediaType: void 0 };
    }
    if (content instanceof ArrayBuffer) {
      return { data: new Uint8Array(content), mediaType: void 0 };
    }
    if (typeof content === "string") {
      try {
        content = new URL(content);
      } catch (error) {
      }
    }
    if (content instanceof URL && content.protocol === "data:") {
      const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(
        content.toString()
      );
      if (dataUrlMediaType == null || base64Content == null) {
        throw new AISDKError$1({
          name: "InvalidDataContentError",
          message: `Invalid data URL format in content ${content.toString()}`
        });
      }
      return { data: base64Content, mediaType: dataUrlMediaType };
    }
    return { data: content, mediaType: void 0 };
  }
  function convertDataContentToBase64String(content) {
    if (typeof content === "string") {
      return content;
    }
    if (content instanceof ArrayBuffer) {
      return convertUint8ArrayToBase64$1(new Uint8Array(content));
    }
    return convertUint8ArrayToBase64$1(content);
  }

  // src/prompt/convert-to-language-model-prompt.ts
  async function convertToLanguageModelPrompt({
    prompt,
    supportedUrls,
    download: download2 = createDefaultDownloadFunction()
  }) {
    const downloadedAssets = await downloadAssets(
      prompt.messages,
      download2,
      supportedUrls
    );
    return [
      ...prompt.system != null ? [{ role: "system", content: prompt.system }] : [],
      ...prompt.messages.map(
        (message) => convertToLanguageModelMessage({ message, downloadedAssets })
      )
    ];
  }
  function convertToLanguageModelMessage({
    message,
    downloadedAssets
  }) {
    const role = message.role;
    switch (role) {
      case "system": {
        return {
          role: "system",
          content: message.content,
          providerOptions: message.providerOptions
        };
      }
      case "user": {
        if (typeof message.content === "string") {
          return {
            role: "user",
            content: [{ type: "text", text: message.content }],
            providerOptions: message.providerOptions
          };
        }
        return {
          role: "user",
          content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== "text" || part.text !== ""),
          providerOptions: message.providerOptions
        };
      }
      case "assistant": {
        if (typeof message.content === "string") {
          return {
            role: "assistant",
            content: [{ type: "text", text: message.content }],
            providerOptions: message.providerOptions
          };
        }
        return {
          role: "assistant",
          content: message.content.filter(
            // remove empty text parts:
            (part) => part.type !== "text" || part.text !== ""
          ).map((part) => {
            const providerOptions = part.providerOptions;
            switch (part.type) {
              case "file": {
                const { data, mediaType } = convertToLanguageModelV2DataContent(
                  part.data
                );
                return {
                  type: "file",
                  data,
                  filename: part.filename,
                  mediaType: mediaType != null ? mediaType : part.mediaType,
                  providerOptions
                };
              }
              case "reasoning": {
                return {
                  type: "reasoning",
                  text: part.text,
                  providerOptions
                };
              }
              case "text": {
                return {
                  type: "text",
                  text: part.text,
                  providerOptions
                };
              }
              case "tool-call": {
                return {
                  type: "tool-call",
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  input: part.input,
                  providerExecuted: part.providerExecuted,
                  providerOptions
                };
              }
              case "tool-result": {
                return {
                  type: "tool-result",
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  output: part.output,
                  providerOptions
                };
              }
            }
          }),
          providerOptions: message.providerOptions
        };
      }
      case "tool": {
        return {
          role: "tool",
          content: message.content.map((part) => ({
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output: part.output,
            providerOptions: part.providerOptions
          })),
          providerOptions: message.providerOptions
        };
      }
      default: {
        const _exhaustiveCheck = role;
        throw new InvalidMessageRoleError({ role: _exhaustiveCheck });
      }
    }
  }
  async function downloadAssets(messages, download2, supportedUrls) {
    const plannedDownloads = messages.filter((message) => message.role === "user").map((message) => message.content).filter(
      (content) => Array.isArray(content)
    ).flat().filter(
      (part) => part.type === "image" || part.type === "file"
    ).map((part) => {
      var _a17;
      const mediaType = (_a17 = part.mediaType) != null ? _a17 : part.type === "image" ? "image/*" : void 0;
      let data = part.type === "image" ? part.image : part.data;
      if (typeof data === "string") {
        try {
          data = new URL(data);
        } catch (ignored) {
        }
      }
      return { mediaType, data };
    }).filter(
      (part) => part.data instanceof URL
    ).map((part) => ({
      url: part.data,
      isUrlSupportedByModel: part.mediaType != null && isUrlSupported({
        url: part.data.toString(),
        mediaType: part.mediaType,
        supportedUrls
      })
    }));
    const downloadedFiles = await download2(plannedDownloads);
    return Object.fromEntries(
      downloadedFiles.filter(
        (downloadedFile) => (downloadedFile == null ? void 0 : downloadedFile.data) != null
      ).map(({ data, mediaType }, index) => [
        plannedDownloads[index].url.toString(),
        { data, mediaType }
      ])
    );
  }
  function convertPartToLanguageModelPart(part, downloadedAssets) {
    var _a17;
    if (part.type === "text") {
      return {
        type: "text",
        text: part.text,
        providerOptions: part.providerOptions
      };
    }
    let originalData;
    const type = part.type;
    switch (type) {
      case "image":
        originalData = part.image;
        break;
      case "file":
        originalData = part.data;
        break;
      default:
        throw new Error(`Unsupported part type: ${type}`);
    }
    const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);
    let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;
    let data = convertedData;
    if (data instanceof URL) {
      const downloadedFile = downloadedAssets[data.toString()];
      if (downloadedFile) {
        data = downloadedFile.data;
        mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;
      }
    }
    switch (type) {
      case "image": {
        if (data instanceof Uint8Array || typeof data === "string") {
          mediaType = (_a17 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a17 : mediaType;
        }
        return {
          type: "file",
          mediaType: mediaType != null ? mediaType : "image/*",
          // any image
          filename: void 0,
          data,
          providerOptions: part.providerOptions
        };
      }
      case "file": {
        if (mediaType == null) {
          throw new Error(`Media type is missing for file part`);
        }
        return {
          type: "file",
          mediaType,
          filename: part.filename,
          data,
          providerOptions: part.providerOptions
        };
      }
    }
  }

  // src/prompt/prepare-call-settings.ts
  function prepareCallSettings({
    maxOutputTokens,
    temperature,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    seed,
    stopSequences
  }) {
    if (maxOutputTokens != null) {
      if (!Number.isInteger(maxOutputTokens)) {
        throw new InvalidArgumentError$1({
          parameter: "maxOutputTokens",
          value: maxOutputTokens,
          message: "maxOutputTokens must be an integer"
        });
      }
      if (maxOutputTokens < 1) {
        throw new InvalidArgumentError$1({
          parameter: "maxOutputTokens",
          value: maxOutputTokens,
          message: "maxOutputTokens must be >= 1"
        });
      }
    }
    if (temperature != null) {
      if (typeof temperature !== "number") {
        throw new InvalidArgumentError$1({
          parameter: "temperature",
          value: temperature,
          message: "temperature must be a number"
        });
      }
    }
    if (topP != null) {
      if (typeof topP !== "number") {
        throw new InvalidArgumentError$1({
          parameter: "topP",
          value: topP,
          message: "topP must be a number"
        });
      }
    }
    if (topK != null) {
      if (typeof topK !== "number") {
        throw new InvalidArgumentError$1({
          parameter: "topK",
          value: topK,
          message: "topK must be a number"
        });
      }
    }
    if (presencePenalty != null) {
      if (typeof presencePenalty !== "number") {
        throw new InvalidArgumentError$1({
          parameter: "presencePenalty",
          value: presencePenalty,
          message: "presencePenalty must be a number"
        });
      }
    }
    if (frequencyPenalty != null) {
      if (typeof frequencyPenalty !== "number") {
        throw new InvalidArgumentError$1({
          parameter: "frequencyPenalty",
          value: frequencyPenalty,
          message: "frequencyPenalty must be a number"
        });
      }
    }
    if (seed != null) {
      if (!Number.isInteger(seed)) {
        throw new InvalidArgumentError$1({
          parameter: "seed",
          value: seed,
          message: "seed must be an integer"
        });
      }
    }
    return {
      maxOutputTokens,
      temperature,
      topP,
      topK,
      presencePenalty,
      frequencyPenalty,
      stopSequences,
      seed
    };
  }

  // src/util/is-non-empty-object.ts
  function isNonEmptyObject(object2) {
    return object2 != null && Object.keys(object2).length > 0;
  }

  // src/prompt/prepare-tools-and-tool-choice.ts
  function prepareToolsAndToolChoice({
    tools,
    toolChoice,
    activeTools
  }) {
    if (!isNonEmptyObject(tools)) {
      return {
        tools: void 0,
        toolChoice: void 0
      };
    }
    const filteredTools = activeTools != null ? Object.entries(tools).filter(
      ([name17]) => activeTools.includes(name17)
    ) : Object.entries(tools);
    return {
      tools: filteredTools.map(([name17, tool3]) => {
        const toolType = tool3.type;
        switch (toolType) {
          case void 0:
          case "dynamic":
          case "function":
            return {
              type: "function",
              name: name17,
              description: tool3.description,
              inputSchema: asSchema(tool3.inputSchema).jsonSchema,
              providerOptions: tool3.providerOptions
            };
          case "provider-defined":
            return {
              type: "provider-defined",
              name: name17,
              id: tool3.id,
              args: tool3.args
            };
          default: {
            const exhaustiveCheck = toolType;
            throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
          }
        }
      }),
      toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName }
    };
  }
  var jsonValueSchema = lazy(
    () => union([
      _null(),
      string$1(),
      number$1(),
      boolean$1(),
      record(string$1(), jsonValueSchema),
      array(jsonValueSchema)
    ])
  );

  // src/types/provider-metadata.ts
  var providerMetadataSchema = record(
    string$1(),
    record(string$1(), jsonValueSchema)
  );
  var textPartSchema = object$1({
    type: literal("text"),
    text: string$1(),
    providerOptions: providerMetadataSchema.optional()
  });
  var imagePartSchema = object$1({
    type: literal("image"),
    image: union([dataContentSchema, _instanceof(URL)]),
    mediaType: string$1().optional(),
    providerOptions: providerMetadataSchema.optional()
  });
  var filePartSchema = object$1({
    type: literal("file"),
    data: union([dataContentSchema, _instanceof(URL)]),
    filename: string$1().optional(),
    mediaType: string$1(),
    providerOptions: providerMetadataSchema.optional()
  });
  var reasoningPartSchema = object$1({
    type: literal("reasoning"),
    text: string$1(),
    providerOptions: providerMetadataSchema.optional()
  });
  var toolCallPartSchema = object$1({
    type: literal("tool-call"),
    toolCallId: string$1(),
    toolName: string$1(),
    input: unknown(),
    providerOptions: providerMetadataSchema.optional(),
    providerExecuted: boolean$1().optional()
  });
  var outputSchema = discriminatedUnion("type", [
    object$1({
      type: literal("text"),
      value: string$1()
    }),
    object$1({
      type: literal("json"),
      value: jsonValueSchema
    }),
    object$1({
      type: literal("error-text"),
      value: string$1()
    }),
    object$1({
      type: literal("error-json"),
      value: jsonValueSchema
    }),
    object$1({
      type: literal("content"),
      value: array(
        union([
          object$1({
            type: literal("text"),
            text: string$1()
          }),
          object$1({
            type: literal("media"),
            data: string$1(),
            mediaType: string$1()
          })
        ])
      )
    })
  ]);
  var toolResultPartSchema = object$1({
    type: literal("tool-result"),
    toolCallId: string$1(),
    toolName: string$1(),
    output: outputSchema,
    providerOptions: providerMetadataSchema.optional()
  });

  // src/prompt/message.ts
  var systemModelMessageSchema = object$1(
    {
      role: literal("system"),
      content: string$1(),
      providerOptions: providerMetadataSchema.optional()
    }
  );
  var userModelMessageSchema = object$1({
    role: literal("user"),
    content: union([
      string$1(),
      array(union([textPartSchema, imagePartSchema, filePartSchema]))
    ]),
    providerOptions: providerMetadataSchema.optional()
  });
  var assistantModelMessageSchema = object$1({
    role: literal("assistant"),
    content: union([
      string$1(),
      array(
        union([
          textPartSchema,
          filePartSchema,
          reasoningPartSchema,
          toolCallPartSchema,
          toolResultPartSchema
        ])
      )
    ]),
    providerOptions: providerMetadataSchema.optional()
  });
  var toolModelMessageSchema = object$1({
    role: literal("tool"),
    content: array(toolResultPartSchema),
    providerOptions: providerMetadataSchema.optional()
  });
  var modelMessageSchema = union([
    systemModelMessageSchema,
    userModelMessageSchema,
    assistantModelMessageSchema,
    toolModelMessageSchema
  ]);

  // src/prompt/standardize-prompt.ts
  async function standardizePrompt(prompt) {
    if (prompt.prompt == null && prompt.messages == null) {
      throw new InvalidPromptError({
        prompt,
        message: "prompt or messages must be defined"
      });
    }
    if (prompt.prompt != null && prompt.messages != null) {
      throw new InvalidPromptError({
        prompt,
        message: "prompt and messages cannot be defined at the same time"
      });
    }
    if (prompt.system != null && typeof prompt.system !== "string") {
      throw new InvalidPromptError({
        prompt,
        message: "system must be a string"
      });
    }
    let messages;
    if (prompt.prompt != null && typeof prompt.prompt === "string") {
      messages = [{ role: "user", content: prompt.prompt }];
    } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {
      messages = prompt.prompt;
    } else if (prompt.messages != null) {
      messages = prompt.messages;
    } else {
      throw new InvalidPromptError({
        prompt,
        message: "prompt or messages must be defined"
      });
    }
    if (messages.length === 0) {
      throw new InvalidPromptError({
        prompt,
        message: "messages must not be empty"
      });
    }
    const validationResult = await safeValidateTypes$1({
      value: messages,
      schema: array(modelMessageSchema)
    });
    if (!validationResult.success) {
      throw new InvalidPromptError({
        prompt,
        message: "The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.",
        cause: validationResult.error
      });
    }
    return {
      messages,
      system: prompt.system
    };
  }
  function wrapGatewayError(error) {
    if (GatewayAuthenticationError.isInstance(error) || GatewayModelNotFoundError.isInstance(error)) {
      return new AISDKError$1({
        name: "GatewayError",
        message: "Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.",
        cause: error
      });
    }
    return error;
  }

  // src/telemetry/assemble-operation-name.ts
  function assembleOperationName({
    operationId,
    telemetry
  }) {
    return {
      // standardized operation and resource name:
      "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
      "resource.name": telemetry == null ? void 0 : telemetry.functionId,
      // detailed, AI SDK specific data:
      "ai.operationId": operationId,
      "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
    };
  }

  // src/telemetry/get-base-telemetry-attributes.ts
  function getBaseTelemetryAttributes({
    model,
    settings,
    telemetry,
    headers
  }) {
    var _a17;
    return {
      "ai.model.provider": model.provider,
      "ai.model.id": model.modelId,
      // settings:
      ...Object.entries(settings).reduce((attributes, [key, value]) => {
        attributes[`ai.settings.${key}`] = value;
        return attributes;
      }, {}),
      // add metadata as attributes:
      ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce(
        (attributes, [key, value]) => {
          attributes[`ai.telemetry.metadata.${key}`] = value;
          return attributes;
        },
        {}
      ),
      // request headers
      ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
        if (value !== void 0) {
          attributes[`ai.request.headers.${key}`] = value;
        }
        return attributes;
      }, {})
    };
  }

  // src/telemetry/noop-tracer.ts
  var noopTracer = {
    startSpan() {
      return noopSpan;
    },
    startActiveSpan(name17, arg1, arg2, arg3) {
      if (typeof arg1 === "function") {
        return arg1(noopSpan);
      }
      if (typeof arg2 === "function") {
        return arg2(noopSpan);
      }
      if (typeof arg3 === "function") {
        return arg3(noopSpan);
      }
    }
  };
  var noopSpan = {
    spanContext() {
      return noopSpanContext;
    },
    setAttribute() {
      return this;
    },
    setAttributes() {
      return this;
    },
    addEvent() {
      return this;
    },
    addLink() {
      return this;
    },
    addLinks() {
      return this;
    },
    setStatus() {
      return this;
    },
    updateName() {
      return this;
    },
    end() {
      return this;
    },
    isRecording() {
      return false;
    },
    recordException() {
      return this;
    }
  };
  var noopSpanContext = {
    traceId: "",
    spanId: "",
    traceFlags: 0
  };

  // src/telemetry/get-tracer.ts
  function getTracer({
    isEnabled = false,
    tracer
  } = {}) {
    if (!isEnabled) {
      return noopTracer;
    }
    if (tracer) {
      return tracer;
    }
    return trace.getTracer("ai");
  }
  function recordSpan({
    name: name17,
    tracer,
    attributes,
    fn,
    endWhenDone = true
  }) {
    return tracer.startActiveSpan(name17, { attributes }, async (span) => {
      try {
        const result = await fn(span);
        if (endWhenDone) {
          span.end();
        }
        return result;
      } catch (error) {
        try {
          recordErrorOnSpan(span, error);
        } finally {
          span.end();
        }
        throw error;
      }
    });
  }
  function recordErrorOnSpan(span, error) {
    if (error instanceof Error) {
      span.recordException({
        name: error.name,
        message: error.message,
        stack: error.stack
      });
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error.message
      });
    } else {
      span.setStatus({ code: SpanStatusCode.ERROR });
    }
  }

  // src/telemetry/select-telemetry-attributes.ts
  function selectTelemetryAttributes({
    telemetry,
    attributes
  }) {
    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
      return {};
    }
    return Object.entries(attributes).reduce((attributes2, [key, value]) => {
      if (value == null) {
        return attributes2;
      }
      if (typeof value === "object" && "input" in value && typeof value.input === "function") {
        if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
          return attributes2;
        }
        const result = value.input();
        return result == null ? attributes2 : { ...attributes2, [key]: result };
      }
      if (typeof value === "object" && "output" in value && typeof value.output === "function") {
        if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
          return attributes2;
        }
        const result = value.output();
        return result == null ? attributes2 : { ...attributes2, [key]: result };
      }
      return { ...attributes2, [key]: value };
    }, {});
  }

  // src/telemetry/stringify-for-telemetry.ts
  function stringifyForTelemetry(prompt) {
    return JSON.stringify(
      prompt.map((message) => ({
        ...message,
        content: typeof message.content === "string" ? message.content : message.content.map(
          (part) => part.type === "file" ? {
            ...part,
            data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data
          } : part
        )
      }))
    );
  }

  // src/types/usage.ts
  function addLanguageModelUsage(usage1, usage2) {
    return {
      inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
      outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
      totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),
      reasoningTokens: addTokenCounts(
        usage1.reasoningTokens,
        usage2.reasoningTokens
      ),
      cachedInputTokens: addTokenCounts(
        usage1.cachedInputTokens,
        usage2.cachedInputTokens
      )
    };
  }
  function addTokenCounts(tokenCount1, tokenCount2) {
    return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);
  }

  // src/util/as-array.ts
  function asArray(value) {
    return value === void 0 ? [] : Array.isArray(value) ? value : [value];
  }
  function getRetryDelayInMs({
    error,
    exponentialBackoffDelay
  }) {
    const headers = error.responseHeaders;
    if (!headers)
      return exponentialBackoffDelay;
    let ms;
    const retryAfterMs = headers["retry-after-ms"];
    if (retryAfterMs) {
      const timeoutMs = parseFloat(retryAfterMs);
      if (!Number.isNaN(timeoutMs)) {
        ms = timeoutMs;
      }
    }
    const retryAfter = headers["retry-after"];
    if (retryAfter && ms === void 0) {
      const timeoutSeconds = parseFloat(retryAfter);
      if (!Number.isNaN(timeoutSeconds)) {
        ms = timeoutSeconds * 1e3;
      } else {
        ms = Date.parse(retryAfter) - Date.now();
      }
    }
    if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {
      return ms;
    }
    return exponentialBackoffDelay;
  }
  var retryWithExponentialBackoffRespectingRetryHeaders = ({
    maxRetries = 2,
    initialDelayInMs = 2e3,
    backoffFactor = 2,
    abortSignal
  } = {}) => async (f) => _retryWithExponentialBackoff(f, {
    maxRetries,
    delayInMs: initialDelayInMs,
    backoffFactor,
    abortSignal
  });
  async function _retryWithExponentialBackoff(f, {
    maxRetries,
    delayInMs,
    backoffFactor,
    abortSignal
  }, errors = []) {
    try {
      return await f();
    } catch (error) {
      if (isAbortError$1(error)) {
        throw error;
      }
      if (maxRetries === 0) {
        throw error;
      }
      const errorMessage = getErrorMessage$1(error);
      const newErrors = [...errors, error];
      const tryNumber = newErrors.length;
      if (tryNumber > maxRetries) {
        throw new RetryError({
          message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
          reason: "maxRetriesExceeded",
          errors: newErrors
        });
      }
      if (error instanceof Error && APICallError$1.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
        await delay(
          getRetryDelayInMs({
            error,
            exponentialBackoffDelay: delayInMs
          }),
          { abortSignal }
        );
        return _retryWithExponentialBackoff(
          f,
          {
            maxRetries,
            delayInMs: backoffFactor * delayInMs,
            backoffFactor,
            abortSignal
          },
          newErrors
        );
      }
      if (tryNumber === 1) {
        throw error;
      }
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
        reason: "errorNotRetryable",
        errors: newErrors
      });
    }
  }

  // src/util/prepare-retries.ts
  function prepareRetries({
    maxRetries,
    abortSignal
  }) {
    if (maxRetries != null) {
      if (!Number.isInteger(maxRetries)) {
        throw new InvalidArgumentError$1({
          parameter: "maxRetries",
          value: maxRetries,
          message: "maxRetries must be an integer"
        });
      }
      if (maxRetries < 0) {
        throw new InvalidArgumentError$1({
          parameter: "maxRetries",
          value: maxRetries,
          message: "maxRetries must be >= 0"
        });
      }
    }
    const maxRetriesResult = maxRetries != null ? maxRetries : 2;
    return {
      maxRetries: maxRetriesResult,
      retry: retryWithExponentialBackoffRespectingRetryHeaders({
        maxRetries: maxRetriesResult,
        abortSignal
      })
    };
  }

  // src/generate-text/extract-text-content.ts
  function extractTextContent$1(content) {
    const parts = content.filter(
      (content2) => content2.type === "text"
    );
    if (parts.length === 0) {
      return void 0;
    }
    return parts.map((content2) => content2.text).join("");
  }
  var DefaultGeneratedFile = class {
    constructor({
      data,
      mediaType
    }) {
      const isUint8Array = data instanceof Uint8Array;
      this.base64Data = isUint8Array ? void 0 : data;
      this.uint8ArrayData = isUint8Array ? data : void 0;
      this.mediaType = mediaType;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get base64() {
      if (this.base64Data == null) {
        this.base64Data = convertUint8ArrayToBase64$1(this.uint8ArrayData);
      }
      return this.base64Data;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get uint8Array() {
      if (this.uint8ArrayData == null) {
        this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
      }
      return this.uint8ArrayData;
    }
  };
  var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
    constructor(options) {
      super(options);
      this.type = "file";
    }
  };
  async function parseToolCall({
    toolCall,
    tools,
    repairToolCall,
    system,
    messages
  }) {
    try {
      if (tools == null) {
        throw new NoSuchToolError({ toolName: toolCall.toolName });
      }
      try {
        return await doParseToolCall({ toolCall, tools });
      } catch (error) {
        if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {
          throw error;
        }
        let repairedToolCall = null;
        try {
          repairedToolCall = await repairToolCall({
            toolCall,
            tools,
            inputSchema: ({ toolName }) => {
              const { inputSchema } = tools[toolName];
              return asSchema(inputSchema).jsonSchema;
            },
            system,
            messages,
            error
          });
        } catch (repairError) {
          throw new ToolCallRepairError({
            cause: repairError,
            originalError: error
          });
        }
        if (repairedToolCall == null) {
          throw error;
        }
        return await doParseToolCall({ toolCall: repairedToolCall, tools });
      }
    } catch (error) {
      const parsedInput = await safeParseJSON$1({ text: toolCall.input });
      const input = parsedInput.success ? parsedInput.value : toolCall.input;
      return {
        type: "tool-call",
        toolCallId: toolCall.toolCallId,
        toolName: toolCall.toolName,
        input,
        dynamic: true,
        invalid: true,
        error
      };
    }
  }
  async function doParseToolCall({
    toolCall,
    tools
  }) {
    const toolName = toolCall.toolName;
    const tool3 = tools[toolName];
    if (tool3 == null) {
      throw new NoSuchToolError({
        toolName: toolCall.toolName,
        availableTools: Object.keys(tools)
      });
    }
    const schema = asSchema(tool3.inputSchema);
    const parseResult = toolCall.input.trim() === "" ? await safeValidateTypes$1({ value: {}, schema }) : await safeParseJSON$1({ text: toolCall.input, schema });
    if (parseResult.success === false) {
      throw new InvalidToolInputError({
        toolName,
        toolInput: toolCall.input,
        cause: parseResult.error
      });
    }
    return tool3.type === "dynamic" ? {
      type: "tool-call",
      toolCallId: toolCall.toolCallId,
      toolName: toolCall.toolName,
      input: parseResult.value,
      providerExecuted: toolCall.providerExecuted,
      providerMetadata: toolCall.providerMetadata,
      dynamic: true
    } : {
      type: "tool-call",
      toolCallId: toolCall.toolCallId,
      toolName,
      input: parseResult.value,
      providerExecuted: toolCall.providerExecuted,
      providerMetadata: toolCall.providerMetadata
    };
  }

  // src/generate-text/step-result.ts
  var DefaultStepResult = class {
    constructor({
      content,
      finishReason,
      usage,
      warnings,
      request,
      response,
      providerMetadata
    }) {
      this.content = content;
      this.finishReason = finishReason;
      this.usage = usage;
      this.warnings = warnings;
      this.request = request;
      this.response = response;
      this.providerMetadata = providerMetadata;
    }
    get text() {
      return this.content.filter((part) => part.type === "text").map((part) => part.text).join("");
    }
    get reasoning() {
      return this.content.filter((part) => part.type === "reasoning");
    }
    get reasoningText() {
      return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join("");
    }
    get files() {
      return this.content.filter((part) => part.type === "file").map((part) => part.file);
    }
    get sources() {
      return this.content.filter((part) => part.type === "source");
    }
    get toolCalls() {
      return this.content.filter((part) => part.type === "tool-call");
    }
    get staticToolCalls() {
      return this.toolCalls.filter(
        (toolCall) => toolCall.dynamic === false
      );
    }
    get dynamicToolCalls() {
      return this.toolCalls.filter(
        (toolCall) => toolCall.dynamic === true
      );
    }
    get toolResults() {
      return this.content.filter((part) => part.type === "tool-result");
    }
    get staticToolResults() {
      return this.toolResults.filter(
        (toolResult) => toolResult.dynamic === false
      );
    }
    get dynamicToolResults() {
      return this.toolResults.filter(
        (toolResult) => toolResult.dynamic === true
      );
    }
  };

  // src/generate-text/stop-condition.ts
  function stepCountIs(stepCount) {
    return ({ steps }) => steps.length === stepCount;
  }
  async function isStopConditionMet({
    stopConditions,
    steps
  }) {
    return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);
  }
  function createToolModelOutput({
    output,
    tool: tool3,
    errorMode
  }) {
    if (errorMode === "text") {
      return { type: "error-text", value: getErrorMessage$2(output) };
    } else if (errorMode === "json") {
      return { type: "error-json", value: toJSONValue(output) };
    }
    if (tool3 == null ? void 0 : tool3.toModelOutput) {
      return tool3.toModelOutput(output);
    }
    return typeof output === "string" ? { type: "text", value: output } : { type: "json", value: toJSONValue(output) };
  }
  function toJSONValue(value) {
    return value === void 0 ? null : value;
  }

  // src/generate-text/to-response-messages.ts
  function toResponseMessages({
    content: inputContent,
    tools
  }) {
    const responseMessages = [];
    const content = inputContent.filter((part) => part.type !== "source").filter(
      (part) => (part.type !== "tool-result" || part.providerExecuted) && (part.type !== "tool-error" || part.providerExecuted)
    ).filter((part) => part.type !== "text" || part.text.length > 0).map((part) => {
      switch (part.type) {
        case "text":
          return {
            type: "text",
            text: part.text,
            providerOptions: part.providerMetadata
          };
        case "reasoning":
          return {
            type: "reasoning",
            text: part.text,
            providerOptions: part.providerMetadata
          };
        case "file":
          return {
            type: "file",
            data: part.file.base64,
            mediaType: part.file.mediaType,
            providerOptions: part.providerMetadata
          };
        case "tool-call":
          return {
            type: "tool-call",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            input: part.input,
            providerExecuted: part.providerExecuted,
            providerOptions: part.providerMetadata
          };
        case "tool-result":
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output: createToolModelOutput({
              tool: tools == null ? void 0 : tools[part.toolName],
              output: part.output,
              errorMode: "none"
            }),
            providerExecuted: true,
            providerOptions: part.providerMetadata
          };
        case "tool-error":
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output: createToolModelOutput({
              tool: tools == null ? void 0 : tools[part.toolName],
              output: part.error,
              errorMode: "json"
            }),
            providerOptions: part.providerMetadata
          };
      }
    });
    if (content.length > 0) {
      responseMessages.push({
        role: "assistant",
        content
      });
    }
    const toolResultContent = inputContent.filter((part) => part.type === "tool-result" || part.type === "tool-error").filter((part) => !part.providerExecuted).map((toolResult) => ({
      type: "tool-result",
      toolCallId: toolResult.toolCallId,
      toolName: toolResult.toolName,
      output: createToolModelOutput({
        tool: tools == null ? void 0 : tools[toolResult.toolName],
        output: toolResult.type === "tool-result" ? toolResult.output : toolResult.error,
        errorMode: toolResult.type === "tool-error" ? "text" : "none"
      })
    }));
    if (toolResultContent.length > 0) {
      responseMessages.push({
        role: "tool",
        content: toolResultContent
      });
    }
    return responseMessages;
  }

  // src/generate-text/generate-text.ts
  var originalGenerateId = createIdGenerator$1({
    prefix: "aitxt",
    size: 24
  });
  async function generateText({
    model: modelArg,
    tools,
    toolChoice,
    system,
    prompt,
    messages,
    maxRetries: maxRetriesArg,
    abortSignal,
    headers,
    stopWhen = stepCountIs(1),
    experimental_output: output,
    experimental_telemetry: telemetry,
    providerOptions,
    experimental_activeTools,
    activeTools = experimental_activeTools,
    experimental_prepareStep,
    prepareStep = experimental_prepareStep,
    experimental_repairToolCall: repairToolCall,
    experimental_download: download2,
    experimental_context,
    _internal: {
      generateId: generateId3 = originalGenerateId,
      currentDate = () => /* @__PURE__ */ new Date()
    } = {},
    onStepFinish,
    ...settings
  }) {
    const model = resolveLanguageModel(modelArg);
    const stopConditions = asArray(stopWhen);
    const { maxRetries, retry } = prepareRetries({
      maxRetries: maxRetriesArg,
      abortSignal
    });
    const callSettings = prepareCallSettings(settings);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
      model,
      telemetry,
      headers,
      settings: { ...callSettings, maxRetries }
    });
    const initialPrompt = await standardizePrompt({
      system,
      prompt,
      messages
    });
    const tracer = getTracer(telemetry);
    try {
      return await recordSpan({
        name: "ai.generateText",
        attributes: selectTelemetryAttributes({
          telemetry,
          attributes: {
            ...assembleOperationName({
              operationId: "ai.generateText",
              telemetry
            }),
            ...baseTelemetryAttributes,
            // model:
            "ai.model.provider": model.provider,
            "ai.model.id": model.modelId,
            // specific settings that only make sense on the outer level:
            "ai.prompt": {
              input: () => JSON.stringify({ system, prompt, messages })
            }
          }
        }),
        tracer,
        fn: async (span) => {
          var _a17, _b, _c, _d, _e, _f, _g;
          const callSettings2 = prepareCallSettings(settings);
          let currentModelResponse;
          let clientToolCalls = [];
          let clientToolOutputs = [];
          const responseMessages = [];
          const steps = [];
          do {
            const stepInputMessages = [
              ...initialPrompt.messages,
              ...responseMessages
            ];
            const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
              model,
              steps,
              stepNumber: steps.length,
              messages: stepInputMessages
            }));
            const promptMessages = await convertToLanguageModelPrompt({
              prompt: {
                system: (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a17 : initialPrompt.system,
                messages: (_b = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _b : stepInputMessages
              },
              supportedUrls: await model.supportedUrls,
              download: download2
            });
            const stepModel = resolveLanguageModel(
              (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model
            );
            const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({
              tools,
              toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,
              activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools
            });
            currentModelResponse = await retry(
              () => {
                var _a18;
                return recordSpan({
                  name: "ai.generateText.doGenerate",
                  attributes: selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      ...assembleOperationName({
                        operationId: "ai.generateText.doGenerate",
                        telemetry
                      }),
                      ...baseTelemetryAttributes,
                      // model:
                      "ai.model.provider": stepModel.provider,
                      "ai.model.id": stepModel.modelId,
                      // prompt:
                      "ai.prompt.messages": {
                        input: () => stringifyForTelemetry(promptMessages)
                      },
                      "ai.prompt.tools": {
                        // convert the language model level tools:
                        input: () => stepTools == null ? void 0 : stepTools.map((tool3) => JSON.stringify(tool3))
                      },
                      "ai.prompt.toolChoice": {
                        input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                      },
                      // standardized gen-ai llm span attributes:
                      "gen_ai.system": stepModel.provider,
                      "gen_ai.request.model": stepModel.modelId,
                      "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                      "gen_ai.request.max_tokens": settings.maxOutputTokens,
                      "gen_ai.request.presence_penalty": settings.presencePenalty,
                      "gen_ai.request.stop_sequences": settings.stopSequences,
                      "gen_ai.request.temperature": (_a18 = settings.temperature) != null ? _a18 : void 0,
                      "gen_ai.request.top_k": settings.topK,
                      "gen_ai.request.top_p": settings.topP
                    }
                  }),
                  tracer,
                  fn: async (span2) => {
                    var _a19, _b2, _c2, _d2, _e2, _f2, _g2, _h;
                    const result = await stepModel.doGenerate({
                      ...callSettings2,
                      tools: stepTools,
                      toolChoice: stepToolChoice,
                      responseFormat: output == null ? void 0 : output.responseFormat,
                      prompt: promptMessages,
                      providerOptions,
                      abortSignal,
                      headers
                    });
                    const responseData = {
                      id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId3(),
                      timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),
                      modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,
                      headers: (_g2 = result.response) == null ? void 0 : _g2.headers,
                      body: (_h = result.response) == null ? void 0 : _h.body
                    };
                    span2.setAttributes(
                      selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                          "ai.response.finishReason": result.finishReason,
                          "ai.response.text": {
                            output: () => extractTextContent$1(result.content)
                          },
                          "ai.response.toolCalls": {
                            output: () => {
                              const toolCalls = asToolCalls(result.content);
                              return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                            }
                          },
                          "ai.response.id": responseData.id,
                          "ai.response.model": responseData.modelId,
                          "ai.response.timestamp": responseData.timestamp.toISOString(),
                          "ai.response.providerMetadata": JSON.stringify(
                            result.providerMetadata
                          ),
                          // TODO rename telemetry attributes to inputTokens and outputTokens
                          "ai.usage.promptTokens": result.usage.inputTokens,
                          "ai.usage.completionTokens": result.usage.outputTokens,
                          // standardized gen-ai llm span attributes:
                          "gen_ai.response.finish_reasons": [result.finishReason],
                          "gen_ai.response.id": responseData.id,
                          "gen_ai.response.model": responseData.modelId,
                          "gen_ai.usage.input_tokens": result.usage.inputTokens,
                          "gen_ai.usage.output_tokens": result.usage.outputTokens
                        }
                      })
                    );
                    return { ...result, response: responseData };
                  }
                });
              }
            );
            const stepToolCalls = await Promise.all(
              currentModelResponse.content.filter(
                (part) => part.type === "tool-call"
              ).map(
                (toolCall) => parseToolCall({
                  toolCall,
                  tools,
                  repairToolCall,
                  system,
                  messages: stepInputMessages
                })
              )
            );
            for (const toolCall of stepToolCalls) {
              if (toolCall.invalid) {
                continue;
              }
              const tool3 = tools[toolCall.toolName];
              if ((tool3 == null ? void 0 : tool3.onInputAvailable) != null) {
                await tool3.onInputAvailable({
                  input: toolCall.input,
                  toolCallId: toolCall.toolCallId,
                  messages: stepInputMessages,
                  abortSignal,
                  experimental_context
                });
              }
            }
            const invalidToolCalls = stepToolCalls.filter(
              (toolCall) => toolCall.invalid && toolCall.dynamic
            );
            clientToolOutputs = [];
            for (const toolCall of invalidToolCalls) {
              clientToolOutputs.push({
                type: "tool-error",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                input: toolCall.input,
                error: getErrorMessage$1(toolCall.error),
                dynamic: true
              });
            }
            clientToolCalls = stepToolCalls.filter(
              (toolCall) => !toolCall.providerExecuted
            );
            if (tools != null) {
              clientToolOutputs.push(
                ...await executeTools({
                  toolCalls: clientToolCalls.filter(
                    (toolCall) => !toolCall.invalid
                  ),
                  tools,
                  tracer,
                  telemetry,
                  messages: stepInputMessages,
                  abortSignal,
                  experimental_context
                })
              );
            }
            const stepContent = asContent({
              content: currentModelResponse.content,
              toolCalls: stepToolCalls,
              toolOutputs: clientToolOutputs
            });
            responseMessages.push(
              ...toResponseMessages({
                content: stepContent,
                tools
              })
            );
            const currentStepResult = new DefaultStepResult({
              content: stepContent,
              finishReason: currentModelResponse.finishReason,
              usage: currentModelResponse.usage,
              warnings: currentModelResponse.warnings,
              providerMetadata: currentModelResponse.providerMetadata,
              request: (_f = currentModelResponse.request) != null ? _f : {},
              response: {
                ...currentModelResponse.response,
                // deep clone msgs to avoid mutating past messages in multi-step:
                messages: structuredClone(responseMessages)
              }
            });
            logWarnings((_g = currentModelResponse.warnings) != null ? _g : []);
            steps.push(currentStepResult);
            await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
          } while (
            // there are tool calls:
            clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):
            clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:
            !await isStopConditionMet({ stopConditions, steps })
          );
          span.setAttributes(
            selectTelemetryAttributes({
              telemetry,
              attributes: {
                "ai.response.finishReason": currentModelResponse.finishReason,
                "ai.response.text": {
                  output: () => extractTextContent$1(currentModelResponse.content)
                },
                "ai.response.toolCalls": {
                  output: () => {
                    const toolCalls = asToolCalls(currentModelResponse.content);
                    return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                  }
                },
                "ai.response.providerMetadata": JSON.stringify(
                  currentModelResponse.providerMetadata
                ),
                // TODO rename telemetry attributes to inputTokens and outputTokens
                "ai.usage.promptTokens": currentModelResponse.usage.inputTokens,
                "ai.usage.completionTokens": currentModelResponse.usage.outputTokens
              }
            })
          );
          const lastStep = steps[steps.length - 1];
          return new DefaultGenerateTextResult({
            steps,
            resolvedOutput: await (output == null ? void 0 : output.parseOutput(
              { text: lastStep.text },
              {
                response: lastStep.response,
                usage: lastStep.usage,
                finishReason: lastStep.finishReason
              }
            ))
          });
        }
      });
    } catch (error) {
      throw wrapGatewayError(error);
    }
  }
  async function executeTools({
    toolCalls,
    tools,
    tracer,
    telemetry,
    messages,
    abortSignal,
    experimental_context
  }) {
    const toolOutputs = await Promise.all(
      toolCalls.map(async ({ toolCallId, toolName, input }) => {
        const tool3 = tools[toolName];
        if ((tool3 == null ? void 0 : tool3.execute) == null) {
          return void 0;
        }
        return recordSpan({
          name: "ai.toolCall",
          attributes: selectTelemetryAttributes({
            telemetry,
            attributes: {
              ...assembleOperationName({
                operationId: "ai.toolCall",
                telemetry
              }),
              "ai.toolCall.name": toolName,
              "ai.toolCall.id": toolCallId,
              "ai.toolCall.args": {
                output: () => JSON.stringify(input)
              }
            }
          }),
          tracer,
          fn: async (span) => {
            try {
              const stream = executeTool({
                execute: tool3.execute.bind(tool3),
                input,
                options: {
                  toolCallId,
                  messages,
                  abortSignal,
                  experimental_context
                }
              });
              let output;
              for await (const part of stream) {
                if (part.type === "final") {
                  output = part.output;
                }
              }
              try {
                span.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.toolCall.result": {
                        output: () => JSON.stringify(output)
                      }
                    }
                  })
                );
              } catch (ignored) {
              }
              return {
                type: "tool-result",
                toolCallId,
                toolName,
                input,
                output,
                dynamic: tool3.type === "dynamic"
              };
            } catch (error) {
              recordErrorOnSpan(span, error);
              return {
                type: "tool-error",
                toolCallId,
                toolName,
                input,
                error,
                dynamic: tool3.type === "dynamic"
              };
            }
          }
        });
      })
    );
    return toolOutputs.filter(
      (output) => output != null
    );
  }
  var DefaultGenerateTextResult = class {
    constructor(options) {
      this.steps = options.steps;
      this.resolvedOutput = options.resolvedOutput;
    }
    get finalStep() {
      return this.steps[this.steps.length - 1];
    }
    get content() {
      return this.finalStep.content;
    }
    get text() {
      return this.finalStep.text;
    }
    get files() {
      return this.finalStep.files;
    }
    get reasoningText() {
      return this.finalStep.reasoningText;
    }
    get reasoning() {
      return this.finalStep.reasoning;
    }
    get toolCalls() {
      return this.finalStep.toolCalls;
    }
    get staticToolCalls() {
      return this.finalStep.staticToolCalls;
    }
    get dynamicToolCalls() {
      return this.finalStep.dynamicToolCalls;
    }
    get toolResults() {
      return this.finalStep.toolResults;
    }
    get staticToolResults() {
      return this.finalStep.staticToolResults;
    }
    get dynamicToolResults() {
      return this.finalStep.dynamicToolResults;
    }
    get sources() {
      return this.finalStep.sources;
    }
    get finishReason() {
      return this.finalStep.finishReason;
    }
    get warnings() {
      return this.finalStep.warnings;
    }
    get providerMetadata() {
      return this.finalStep.providerMetadata;
    }
    get response() {
      return this.finalStep.response;
    }
    get request() {
      return this.finalStep.request;
    }
    get usage() {
      return this.finalStep.usage;
    }
    get totalUsage() {
      return this.steps.reduce(
        (totalUsage, step) => {
          return addLanguageModelUsage(totalUsage, step.usage);
        },
        {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0,
          reasoningTokens: void 0,
          cachedInputTokens: void 0
        }
      );
    }
    get experimental_output() {
      if (this.resolvedOutput == null) {
        throw new NoOutputSpecifiedError();
      }
      return this.resolvedOutput;
    }
  };
  function asToolCalls(content) {
    const parts = content.filter(
      (part) => part.type === "tool-call"
    );
    if (parts.length === 0) {
      return void 0;
    }
    return parts.map((toolCall) => ({
      toolCallId: toolCall.toolCallId,
      toolName: toolCall.toolName,
      input: toolCall.input
    }));
  }
  function asContent({
    content,
    toolCalls,
    toolOutputs
  }) {
    return [
      ...content.map((part) => {
        switch (part.type) {
          case "text":
          case "reasoning":
          case "source":
            return part;
          case "file": {
            return {
              type: "file",
              file: new DefaultGeneratedFile(part)
            };
          }
          case "tool-call": {
            return toolCalls.find(
              (toolCall) => toolCall.toolCallId === part.toolCallId
            );
          }
          case "tool-result": {
            const toolCall = toolCalls.find(
              (toolCall2) => toolCall2.toolCallId === part.toolCallId
            );
            if (toolCall == null) {
              throw new Error(`Tool call ${part.toolCallId} not found.`);
            }
            if (part.isError) {
              return {
                type: "tool-error",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                input: toolCall.input,
                error: part.result,
                providerExecuted: true,
                dynamic: toolCall.dynamic
              };
            }
            return {
              type: "tool-result",
              toolCallId: part.toolCallId,
              toolName: part.toolName,
              input: toolCall.input,
              output: part.result,
              providerExecuted: true,
              dynamic: toolCall.dynamic
            };
          }
        }
      }),
      ...toolOutputs
    ];
  }

  // src/util/prepare-headers.ts
  function prepareHeaders(headers, defaultHeaders) {
    const responseHeaders = new Headers(headers != null ? headers : {});
    for (const [key, value] of Object.entries(defaultHeaders)) {
      if (!responseHeaders.has(key)) {
        responseHeaders.set(key, value);
      }
    }
    return responseHeaders;
  }

  // src/text-stream/create-text-stream-response.ts
  function createTextStreamResponse({
    status,
    statusText,
    headers,
    textStream
  }) {
    return new Response(textStream.pipeThrough(new TextEncoderStream()), {
      status: status != null ? status : 200,
      statusText,
      headers: prepareHeaders(headers, {
        "content-type": "text/plain; charset=utf-8"
      })
    });
  }

  // src/util/write-to-server-response.ts
  function writeToServerResponse({
    response,
    status,
    statusText,
    headers,
    stream
  }) {
    response.writeHead(status != null ? status : 200, statusText, headers);
    const reader = stream.getReader();
    const read = async () => {
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          response.write(value);
        }
      } catch (error) {
        throw error;
      } finally {
        response.end();
      }
    };
    read();
  }

  // src/text-stream/pipe-text-stream-to-response.ts
  function pipeTextStreamToResponse({
    response,
    status,
    statusText,
    headers,
    textStream
  }) {
    writeToServerResponse({
      response,
      status,
      statusText,
      headers: Object.fromEntries(
        prepareHeaders(headers, {
          "content-type": "text/plain; charset=utf-8"
        }).entries()
      ),
      stream: textStream.pipeThrough(new TextEncoderStream())
    });
  }

  // src/ui-message-stream/json-to-sse-transform-stream.ts
  var JsonToSseTransformStream = class extends TransformStream {
    constructor() {
      super({
        transform(part, controller) {
          controller.enqueue(`data: ${JSON.stringify(part)}

`);
        },
        flush(controller) {
          controller.enqueue("data: [DONE]\n\n");
        }
      });
    }
  };

  // src/ui-message-stream/ui-message-stream-headers.ts
  var UI_MESSAGE_STREAM_HEADERS = {
    "content-type": "text/event-stream",
    "cache-control": "no-cache",
    connection: "keep-alive",
    "x-vercel-ai-ui-message-stream": "v1",
    "x-accel-buffering": "no"
    // disable nginx buffering
  };

  // src/ui-message-stream/create-ui-message-stream-response.ts
  function createUIMessageStreamResponse({
    status,
    statusText,
    headers,
    stream,
    consumeSseStream
  }) {
    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
    if (consumeSseStream) {
      const [stream1, stream2] = sseStream.tee();
      sseStream = stream1;
      consumeSseStream({ stream: stream2 });
    }
    return new Response(sseStream.pipeThrough(new TextEncoderStream()), {
      status,
      statusText,
      headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)
    });
  }

  // src/ui-message-stream/get-response-ui-message-id.ts
  function getResponseUIMessageId({
    originalMessages,
    responseMessageId
  }) {
    if (originalMessages == null) {
      return void 0;
    }
    const lastMessage = originalMessages[originalMessages.length - 1];
    return (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage.id : typeof responseMessageId === "function" ? responseMessageId() : responseMessageId;
  }
  union([
    strictObject({
      type: literal("text-start"),
      id: string$1(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("text-delta"),
      id: string$1(),
      delta: string$1(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("text-end"),
      id: string$1(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("error"),
      errorText: string$1()
    }),
    strictObject({
      type: literal("tool-input-start"),
      toolCallId: string$1(),
      toolName: string$1(),
      providerExecuted: boolean$1().optional(),
      dynamic: boolean$1().optional()
    }),
    strictObject({
      type: literal("tool-input-delta"),
      toolCallId: string$1(),
      inputTextDelta: string$1()
    }),
    strictObject({
      type: literal("tool-input-available"),
      toolCallId: string$1(),
      toolName: string$1(),
      input: unknown(),
      providerExecuted: boolean$1().optional(),
      providerMetadata: providerMetadataSchema.optional(),
      dynamic: boolean$1().optional()
    }),
    strictObject({
      type: literal("tool-input-error"),
      toolCallId: string$1(),
      toolName: string$1(),
      input: unknown(),
      providerExecuted: boolean$1().optional(),
      providerMetadata: providerMetadataSchema.optional(),
      dynamic: boolean$1().optional(),
      errorText: string$1()
    }),
    strictObject({
      type: literal("tool-output-available"),
      toolCallId: string$1(),
      output: unknown(),
      providerExecuted: boolean$1().optional(),
      dynamic: boolean$1().optional(),
      preliminary: boolean$1().optional()
    }),
    strictObject({
      type: literal("tool-output-error"),
      toolCallId: string$1(),
      errorText: string$1(),
      providerExecuted: boolean$1().optional(),
      dynamic: boolean$1().optional()
    }),
    strictObject({
      type: literal("reasoning"),
      text: string$1(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("reasoning-start"),
      id: string$1(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("reasoning-delta"),
      id: string$1(),
      delta: string$1(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("reasoning-end"),
      id: string$1(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("reasoning-part-finish")
    }),
    strictObject({
      type: literal("source-url"),
      sourceId: string$1(),
      url: string$1(),
      title: string$1().optional(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("source-document"),
      sourceId: string$1(),
      mediaType: string$1(),
      title: string$1(),
      filename: string$1().optional(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: literal("file"),
      url: string$1(),
      mediaType: string$1(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    strictObject({
      type: string$1().startsWith("data-"),
      id: string$1().optional(),
      data: unknown(),
      transient: boolean$1().optional()
    }),
    strictObject({
      type: literal("start-step")
    }),
    strictObject({
      type: literal("finish-step")
    }),
    strictObject({
      type: literal("start"),
      messageId: string$1().optional(),
      messageMetadata: unknown().optional()
    }),
    strictObject({
      type: literal("finish"),
      messageMetadata: unknown().optional()
    }),
    strictObject({
      type: literal("abort")
    }),
    strictObject({
      type: literal("message-metadata"),
      messageMetadata: unknown()
    })
  ]);
  function isDataUIMessageChunk(chunk) {
    return chunk.type.startsWith("data-");
  }

  // src/util/merge-objects.ts
  function mergeObjects(base, overrides) {
    if (base === void 0 && overrides === void 0) {
      return void 0;
    }
    if (base === void 0) {
      return overrides;
    }
    if (overrides === void 0) {
      return base;
    }
    const result = { ...base };
    for (const key in overrides) {
      if (Object.prototype.hasOwnProperty.call(overrides, key)) {
        const overridesValue = overrides[key];
        if (overridesValue === void 0)
          continue;
        const baseValue = key in base ? base[key] : void 0;
        const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);
        const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);
        if (isSourceObject && isTargetObject) {
          result[key] = mergeObjects(
            baseValue,
            overridesValue
          );
        } else {
          result[key] = overridesValue;
        }
      }
    }
    return result;
  }

  // src/util/fix-json.ts
  function fixJson(input) {
    const stack = ["ROOT"];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char, i, swapState) {
      {
        switch (char) {
          case '"': {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_STRING");
            break;
          }
          case "f":
          case "t":
          case "n": {
            lastValidIndex = i;
            literalStart = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_LITERAL");
            break;
          }
          case "-": {
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_NUMBER");
            break;
          }
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_NUMBER");
            break;
          }
          case "{": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_OBJECT_START");
            break;
          }
          case "[": {
            lastValidIndex = i;
            stack.pop();
            stack.push(swapState);
            stack.push("INSIDE_ARRAY_START");
            break;
          }
        }
      }
    }
    function processAfterObjectValue(char, i) {
      switch (char) {
        case ",": {
          stack.pop();
          stack.push("INSIDE_OBJECT_AFTER_COMMA");
          break;
        }
        case "}": {
          lastValidIndex = i;
          stack.pop();
          break;
        }
      }
    }
    function processAfterArrayValue(char, i) {
      switch (char) {
        case ",": {
          stack.pop();
          stack.push("INSIDE_ARRAY_AFTER_COMMA");
          break;
        }
        case "]": {
          lastValidIndex = i;
          stack.pop();
          break;
        }
      }
    }
    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      const currentState = stack[stack.length - 1];
      switch (currentState) {
        case "ROOT":
          processValueStart(char, i, "FINISH");
          break;
        case "INSIDE_OBJECT_START": {
          switch (char) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_KEY");
              break;
            }
            case "}": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_AFTER_COMMA": {
          switch (char) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_KEY");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_KEY": {
          switch (char) {
            case '"': {
              stack.pop();
              stack.push("INSIDE_OBJECT_AFTER_KEY");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_AFTER_KEY": {
          switch (char) {
            case ":": {
              stack.pop();
              stack.push("INSIDE_OBJECT_BEFORE_VALUE");
              break;
            }
          }
          break;
        }
        case "INSIDE_OBJECT_BEFORE_VALUE": {
          processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
          break;
        }
        case "INSIDE_OBJECT_AFTER_VALUE": {
          processAfterObjectValue(char, i);
          break;
        }
        case "INSIDE_STRING": {
          switch (char) {
            case '"': {
              stack.pop();
              lastValidIndex = i;
              break;
            }
            case "\\": {
              stack.push("INSIDE_STRING_ESCAPE");
              break;
            }
            default: {
              lastValidIndex = i;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_START": {
          switch (char) {
            case "]": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
            default: {
              lastValidIndex = i;
              processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
              break;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_AFTER_VALUE": {
          switch (char) {
            case ",": {
              stack.pop();
              stack.push("INSIDE_ARRAY_AFTER_COMMA");
              break;
            }
            case "]": {
              lastValidIndex = i;
              stack.pop();
              break;
            }
            default: {
              lastValidIndex = i;
              break;
            }
          }
          break;
        }
        case "INSIDE_ARRAY_AFTER_COMMA": {
          processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
          break;
        }
        case "INSIDE_STRING_ESCAPE": {
          stack.pop();
          lastValidIndex = i;
          break;
        }
        case "INSIDE_NUMBER": {
          switch (char) {
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9": {
              lastValidIndex = i;
              break;
            }
            case "e":
            case "E":
            case "-":
            case ".": {
              break;
            }
            case ",": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                processAfterArrayValue(char, i);
              }
              if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                processAfterObjectValue(char, i);
              }
              break;
            }
            case "}": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                processAfterObjectValue(char, i);
              }
              break;
            }
            case "]": {
              stack.pop();
              if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                processAfterArrayValue(char, i);
              }
              break;
            }
            default: {
              stack.pop();
              break;
            }
          }
          break;
        }
        case "INSIDE_LITERAL": {
          const partialLiteral = input.substring(literalStart, i + 1);
          if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
          } else {
            lastValidIndex = i;
          }
          break;
        }
      }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for (let i = stack.length - 1; i >= 0; i--) {
      const state = stack[i];
      switch (state) {
        case "INSIDE_STRING": {
          result += '"';
          break;
        }
        case "INSIDE_OBJECT_KEY":
        case "INSIDE_OBJECT_AFTER_KEY":
        case "INSIDE_OBJECT_AFTER_COMMA":
        case "INSIDE_OBJECT_START":
        case "INSIDE_OBJECT_BEFORE_VALUE":
        case "INSIDE_OBJECT_AFTER_VALUE": {
          result += "}";
          break;
        }
        case "INSIDE_ARRAY_START":
        case "INSIDE_ARRAY_AFTER_COMMA":
        case "INSIDE_ARRAY_AFTER_VALUE": {
          result += "]";
          break;
        }
        case "INSIDE_LITERAL": {
          const partialLiteral = input.substring(literalStart, input.length);
          if ("true".startsWith(partialLiteral)) {
            result += "true".slice(partialLiteral.length);
          } else if ("false".startsWith(partialLiteral)) {
            result += "false".slice(partialLiteral.length);
          } else if ("null".startsWith(partialLiteral)) {
            result += "null".slice(partialLiteral.length);
          }
        }
      }
    }
    return result;
  }

  // src/util/parse-partial-json.ts
  async function parsePartialJson(jsonText) {
    if (jsonText === void 0) {
      return { value: void 0, state: "undefined-input" };
    }
    let result = await safeParseJSON$1({ text: jsonText });
    if (result.success) {
      return { value: result.value, state: "successful-parse" };
    }
    result = await safeParseJSON$1({ text: fixJson(jsonText) });
    if (result.success) {
      return { value: result.value, state: "repaired-parse" };
    }
    return { value: void 0, state: "failed-parse" };
  }

  // src/ui/ui-messages.ts
  function isToolUIPart(part) {
    return part.type.startsWith("tool-");
  }
  function getToolName(part) {
    return part.type.split("-").slice(1).join("-");
  }

  // src/ui/process-ui-message-stream.ts
  function createStreamingUIMessageState({
    lastMessage,
    messageId
  }) {
    return {
      message: (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage : {
        id: messageId,
        metadata: void 0,
        role: "assistant",
        parts: []
      },
      activeTextParts: {},
      activeReasoningParts: {},
      partialToolCalls: {}
    };
  }
  function processUIMessageStream({
    stream,
    messageMetadataSchema,
    dataPartSchemas,
    runUpdateMessageJob,
    onError,
    onToolCall,
    onData
  }) {
    return stream.pipeThrough(
      new TransformStream({
        async transform(chunk, controller) {
          await runUpdateMessageJob(async ({ state, write }) => {
            var _a17, _b, _c, _d;
            function getToolInvocation(toolCallId) {
              const toolInvocations = state.message.parts.filter(isToolUIPart);
              const toolInvocation = toolInvocations.find(
                (invocation) => invocation.toolCallId === toolCallId
              );
              if (toolInvocation == null) {
                throw new Error(
                  "tool-output-error must be preceded by a tool-input-available"
                );
              }
              return toolInvocation;
            }
            function getDynamicToolInvocation(toolCallId) {
              const toolInvocations = state.message.parts.filter(
                (part) => part.type === "dynamic-tool"
              );
              const toolInvocation = toolInvocations.find(
                (invocation) => invocation.toolCallId === toolCallId
              );
              if (toolInvocation == null) {
                throw new Error(
                  "tool-output-error must be preceded by a tool-input-available"
                );
              }
              return toolInvocation;
            }
            function updateToolPart(options) {
              var _a18;
              const part = state.message.parts.find(
                (part2) => isToolUIPart(part2) && part2.toolCallId === options.toolCallId
              );
              const anyOptions = options;
              const anyPart = part;
              if (part != null) {
                part.state = options.state;
                anyPart.input = anyOptions.input;
                anyPart.output = anyOptions.output;
                anyPart.errorText = anyOptions.errorText;
                anyPart.rawInput = anyOptions.rawInput;
                anyPart.preliminary = anyOptions.preliminary;
                anyPart.providerExecuted = (_a18 = anyOptions.providerExecuted) != null ? _a18 : part.providerExecuted;
                if (anyOptions.providerMetadata != null && part.state === "input-available") {
                  part.callProviderMetadata = anyOptions.providerMetadata;
                }
              } else {
                state.message.parts.push({
                  type: `tool-${options.toolName}`,
                  toolCallId: options.toolCallId,
                  state: options.state,
                  input: anyOptions.input,
                  output: anyOptions.output,
                  rawInput: anyOptions.rawInput,
                  errorText: anyOptions.errorText,
                  providerExecuted: anyOptions.providerExecuted,
                  preliminary: anyOptions.preliminary,
                  ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
                });
              }
            }
            function updateDynamicToolPart(options) {
              var _a18;
              const part = state.message.parts.find(
                (part2) => part2.type === "dynamic-tool" && part2.toolCallId === options.toolCallId
              );
              const anyOptions = options;
              const anyPart = part;
              if (part != null) {
                part.state = options.state;
                anyPart.toolName = options.toolName;
                anyPart.input = anyOptions.input;
                anyPart.output = anyOptions.output;
                anyPart.errorText = anyOptions.errorText;
                anyPart.rawInput = (_a18 = anyOptions.rawInput) != null ? _a18 : anyPart.rawInput;
                anyPart.preliminary = anyOptions.preliminary;
                if (anyOptions.providerMetadata != null && part.state === "input-available") {
                  part.callProviderMetadata = anyOptions.providerMetadata;
                }
              } else {
                state.message.parts.push({
                  type: "dynamic-tool",
                  toolName: options.toolName,
                  toolCallId: options.toolCallId,
                  state: options.state,
                  input: anyOptions.input,
                  output: anyOptions.output,
                  errorText: anyOptions.errorText,
                  preliminary: anyOptions.preliminary,
                  ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
                });
              }
            }
            async function updateMessageMetadata(metadata) {
              if (metadata != null) {
                const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;
                if (messageMetadataSchema != null) {
                  await validateTypes$1({
                    value: mergedMetadata,
                    schema: messageMetadataSchema
                  });
                }
                state.message.metadata = mergedMetadata;
              }
            }
            switch (chunk.type) {
              case "text-start": {
                const textPart = {
                  type: "text",
                  text: "",
                  providerMetadata: chunk.providerMetadata,
                  state: "streaming"
                };
                state.activeTextParts[chunk.id] = textPart;
                state.message.parts.push(textPart);
                write();
                break;
              }
              case "text-delta": {
                const textPart = state.activeTextParts[chunk.id];
                textPart.text += chunk.delta;
                textPart.providerMetadata = (_a17 = chunk.providerMetadata) != null ? _a17 : textPart.providerMetadata;
                write();
                break;
              }
              case "text-end": {
                const textPart = state.activeTextParts[chunk.id];
                textPart.state = "done";
                textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;
                delete state.activeTextParts[chunk.id];
                write();
                break;
              }
              case "reasoning-start": {
                const reasoningPart = {
                  type: "reasoning",
                  text: "",
                  providerMetadata: chunk.providerMetadata,
                  state: "streaming"
                };
                state.activeReasoningParts[chunk.id] = reasoningPart;
                state.message.parts.push(reasoningPart);
                write();
                break;
              }
              case "reasoning-delta": {
                const reasoningPart = state.activeReasoningParts[chunk.id];
                reasoningPart.text += chunk.delta;
                reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;
                write();
                break;
              }
              case "reasoning-end": {
                const reasoningPart = state.activeReasoningParts[chunk.id];
                reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;
                reasoningPart.state = "done";
                delete state.activeReasoningParts[chunk.id];
                write();
                break;
              }
              case "file": {
                state.message.parts.push({
                  type: "file",
                  mediaType: chunk.mediaType,
                  url: chunk.url
                });
                write();
                break;
              }
              case "source-url": {
                state.message.parts.push({
                  type: "source-url",
                  sourceId: chunk.sourceId,
                  url: chunk.url,
                  title: chunk.title,
                  providerMetadata: chunk.providerMetadata
                });
                write();
                break;
              }
              case "source-document": {
                state.message.parts.push({
                  type: "source-document",
                  sourceId: chunk.sourceId,
                  mediaType: chunk.mediaType,
                  title: chunk.title,
                  filename: chunk.filename,
                  providerMetadata: chunk.providerMetadata
                });
                write();
                break;
              }
              case "tool-input-start": {
                const toolInvocations = state.message.parts.filter(isToolUIPart);
                state.partialToolCalls[chunk.toolCallId] = {
                  text: "",
                  toolName: chunk.toolName,
                  index: toolInvocations.length,
                  dynamic: chunk.dynamic
                };
                if (chunk.dynamic) {
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "input-streaming",
                    input: void 0
                  });
                } else {
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "input-streaming",
                    input: void 0,
                    providerExecuted: chunk.providerExecuted
                  });
                }
                write();
                break;
              }
              case "tool-input-delta": {
                const partialToolCall = state.partialToolCalls[chunk.toolCallId];
                partialToolCall.text += chunk.inputTextDelta;
                const { value: partialArgs } = await parsePartialJson(
                  partialToolCall.text
                );
                if (partialToolCall.dynamic) {
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: partialToolCall.toolName,
                    state: "input-streaming",
                    input: partialArgs
                  });
                } else {
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: partialToolCall.toolName,
                    state: "input-streaming",
                    input: partialArgs
                  });
                }
                write();
                break;
              }
              case "tool-input-available": {
                if (chunk.dynamic) {
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "input-available",
                    input: chunk.input,
                    providerMetadata: chunk.providerMetadata
                  });
                } else {
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "input-available",
                    input: chunk.input,
                    providerExecuted: chunk.providerExecuted,
                    providerMetadata: chunk.providerMetadata
                  });
                }
                write();
                if (onToolCall && !chunk.providerExecuted) {
                  await onToolCall({
                    toolCall: chunk
                  });
                }
                break;
              }
              case "tool-input-error": {
                if (chunk.dynamic) {
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "output-error",
                    input: chunk.input,
                    errorText: chunk.errorText,
                    providerMetadata: chunk.providerMetadata
                  });
                } else {
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    state: "output-error",
                    input: void 0,
                    rawInput: chunk.input,
                    errorText: chunk.errorText,
                    providerExecuted: chunk.providerExecuted,
                    providerMetadata: chunk.providerMetadata
                  });
                }
                write();
                break;
              }
              case "tool-output-available": {
                if (chunk.dynamic) {
                  const toolInvocation = getDynamicToolInvocation(
                    chunk.toolCallId
                  );
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: toolInvocation.toolName,
                    state: "output-available",
                    input: toolInvocation.input,
                    output: chunk.output,
                    preliminary: chunk.preliminary
                  });
                } else {
                  const toolInvocation = getToolInvocation(chunk.toolCallId);
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: getToolName(toolInvocation),
                    state: "output-available",
                    input: toolInvocation.input,
                    output: chunk.output,
                    providerExecuted: chunk.providerExecuted,
                    preliminary: chunk.preliminary
                  });
                }
                write();
                break;
              }
              case "tool-output-error": {
                if (chunk.dynamic) {
                  const toolInvocation = getDynamicToolInvocation(
                    chunk.toolCallId
                  );
                  updateDynamicToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: toolInvocation.toolName,
                    state: "output-error",
                    input: toolInvocation.input,
                    errorText: chunk.errorText
                  });
                } else {
                  const toolInvocation = getToolInvocation(chunk.toolCallId);
                  updateToolPart({
                    toolCallId: chunk.toolCallId,
                    toolName: getToolName(toolInvocation),
                    state: "output-error",
                    input: toolInvocation.input,
                    rawInput: toolInvocation.rawInput,
                    errorText: chunk.errorText
                  });
                }
                write();
                break;
              }
              case "start-step": {
                state.message.parts.push({ type: "step-start" });
                break;
              }
              case "finish-step": {
                state.activeTextParts = {};
                state.activeReasoningParts = {};
                break;
              }
              case "start": {
                if (chunk.messageId != null) {
                  state.message.id = chunk.messageId;
                }
                await updateMessageMetadata(chunk.messageMetadata);
                if (chunk.messageId != null || chunk.messageMetadata != null) {
                  write();
                }
                break;
              }
              case "finish": {
                await updateMessageMetadata(chunk.messageMetadata);
                if (chunk.messageMetadata != null) {
                  write();
                }
                break;
              }
              case "message-metadata": {
                await updateMessageMetadata(chunk.messageMetadata);
                if (chunk.messageMetadata != null) {
                  write();
                }
                break;
              }
              case "error": {
                onError == null ? void 0 : onError(new Error(chunk.errorText));
                break;
              }
              default: {
                if (isDataUIMessageChunk(chunk)) {
                  if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {
                    await validateTypes$1({
                      value: chunk.data,
                      schema: dataPartSchemas[chunk.type]
                    });
                  }
                  const dataChunk = chunk;
                  if (dataChunk.transient) {
                    onData == null ? void 0 : onData(dataChunk);
                    break;
                  }
                  const existingUIPart = dataChunk.id != null ? state.message.parts.find(
                    (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id
                  ) : void 0;
                  if (existingUIPart != null) {
                    existingUIPart.data = dataChunk.data;
                  } else {
                    state.message.parts.push(dataChunk);
                  }
                  onData == null ? void 0 : onData(dataChunk);
                  write();
                }
              }
            }
            controller.enqueue(chunk);
          });
        }
      })
    );
  }

  // src/ui-message-stream/handle-ui-message-stream-finish.ts
  function handleUIMessageStreamFinish({
    messageId,
    originalMessages = [],
    onFinish,
    onError,
    stream
  }) {
    let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];
    if ((lastMessage == null ? void 0 : lastMessage.role) !== "assistant") {
      lastMessage = void 0;
    } else {
      messageId = lastMessage.id;
    }
    let isAborted = false;
    const idInjectedStream = stream.pipeThrough(
      new TransformStream({
        transform(chunk, controller) {
          if (chunk.type === "start") {
            const startChunk = chunk;
            if (startChunk.messageId == null && messageId != null) {
              startChunk.messageId = messageId;
            }
          }
          if (chunk.type === "abort") {
            isAborted = true;
          }
          controller.enqueue(chunk);
        }
      })
    );
    if (onFinish == null) {
      return idInjectedStream;
    }
    const state = createStreamingUIMessageState({
      lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,
      messageId: messageId != null ? messageId : ""
      // will be overridden by the stream
    });
    const runUpdateMessageJob = async (job) => {
      await job({ state, write: () => {
      } });
    };
    let finishCalled = false;
    const callOnFinish = async () => {
      if (finishCalled || !onFinish) {
        return;
      }
      finishCalled = true;
      const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);
      await onFinish({
        isAborted,
        isContinuation,
        responseMessage: state.message,
        messages: [
          ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,
          state.message
        ]
      });
    };
    return processUIMessageStream({
      stream: idInjectedStream,
      runUpdateMessageJob,
      onError
    }).pipeThrough(
      new TransformStream({
        transform(chunk, controller) {
          controller.enqueue(chunk);
        },
        // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility
        async cancel() {
          await callOnFinish();
        },
        async flush() {
          await callOnFinish();
        }
      })
    );
  }

  // src/ui-message-stream/pipe-ui-message-stream-to-response.ts
  function pipeUIMessageStreamToResponse({
    response,
    status,
    statusText,
    headers,
    stream,
    consumeSseStream
  }) {
    let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
    if (consumeSseStream) {
      const [stream1, stream2] = sseStream.tee();
      sseStream = stream1;
      consumeSseStream({ stream: stream2 });
    }
    writeToServerResponse({
      response,
      status,
      statusText,
      headers: Object.fromEntries(
        prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()
      ),
      stream: sseStream.pipeThrough(new TextEncoderStream())
    });
  }

  // src/util/async-iterable-stream.ts
  function createAsyncIterableStream(source) {
    const stream = source.pipeThrough(new TransformStream());
    stream[Symbol.asyncIterator] = function() {
      const reader = this.getReader();
      let finished = false;
      async function cleanup(cancelStream) {
        var _a17;
        finished = true;
        try {
          if (cancelStream) {
            await ((_a17 = reader.cancel) == null ? void 0 : _a17.call(reader));
          }
        } finally {
          try {
            reader.releaseLock();
          } catch (e) {
          }
        }
      }
      return {
        /**
         * Reads the next chunk from the stream.
         * @returns A promise resolving to the next IteratorResult.
         */
        async next() {
          if (finished) {
            return { done: true, value: void 0 };
          }
          const { done, value } = await reader.read();
          if (done) {
            await cleanup(true);
            return { done: true, value: void 0 };
          }
          return { done: false, value };
        },
        /**
         * Called on early exit (e.g., break from for-await).
         * Ensures the stream is cancelled and resources are released.
         * @returns A promise resolving to a completed IteratorResult.
         */
        async return() {
          await cleanup(true);
          return { done: true, value: void 0 };
        },
        /**
         * Called on early exit with error.
         * Ensures the stream is cancelled and resources are released, then rethrows the error.
         * @param err The error to throw.
         * @returns A promise that rejects with the provided error.
         */
        async throw(err) {
          await cleanup(true);
          throw err;
        }
      };
    };
    return stream;
  }

  // src/util/consume-stream.ts
  async function consumeStream({
    stream,
    onError
  }) {
    const reader = stream.getReader();
    try {
      while (true) {
        const { done } = await reader.read();
        if (done)
          break;
      }
    } catch (error) {
      onError == null ? void 0 : onError(error);
    } finally {
      reader.releaseLock();
    }
  }

  // src/util/create-resolvable-promise.ts
  function createResolvablePromise() {
    let resolve2;
    let reject;
    const promise = new Promise((res, rej) => {
      resolve2 = res;
      reject = rej;
    });
    return {
      promise,
      resolve: resolve2,
      reject
    };
  }

  // src/util/create-stitchable-stream.ts
  function createStitchableStream() {
    let innerStreamReaders = [];
    let controller = null;
    let isClosed = false;
    let waitForNewStream = createResolvablePromise();
    const terminate = () => {
      isClosed = true;
      waitForNewStream.resolve();
      innerStreamReaders.forEach((reader) => reader.cancel());
      innerStreamReaders = [];
      controller == null ? void 0 : controller.close();
    };
    const processPull = async () => {
      if (isClosed && innerStreamReaders.length === 0) {
        controller == null ? void 0 : controller.close();
        return;
      }
      if (innerStreamReaders.length === 0) {
        waitForNewStream = createResolvablePromise();
        await waitForNewStream.promise;
        return processPull();
      }
      try {
        const { value, done } = await innerStreamReaders[0].read();
        if (done) {
          innerStreamReaders.shift();
          if (innerStreamReaders.length > 0) {
            await processPull();
          } else if (isClosed) {
            controller == null ? void 0 : controller.close();
          }
        } else {
          controller == null ? void 0 : controller.enqueue(value);
        }
      } catch (error) {
        controller == null ? void 0 : controller.error(error);
        innerStreamReaders.shift();
        terminate();
      }
    };
    return {
      stream: new ReadableStream({
        start(controllerParam) {
          controller = controllerParam;
        },
        pull: processPull,
        async cancel() {
          for (const reader of innerStreamReaders) {
            await reader.cancel();
          }
          innerStreamReaders = [];
          isClosed = true;
        }
      }),
      addStream: (innerStream) => {
        if (isClosed) {
          throw new Error("Cannot add inner stream: outer stream is closed");
        }
        innerStreamReaders.push(innerStream.getReader());
        waitForNewStream.resolve();
      },
      /**
       * Gracefully close the outer stream. This will let the inner streams
       * finish processing and then close the outer stream.
       */
      close: () => {
        isClosed = true;
        waitForNewStream.resolve();
        if (innerStreamReaders.length === 0) {
          controller == null ? void 0 : controller.close();
        }
      },
      /**
       * Immediately close the outer stream. This will cancel all inner streams
       * and close the outer stream.
       */
      terminate
    };
  }

  // src/util/delayed-promise.ts
  var DelayedPromise = class {
    constructor() {
      this.status = { type: "pending" };
      this._resolve = void 0;
      this._reject = void 0;
    }
    get promise() {
      if (this._promise) {
        return this._promise;
      }
      this._promise = new Promise((resolve2, reject) => {
        if (this.status.type === "resolved") {
          resolve2(this.status.value);
        } else if (this.status.type === "rejected") {
          reject(this.status.error);
        }
        this._resolve = resolve2;
        this._reject = reject;
      });
      return this._promise;
    }
    resolve(value) {
      var _a17;
      this.status = { type: "resolved", value };
      if (this._promise) {
        (_a17 = this._resolve) == null ? void 0 : _a17.call(this, value);
      }
    }
    reject(error) {
      var _a17;
      this.status = { type: "rejected", error };
      if (this._promise) {
        (_a17 = this._reject) == null ? void 0 : _a17.call(this, error);
      }
    }
  };

  // src/util/now.ts
  function now() {
    var _a17, _b;
    return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();
  }
  function runToolsTransformation({
    tools,
    generatorStream,
    tracer,
    telemetry,
    system,
    messages,
    abortSignal,
    repairToolCall,
    experimental_context
  }) {
    let toolResultsStreamController = null;
    const toolResultsStream = new ReadableStream({
      start(controller) {
        toolResultsStreamController = controller;
      }
    });
    const outstandingToolResults = /* @__PURE__ */ new Set();
    const toolInputs = /* @__PURE__ */ new Map();
    let canClose = false;
    let finishChunk = void 0;
    function attemptClose() {
      if (canClose && outstandingToolResults.size === 0) {
        if (finishChunk != null) {
          toolResultsStreamController.enqueue(finishChunk);
        }
        toolResultsStreamController.close();
      }
    }
    const forwardStream = new TransformStream({
      async transform(chunk, controller) {
        const chunkType = chunk.type;
        switch (chunkType) {
          case "stream-start":
          case "text-start":
          case "text-delta":
          case "text-end":
          case "reasoning-start":
          case "reasoning-delta":
          case "reasoning-end":
          case "tool-input-start":
          case "tool-input-delta":
          case "tool-input-end":
          case "source":
          case "response-metadata":
          case "error":
          case "raw": {
            controller.enqueue(chunk);
            break;
          }
          case "file": {
            controller.enqueue({
              type: "file",
              file: new DefaultGeneratedFileWithType({
                data: chunk.data,
                mediaType: chunk.mediaType
              })
            });
            break;
          }
          case "finish": {
            finishChunk = {
              type: "finish",
              finishReason: chunk.finishReason,
              usage: chunk.usage,
              providerMetadata: chunk.providerMetadata
            };
            break;
          }
          case "tool-call": {
            try {
              const toolCall = await parseToolCall({
                toolCall: chunk,
                tools,
                repairToolCall,
                system,
                messages
              });
              controller.enqueue(toolCall);
              if (toolCall.invalid) {
                toolResultsStreamController.enqueue({
                  type: "tool-error",
                  toolCallId: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  input: toolCall.input,
                  error: getErrorMessage$1(toolCall.error),
                  dynamic: true
                });
                break;
              }
              const tool3 = tools[toolCall.toolName];
              toolInputs.set(toolCall.toolCallId, toolCall.input);
              if (tool3.onInputAvailable != null) {
                await tool3.onInputAvailable({
                  input: toolCall.input,
                  toolCallId: toolCall.toolCallId,
                  messages,
                  abortSignal,
                  experimental_context
                });
              }
              if (tool3.execute != null && toolCall.providerExecuted !== true) {
                const toolExecutionId = generateId$1();
                outstandingToolResults.add(toolExecutionId);
                recordSpan({
                  name: "ai.toolCall",
                  attributes: selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      ...assembleOperationName({
                        operationId: "ai.toolCall",
                        telemetry
                      }),
                      "ai.toolCall.name": toolCall.toolName,
                      "ai.toolCall.id": toolCall.toolCallId,
                      "ai.toolCall.args": {
                        output: () => JSON.stringify(toolCall.input)
                      }
                    }
                  }),
                  tracer,
                  fn: async (span) => {
                    let output;
                    try {
                      const stream = executeTool({
                        execute: tool3.execute.bind(tool3),
                        input: toolCall.input,
                        options: {
                          toolCallId: toolCall.toolCallId,
                          messages,
                          abortSignal,
                          experimental_context
                        }
                      });
                      for await (const part of stream) {
                        toolResultsStreamController.enqueue({
                          ...toolCall,
                          type: "tool-result",
                          output: part.output,
                          ...part.type === "preliminary" && {
                            preliminary: true
                          }
                        });
                        if (part.type === "final") {
                          output = part.output;
                        }
                      }
                    } catch (error) {
                      recordErrorOnSpan(span, error);
                      toolResultsStreamController.enqueue({
                        ...toolCall,
                        type: "tool-error",
                        error
                      });
                      outstandingToolResults.delete(toolExecutionId);
                      attemptClose();
                      return;
                    }
                    outstandingToolResults.delete(toolExecutionId);
                    attemptClose();
                    try {
                      span.setAttributes(
                        selectTelemetryAttributes({
                          telemetry,
                          attributes: {
                            "ai.toolCall.result": {
                              output: () => JSON.stringify(output)
                            }
                          }
                        })
                      );
                    } catch (ignored) {
                    }
                  }
                });
              }
            } catch (error) {
              toolResultsStreamController.enqueue({ type: "error", error });
            }
            break;
          }
          case "tool-result": {
            const toolName = chunk.toolName;
            if (chunk.isError) {
              toolResultsStreamController.enqueue({
                type: "tool-error",
                toolCallId: chunk.toolCallId,
                toolName,
                input: toolInputs.get(chunk.toolCallId),
                providerExecuted: chunk.providerExecuted,
                error: chunk.result
              });
            } else {
              controller.enqueue({
                type: "tool-result",
                toolCallId: chunk.toolCallId,
                toolName,
                input: toolInputs.get(chunk.toolCallId),
                output: chunk.result,
                providerExecuted: chunk.providerExecuted
              });
            }
            break;
          }
          default: {
            const _exhaustiveCheck = chunkType;
            throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);
          }
        }
      },
      flush() {
        canClose = true;
        attemptClose();
      }
    });
    return new ReadableStream({
      async start(controller) {
        return Promise.all([
          generatorStream.pipeThrough(forwardStream).pipeTo(
            new WritableStream({
              write(chunk) {
                controller.enqueue(chunk);
              },
              close() {
              }
            })
          ),
          toolResultsStream.pipeTo(
            new WritableStream({
              write(chunk) {
                controller.enqueue(chunk);
              },
              close() {
                controller.close();
              }
            })
          )
        ]);
      }
    });
  }

  // src/generate-text/stream-text.ts
  var originalGenerateId2 = createIdGenerator$1({
    prefix: "aitxt",
    size: 24
  });
  function streamText({
    model,
    tools,
    toolChoice,
    system,
    prompt,
    messages,
    maxRetries,
    abortSignal,
    headers,
    stopWhen = stepCountIs(1),
    experimental_output: output,
    experimental_telemetry: telemetry,
    prepareStep,
    providerOptions,
    experimental_activeTools,
    activeTools = experimental_activeTools,
    experimental_repairToolCall: repairToolCall,
    experimental_transform: transform,
    experimental_download: download2,
    includeRawChunks = false,
    onChunk,
    onError = ({ error }) => {
      console.error(error);
    },
    onFinish,
    onAbort,
    onStepFinish,
    experimental_context,
    _internal: {
      now: now2 = now,
      generateId: generateId3 = originalGenerateId2,
      currentDate = () => /* @__PURE__ */ new Date()
    } = {},
    ...settings
  }) {
    return new DefaultStreamTextResult({
      model: resolveLanguageModel(model),
      telemetry,
      headers,
      settings,
      maxRetries,
      abortSignal,
      system,
      prompt,
      messages,
      tools,
      toolChoice,
      transforms: asArray(transform),
      activeTools,
      repairToolCall,
      stopConditions: asArray(stopWhen),
      output,
      providerOptions,
      prepareStep,
      includeRawChunks,
      onChunk,
      onError,
      onFinish,
      onAbort,
      onStepFinish,
      now: now2,
      currentDate,
      generateId: generateId3,
      experimental_context,
      download: download2
    });
  }
  function createOutputTransformStream(output) {
    if (!output) {
      return new TransformStream({
        transform(chunk, controller) {
          controller.enqueue({ part: chunk, partialOutput: void 0 });
        }
      });
    }
    let firstTextChunkId = void 0;
    let text2 = "";
    let textChunk = "";
    let lastPublishedJson = "";
    function publishTextChunk({
      controller,
      partialOutput = void 0
    }) {
      controller.enqueue({
        part: {
          type: "text-delta",
          id: firstTextChunkId,
          text: textChunk
        },
        partialOutput
      });
      textChunk = "";
    }
    return new TransformStream({
      async transform(chunk, controller) {
        if (chunk.type === "finish-step" && textChunk.length > 0) {
          publishTextChunk({ controller });
        }
        if (chunk.type !== "text-delta" && chunk.type !== "text-start" && chunk.type !== "text-end") {
          controller.enqueue({ part: chunk, partialOutput: void 0 });
          return;
        }
        if (firstTextChunkId == null) {
          firstTextChunkId = chunk.id;
        } else if (chunk.id !== firstTextChunkId) {
          controller.enqueue({ part: chunk, partialOutput: void 0 });
          return;
        }
        if (chunk.type === "text-start") {
          controller.enqueue({ part: chunk, partialOutput: void 0 });
          return;
        }
        if (chunk.type === "text-end") {
          if (textChunk.length > 0) {
            publishTextChunk({ controller });
          }
          controller.enqueue({ part: chunk, partialOutput: void 0 });
          return;
        }
        text2 += chunk.text;
        textChunk += chunk.text;
        const result = await output.parsePartial({ text: text2 });
        if (result != null) {
          const currentJson = JSON.stringify(result.partial);
          if (currentJson !== lastPublishedJson) {
            publishTextChunk({ controller, partialOutput: result.partial });
            lastPublishedJson = currentJson;
          }
        }
      }
    });
  }
  var DefaultStreamTextResult = class {
    constructor({
      model,
      telemetry,
      headers,
      settings,
      maxRetries: maxRetriesArg,
      abortSignal,
      system,
      prompt,
      messages,
      tools,
      toolChoice,
      transforms,
      activeTools,
      repairToolCall,
      stopConditions,
      output,
      providerOptions,
      prepareStep,
      includeRawChunks,
      now: now2,
      currentDate,
      generateId: generateId3,
      onChunk,
      onError,
      onFinish,
      onAbort,
      onStepFinish,
      experimental_context,
      download: download2
    }) {
      this._totalUsage = new DelayedPromise();
      this._finishReason = new DelayedPromise();
      this._steps = new DelayedPromise();
      this.output = output;
      this.includeRawChunks = includeRawChunks;
      this.tools = tools;
      let stepFinish;
      let recordedContent = [];
      const recordedResponseMessages = [];
      let recordedFinishReason = void 0;
      let recordedTotalUsage = void 0;
      let recordedRequest = {};
      let recordedWarnings = [];
      const recordedSteps = [];
      let rootSpan;
      let activeTextContent = {};
      let activeReasoningContent = {};
      const eventProcessor = new TransformStream({
        async transform(chunk, controller) {
          var _a17, _b, _c;
          controller.enqueue(chunk);
          const { part } = chunk;
          if (part.type === "text-delta" || part.type === "reasoning-delta" || part.type === "source" || part.type === "tool-call" || part.type === "tool-result" || part.type === "tool-input-start" || part.type === "tool-input-delta" || part.type === "raw") {
            await (onChunk == null ? void 0 : onChunk({ chunk: part }));
          }
          if (part.type === "error") {
            await onError({ error: wrapGatewayError(part.error) });
          }
          if (part.type === "text-start") {
            activeTextContent[part.id] = {
              type: "text",
              text: "",
              providerMetadata: part.providerMetadata
            };
            recordedContent.push(activeTextContent[part.id]);
          }
          if (part.type === "text-delta") {
            const activeText = activeTextContent[part.id];
            if (activeText == null) {
              controller.enqueue({
                part: {
                  type: "error",
                  error: `text part ${part.id} not found`
                },
                partialOutput: void 0
              });
              return;
            }
            activeText.text += part.text;
            activeText.providerMetadata = (_a17 = part.providerMetadata) != null ? _a17 : activeText.providerMetadata;
          }
          if (part.type === "text-end") {
            delete activeTextContent[part.id];
          }
          if (part.type === "reasoning-start") {
            activeReasoningContent[part.id] = {
              type: "reasoning",
              text: "",
              providerMetadata: part.providerMetadata
            };
            recordedContent.push(activeReasoningContent[part.id]);
          }
          if (part.type === "reasoning-delta") {
            const activeReasoning = activeReasoningContent[part.id];
            if (activeReasoning == null) {
              controller.enqueue({
                part: {
                  type: "error",
                  error: `reasoning part ${part.id} not found`
                },
                partialOutput: void 0
              });
              return;
            }
            activeReasoning.text += part.text;
            activeReasoning.providerMetadata = (_b = part.providerMetadata) != null ? _b : activeReasoning.providerMetadata;
          }
          if (part.type === "reasoning-end") {
            const activeReasoning = activeReasoningContent[part.id];
            if (activeReasoning == null) {
              controller.enqueue({
                part: {
                  type: "error",
                  error: `reasoning part ${part.id} not found`
                },
                partialOutput: void 0
              });
              return;
            }
            activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;
            delete activeReasoningContent[part.id];
          }
          if (part.type === "file") {
            recordedContent.push({ type: "file", file: part.file });
          }
          if (part.type === "source") {
            recordedContent.push(part);
          }
          if (part.type === "tool-call") {
            recordedContent.push(part);
          }
          if (part.type === "tool-result" && !part.preliminary) {
            recordedContent.push(part);
          }
          if (part.type === "tool-error") {
            recordedContent.push(part);
          }
          if (part.type === "start-step") {
            recordedRequest = part.request;
            recordedWarnings = part.warnings;
          }
          if (part.type === "finish-step") {
            const stepMessages = toResponseMessages({
              content: recordedContent,
              tools
            });
            const currentStepResult = new DefaultStepResult({
              content: recordedContent,
              finishReason: part.finishReason,
              usage: part.usage,
              warnings: recordedWarnings,
              request: recordedRequest,
              response: {
                ...part.response,
                messages: [...recordedResponseMessages, ...stepMessages]
              },
              providerMetadata: part.providerMetadata
            });
            await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
            logWarnings(recordedWarnings);
            recordedSteps.push(currentStepResult);
            recordedContent = [];
            activeReasoningContent = {};
            activeTextContent = {};
            recordedResponseMessages.push(...stepMessages);
            stepFinish.resolve();
          }
          if (part.type === "finish") {
            recordedTotalUsage = part.totalUsage;
            recordedFinishReason = part.finishReason;
          }
        },
        async flush(controller) {
          try {
            if (recordedSteps.length === 0) {
              const error = new NoOutputGeneratedError({
                message: "No output generated. Check the stream for errors."
              });
              self._finishReason.reject(error);
              self._totalUsage.reject(error);
              self._steps.reject(error);
              return;
            }
            const finishReason = recordedFinishReason != null ? recordedFinishReason : "unknown";
            const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            self._finishReason.resolve(finishReason);
            self._totalUsage.resolve(totalUsage);
            self._steps.resolve(recordedSteps);
            const finalStep = recordedSteps[recordedSteps.length - 1];
            await (onFinish == null ? void 0 : onFinish({
              finishReason,
              totalUsage,
              usage: finalStep.usage,
              content: finalStep.content,
              text: finalStep.text,
              reasoningText: finalStep.reasoningText,
              reasoning: finalStep.reasoning,
              files: finalStep.files,
              sources: finalStep.sources,
              toolCalls: finalStep.toolCalls,
              staticToolCalls: finalStep.staticToolCalls,
              dynamicToolCalls: finalStep.dynamicToolCalls,
              toolResults: finalStep.toolResults,
              staticToolResults: finalStep.staticToolResults,
              dynamicToolResults: finalStep.dynamicToolResults,
              request: finalStep.request,
              response: finalStep.response,
              warnings: finalStep.warnings,
              providerMetadata: finalStep.providerMetadata,
              steps: recordedSteps
            }));
            rootSpan.setAttributes(
              selectTelemetryAttributes({
                telemetry,
                attributes: {
                  "ai.response.finishReason": finishReason,
                  "ai.response.text": { output: () => finalStep.text },
                  "ai.response.toolCalls": {
                    output: () => {
                      var _a17;
                      return ((_a17 = finalStep.toolCalls) == null ? void 0 : _a17.length) ? JSON.stringify(finalStep.toolCalls) : void 0;
                    }
                  },
                  "ai.response.providerMetadata": JSON.stringify(
                    finalStep.providerMetadata
                  ),
                  "ai.usage.inputTokens": totalUsage.inputTokens,
                  "ai.usage.outputTokens": totalUsage.outputTokens,
                  "ai.usage.totalTokens": totalUsage.totalTokens,
                  "ai.usage.reasoningTokens": totalUsage.reasoningTokens,
                  "ai.usage.cachedInputTokens": totalUsage.cachedInputTokens
                }
              })
            );
          } catch (error) {
            controller.error(error);
          } finally {
            rootSpan.end();
          }
        }
      });
      const stitchableStream = createStitchableStream();
      this.addStream = stitchableStream.addStream;
      this.closeStream = stitchableStream.close;
      const reader = stitchableStream.stream.getReader();
      let stream = new ReadableStream({
        async start(controller) {
          controller.enqueue({ type: "start" });
        },
        async pull(controller) {
          function abort() {
            onAbort == null ? void 0 : onAbort({ steps: recordedSteps });
            controller.enqueue({ type: "abort" });
            controller.close();
          }
          try {
            const { done, value } = await reader.read();
            if (done) {
              controller.close();
              return;
            }
            if (abortSignal == null ? void 0 : abortSignal.aborted) {
              abort();
              return;
            }
            controller.enqueue(value);
          } catch (error) {
            if (isAbortError$1(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {
              abort();
            } else {
              controller.error(error);
            }
          }
        },
        cancel(reason) {
          return stitchableStream.stream.cancel(reason);
        }
      });
      for (const transform of transforms) {
        stream = stream.pipeThrough(
          transform({
            tools,
            stopStream() {
              stitchableStream.terminate();
            }
          })
        );
      }
      this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);
      const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg,
        abortSignal
      });
      const tracer = getTracer(telemetry);
      const callSettings = prepareCallSettings(settings);
      const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers,
        settings: { ...callSettings, maxRetries }
      });
      const self = this;
      recordSpan({
        name: "ai.streamText",
        attributes: selectTelemetryAttributes({
          telemetry,
          attributes: {
            ...assembleOperationName({ operationId: "ai.streamText", telemetry }),
            ...baseTelemetryAttributes,
            // specific settings that only make sense on the outer level:
            "ai.prompt": {
              input: () => JSON.stringify({ system, prompt, messages })
            }
          }
        }),
        tracer,
        endWhenDone: false,
        fn: async (rootSpanArg) => {
          rootSpan = rootSpanArg;
          async function streamStep({
            currentStep,
            responseMessages,
            usage
          }) {
            var _a17, _b, _c, _d, _e;
            const includeRawChunks2 = self.includeRawChunks;
            stepFinish = new DelayedPromise();
            const initialPrompt = await standardizePrompt({
              system,
              prompt,
              messages
            });
            const stepInputMessages = [
              ...initialPrompt.messages,
              ...responseMessages
            ];
            const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
              model,
              steps: recordedSteps,
              stepNumber: recordedSteps.length,
              messages: stepInputMessages
            }));
            const promptMessages = await convertToLanguageModelPrompt({
              prompt: {
                system: (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a17 : initialPrompt.system,
                messages: (_b = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _b : stepInputMessages
              },
              supportedUrls: await model.supportedUrls,
              download: download2
            });
            const stepModel = resolveLanguageModel(
              (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model
            );
            const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({
              tools,
              toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,
              activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools
            });
            const {
              result: { stream: stream2, response, request },
              doStreamSpan,
              startTimestampMs
            } = await retry(
              () => recordSpan({
                name: "ai.streamText.doStream",
                attributes: selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    ...assembleOperationName({
                      operationId: "ai.streamText.doStream",
                      telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // model:
                    "ai.model.provider": stepModel.provider,
                    "ai.model.id": stepModel.modelId,
                    // prompt:
                    "ai.prompt.messages": {
                      input: () => stringifyForTelemetry(promptMessages)
                    },
                    "ai.prompt.tools": {
                      // convert the language model level tools:
                      input: () => stepTools == null ? void 0 : stepTools.map((tool3) => JSON.stringify(tool3))
                    },
                    "ai.prompt.toolChoice": {
                      input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                    },
                    // standardized gen-ai llm span attributes:
                    "gen_ai.system": stepModel.provider,
                    "gen_ai.request.model": stepModel.modelId,
                    "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                    "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                    "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                    "gen_ai.request.stop_sequences": callSettings.stopSequences,
                    "gen_ai.request.temperature": callSettings.temperature,
                    "gen_ai.request.top_k": callSettings.topK,
                    "gen_ai.request.top_p": callSettings.topP
                  }
                }),
                tracer,
                endWhenDone: false,
                fn: async (doStreamSpan2) => {
                  return {
                    startTimestampMs: now2(),
                    // get before the call
                    doStreamSpan: doStreamSpan2,
                    result: await stepModel.doStream({
                      ...callSettings,
                      tools: stepTools,
                      toolChoice: stepToolChoice,
                      responseFormat: output == null ? void 0 : output.responseFormat,
                      prompt: promptMessages,
                      providerOptions,
                      abortSignal,
                      headers,
                      includeRawChunks: includeRawChunks2
                    })
                  };
                }
              })
            );
            const streamWithToolResults = runToolsTransformation({
              tools,
              generatorStream: stream2,
              tracer,
              telemetry,
              system,
              messages: stepInputMessages,
              repairToolCall,
              abortSignal,
              experimental_context
            });
            const stepRequest = request != null ? request : {};
            const stepToolCalls = [];
            const stepToolOutputs = [];
            let warnings;
            const activeToolCallToolNames = {};
            let stepFinishReason = "unknown";
            let stepUsage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            let stepProviderMetadata;
            let stepFirstChunk = true;
            let stepResponse = {
              id: generateId3(),
              timestamp: currentDate(),
              modelId: model.modelId
            };
            let activeText = "";
            self.addStream(
              streamWithToolResults.pipeThrough(
                new TransformStream({
                  async transform(chunk, controller) {
                    var _a18, _b2, _c2, _d2;
                    if (chunk.type === "stream-start") {
                      warnings = chunk.warnings;
                      return;
                    }
                    if (stepFirstChunk) {
                      const msToFirstChunk = now2() - startTimestampMs;
                      stepFirstChunk = false;
                      doStreamSpan.addEvent("ai.stream.firstChunk", {
                        "ai.response.msToFirstChunk": msToFirstChunk
                      });
                      doStreamSpan.setAttributes({
                        "ai.response.msToFirstChunk": msToFirstChunk
                      });
                      controller.enqueue({
                        type: "start-step",
                        request: stepRequest,
                        warnings: warnings != null ? warnings : []
                      });
                    }
                    const chunkType = chunk.type;
                    switch (chunkType) {
                      case "text-start":
                      case "text-end": {
                        controller.enqueue(chunk);
                        break;
                      }
                      case "text-delta": {
                        if (chunk.delta.length > 0) {
                          controller.enqueue({
                            type: "text-delta",
                            id: chunk.id,
                            text: chunk.delta,
                            providerMetadata: chunk.providerMetadata
                          });
                          activeText += chunk.delta;
                        }
                        break;
                      }
                      case "reasoning-start":
                      case "reasoning-end": {
                        controller.enqueue(chunk);
                        break;
                      }
                      case "reasoning-delta": {
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: chunk.id,
                          text: chunk.delta,
                          providerMetadata: chunk.providerMetadata
                        });
                        break;
                      }
                      case "tool-call": {
                        controller.enqueue(chunk);
                        stepToolCalls.push(chunk);
                        break;
                      }
                      case "tool-result": {
                        controller.enqueue(chunk);
                        if (!chunk.preliminary) {
                          stepToolOutputs.push(chunk);
                        }
                        break;
                      }
                      case "tool-error": {
                        controller.enqueue(chunk);
                        stepToolOutputs.push(chunk);
                        break;
                      }
                      case "response-metadata": {
                        stepResponse = {
                          id: (_a18 = chunk.id) != null ? _a18 : stepResponse.id,
                          timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,
                          modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId
                        };
                        break;
                      }
                      case "finish": {
                        stepUsage = chunk.usage;
                        stepFinishReason = chunk.finishReason;
                        stepProviderMetadata = chunk.providerMetadata;
                        const msToFinish = now2() - startTimestampMs;
                        doStreamSpan.addEvent("ai.stream.finish");
                        doStreamSpan.setAttributes({
                          "ai.response.msToFinish": msToFinish,
                          "ai.response.avgOutputTokensPerSecond": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish
                        });
                        break;
                      }
                      case "file": {
                        controller.enqueue(chunk);
                        break;
                      }
                      case "source": {
                        controller.enqueue(chunk);
                        break;
                      }
                      case "tool-input-start": {
                        activeToolCallToolNames[chunk.id] = chunk.toolName;
                        const tool3 = tools == null ? void 0 : tools[chunk.toolName];
                        if ((tool3 == null ? void 0 : tool3.onInputStart) != null) {
                          await tool3.onInputStart({
                            toolCallId: chunk.id,
                            messages: stepInputMessages,
                            abortSignal,
                            experimental_context
                          });
                        }
                        controller.enqueue({
                          ...chunk,
                          dynamic: (tool3 == null ? void 0 : tool3.type) === "dynamic"
                        });
                        break;
                      }
                      case "tool-input-end": {
                        delete activeToolCallToolNames[chunk.id];
                        controller.enqueue(chunk);
                        break;
                      }
                      case "tool-input-delta": {
                        const toolName = activeToolCallToolNames[chunk.id];
                        const tool3 = tools == null ? void 0 : tools[toolName];
                        if ((tool3 == null ? void 0 : tool3.onInputDelta) != null) {
                          await tool3.onInputDelta({
                            inputTextDelta: chunk.delta,
                            toolCallId: chunk.id,
                            messages: stepInputMessages,
                            abortSignal,
                            experimental_context
                          });
                        }
                        controller.enqueue(chunk);
                        break;
                      }
                      case "error": {
                        controller.enqueue(chunk);
                        stepFinishReason = "error";
                        break;
                      }
                      case "raw": {
                        if (includeRawChunks2) {
                          controller.enqueue(chunk);
                        }
                        break;
                      }
                      default: {
                        const exhaustiveCheck = chunkType;
                        throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                      }
                    }
                  },
                  // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                  async flush(controller) {
                    const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;
                    try {
                      doStreamSpan.setAttributes(
                        selectTelemetryAttributes({
                          telemetry,
                          attributes: {
                            "ai.response.finishReason": stepFinishReason,
                            "ai.response.text": {
                              output: () => activeText
                            },
                            "ai.response.toolCalls": {
                              output: () => stepToolCallsJson
                            },
                            "ai.response.id": stepResponse.id,
                            "ai.response.model": stepResponse.modelId,
                            "ai.response.timestamp": stepResponse.timestamp.toISOString(),
                            "ai.response.providerMetadata": JSON.stringify(stepProviderMetadata),
                            "ai.usage.inputTokens": stepUsage.inputTokens,
                            "ai.usage.outputTokens": stepUsage.outputTokens,
                            "ai.usage.totalTokens": stepUsage.totalTokens,
                            "ai.usage.reasoningTokens": stepUsage.reasoningTokens,
                            "ai.usage.cachedInputTokens": stepUsage.cachedInputTokens,
                            // standardized gen-ai llm span attributes:
                            "gen_ai.response.finish_reasons": [stepFinishReason],
                            "gen_ai.response.id": stepResponse.id,
                            "gen_ai.response.model": stepResponse.modelId,
                            "gen_ai.usage.input_tokens": stepUsage.inputTokens,
                            "gen_ai.usage.output_tokens": stepUsage.outputTokens
                          }
                        })
                      );
                    } catch (error) {
                    } finally {
                      doStreamSpan.end();
                    }
                    controller.enqueue({
                      type: "finish-step",
                      finishReason: stepFinishReason,
                      usage: stepUsage,
                      providerMetadata: stepProviderMetadata,
                      response: {
                        ...stepResponse,
                        headers: response == null ? void 0 : response.headers
                      }
                    });
                    const combinedUsage = addLanguageModelUsage(usage, stepUsage);
                    await stepFinish.promise;
                    const clientToolCalls = stepToolCalls.filter(
                      (toolCall) => toolCall.providerExecuted !== true
                    );
                    const clientToolOutputs = stepToolOutputs.filter(
                      (toolOutput) => toolOutput.providerExecuted !== true
                    );
                    if (clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):
                    clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:
                    !await isStopConditionMet({
                      stopConditions,
                      steps: recordedSteps
                    })) {
                      responseMessages.push(
                        ...toResponseMessages({
                          content: (
                            // use transformed content to create the messages for the next step:
                            recordedSteps[recordedSteps.length - 1].content
                          ),
                          tools
                        })
                      );
                      try {
                        await streamStep({
                          currentStep: currentStep + 1,
                          responseMessages,
                          usage: combinedUsage
                        });
                      } catch (error) {
                        controller.enqueue({
                          type: "error",
                          error
                        });
                        self.closeStream();
                      }
                    } else {
                      controller.enqueue({
                        type: "finish",
                        finishReason: stepFinishReason,
                        totalUsage: combinedUsage
                      });
                      self.closeStream();
                    }
                  }
                })
              )
            );
          }
          await streamStep({
            currentStep: 0,
            responseMessages: [],
            usage: {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            }
          });
        }
      }).catch((error) => {
        self.addStream(
          new ReadableStream({
            start(controller) {
              controller.enqueue({ type: "error", error });
              controller.close();
            }
          })
        );
        self.closeStream();
      });
    }
    get steps() {
      this.consumeStream();
      return this._steps.promise;
    }
    get finalStep() {
      return this.steps.then((steps) => steps[steps.length - 1]);
    }
    get content() {
      return this.finalStep.then((step) => step.content);
    }
    get warnings() {
      return this.finalStep.then((step) => step.warnings);
    }
    get providerMetadata() {
      return this.finalStep.then((step) => step.providerMetadata);
    }
    get text() {
      return this.finalStep.then((step) => step.text);
    }
    get reasoningText() {
      return this.finalStep.then((step) => step.reasoningText);
    }
    get reasoning() {
      return this.finalStep.then((step) => step.reasoning);
    }
    get sources() {
      return this.finalStep.then((step) => step.sources);
    }
    get files() {
      return this.finalStep.then((step) => step.files);
    }
    get toolCalls() {
      return this.finalStep.then((step) => step.toolCalls);
    }
    get staticToolCalls() {
      return this.finalStep.then((step) => step.staticToolCalls);
    }
    get dynamicToolCalls() {
      return this.finalStep.then((step) => step.dynamicToolCalls);
    }
    get toolResults() {
      return this.finalStep.then((step) => step.toolResults);
    }
    get staticToolResults() {
      return this.finalStep.then((step) => step.staticToolResults);
    }
    get dynamicToolResults() {
      return this.finalStep.then((step) => step.dynamicToolResults);
    }
    get usage() {
      return this.finalStep.then((step) => step.usage);
    }
    get request() {
      return this.finalStep.then((step) => step.request);
    }
    get response() {
      return this.finalStep.then((step) => step.response);
    }
    get totalUsage() {
      this.consumeStream();
      return this._totalUsage.promise;
    }
    get finishReason() {
      this.consumeStream();
      return this._finishReason.promise;
    }
    /**
    Split out a new stream from the original stream.
    The original stream is replaced to allow for further splitting,
    since we do not know how many times the stream will be split.
    
    Note: this leads to buffering the stream content on the server.
    However, the LLM results are expected to be small enough to not cause issues.
       */
    teeStream() {
      const [stream1, stream2] = this.baseStream.tee();
      this.baseStream = stream2;
      return stream1;
    }
    get textStream() {
      return createAsyncIterableStream(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ part }, controller) {
              if (part.type === "text-delta") {
                controller.enqueue(part.text);
              }
            }
          })
        )
      );
    }
    get fullStream() {
      return createAsyncIterableStream(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ part }, controller) {
              controller.enqueue(part);
            }
          })
        )
      );
    }
    async consumeStream(options) {
      var _a17;
      try {
        await consumeStream({
          stream: this.fullStream,
          onError: options == null ? void 0 : options.onError
        });
      } catch (error) {
        (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);
      }
    }
    get experimental_partialOutputStream() {
      if (this.output == null) {
        throw new NoOutputSpecifiedError();
      }
      return createAsyncIterableStream(
        this.teeStream().pipeThrough(
          new TransformStream({
            transform({ partialOutput }, controller) {
              if (partialOutput != null) {
                controller.enqueue(partialOutput);
              }
            }
          })
        )
      );
    }
    toUIMessageStream({
      originalMessages,
      generateMessageId,
      onFinish,
      messageMetadata,
      sendReasoning = true,
      sendSources = false,
      sendStart = true,
      sendFinish = true,
      onError = getErrorMessage$2
    } = {}) {
      const responseMessageId = generateMessageId != null ? getResponseUIMessageId({
        originalMessages,
        responseMessageId: generateMessageId
      }) : void 0;
      const toolNamesByCallId = {};
      const isDynamic = (toolCallId) => {
        var _a17, _b;
        const toolName = toolNamesByCallId[toolCallId];
        const dynamic = ((_b = (_a17 = this.tools) == null ? void 0 : _a17[toolName]) == null ? void 0 : _b.type) === "dynamic";
        return dynamic ? true : void 0;
      };
      const baseStream = this.fullStream.pipeThrough(
        new TransformStream({
          transform: async (part, controller) => {
            const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part });
            const partType = part.type;
            switch (partType) {
              case "text-start": {
                controller.enqueue({
                  type: "text-start",
                  id: part.id,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "text-delta": {
                controller.enqueue({
                  type: "text-delta",
                  id: part.id,
                  delta: part.text,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "text-end": {
                controller.enqueue({
                  type: "text-end",
                  id: part.id,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "reasoning-start": {
                controller.enqueue({
                  type: "reasoning-start",
                  id: part.id,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "reasoning-delta": {
                if (sendReasoning) {
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: part.id,
                    delta: part.text,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                }
                break;
              }
              case "reasoning-end": {
                controller.enqueue({
                  type: "reasoning-end",
                  id: part.id,
                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                });
                break;
              }
              case "file": {
                controller.enqueue({
                  type: "file",
                  mediaType: part.file.mediaType,
                  url: `data:${part.file.mediaType};base64,${part.file.base64}`
                });
                break;
              }
              case "source": {
                if (sendSources && part.sourceType === "url") {
                  controller.enqueue({
                    type: "source-url",
                    sourceId: part.id,
                    url: part.url,
                    title: part.title,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                }
                if (sendSources && part.sourceType === "document") {
                  controller.enqueue({
                    type: "source-document",
                    sourceId: part.id,
                    mediaType: part.mediaType,
                    title: part.title,
                    filename: part.filename,
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
                  });
                }
                break;
              }
              case "tool-input-start": {
                toolNamesByCallId[part.id] = part.toolName;
                const dynamic = isDynamic(part.id);
                controller.enqueue({
                  type: "tool-input-start",
                  toolCallId: part.id,
                  toolName: part.toolName,
                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                  ...dynamic != null ? { dynamic } : {}
                });
                break;
              }
              case "tool-input-delta": {
                controller.enqueue({
                  type: "tool-input-delta",
                  toolCallId: part.id,
                  inputTextDelta: part.delta
                });
                break;
              }
              case "tool-call": {
                toolNamesByCallId[part.toolCallId] = part.toolName;
                const dynamic = isDynamic(part.toolCallId);
                if (part.invalid) {
                  controller.enqueue({
                    type: "tool-input-error",
                    toolCallId: part.toolCallId,
                    toolName: part.toolName,
                    input: part.input,
                    ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                    ...dynamic != null ? { dynamic } : {},
                    errorText: onError(part.error)
                  });
                } else {
                  controller.enqueue({
                    type: "tool-input-available",
                    toolCallId: part.toolCallId,
                    toolName: part.toolName,
                    input: part.input,
                    ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                    ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                    ...dynamic != null ? { dynamic } : {}
                  });
                }
                break;
              }
              case "tool-result": {
                const dynamic = isDynamic(part.toolCallId);
                controller.enqueue({
                  type: "tool-output-available",
                  toolCallId: part.toolCallId,
                  output: part.output,
                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                  ...part.preliminary != null ? { preliminary: part.preliminary } : {},
                  ...dynamic != null ? { dynamic } : {}
                });
                break;
              }
              case "tool-error": {
                const dynamic = isDynamic(part.toolCallId);
                controller.enqueue({
                  type: "tool-output-error",
                  toolCallId: part.toolCallId,
                  errorText: onError(part.error),
                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                  ...dynamic != null ? { dynamic } : {}
                });
                break;
              }
              case "error": {
                controller.enqueue({
                  type: "error",
                  errorText: onError(part.error)
                });
                break;
              }
              case "start-step": {
                controller.enqueue({ type: "start-step" });
                break;
              }
              case "finish-step": {
                controller.enqueue({ type: "finish-step" });
                break;
              }
              case "start": {
                if (sendStart) {
                  controller.enqueue({
                    type: "start",
                    ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},
                    ...responseMessageId != null ? { messageId: responseMessageId } : {}
                  });
                }
                break;
              }
              case "finish": {
                if (sendFinish) {
                  controller.enqueue({
                    type: "finish",
                    ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}
                  });
                }
                break;
              }
              case "abort": {
                controller.enqueue(part);
                break;
              }
              case "tool-input-end": {
                break;
              }
              case "raw": {
                break;
              }
              default: {
                const exhaustiveCheck = partType;
                throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
              }
            }
            if (messageMetadataValue != null && partType !== "start" && partType !== "finish") {
              controller.enqueue({
                type: "message-metadata",
                messageMetadata: messageMetadataValue
              });
            }
          }
        })
      );
      return createAsyncIterableStream(
        handleUIMessageStreamFinish({
          stream: baseStream,
          messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),
          originalMessages,
          onFinish,
          onError
        })
      );
    }
    pipeUIMessageStreamToResponse(response, {
      originalMessages,
      generateMessageId,
      onFinish,
      messageMetadata,
      sendReasoning,
      sendSources,
      sendFinish,
      sendStart,
      onError,
      ...init
    } = {}) {
      pipeUIMessageStreamToResponse({
        response,
        stream: this.toUIMessageStream({
          originalMessages,
          generateMessageId,
          onFinish,
          messageMetadata,
          sendReasoning,
          sendSources,
          sendFinish,
          sendStart,
          onError
        }),
        ...init
      });
    }
    pipeTextStreamToResponse(response, init) {
      pipeTextStreamToResponse({
        response,
        textStream: this.textStream,
        ...init
      });
    }
    toUIMessageStreamResponse({
      originalMessages,
      generateMessageId,
      onFinish,
      messageMetadata,
      sendReasoning,
      sendSources,
      sendFinish,
      sendStart,
      onError,
      ...init
    } = {}) {
      return createUIMessageStreamResponse({
        stream: this.toUIMessageStream({
          originalMessages,
          generateMessageId,
          onFinish,
          messageMetadata,
          sendReasoning,
          sendSources,
          sendFinish,
          sendStart,
          onError
        }),
        ...init
      });
    }
    toTextStreamResponse(init) {
      return createTextStreamResponse({
        textStream: this.textStream,
        ...init
      });
    }
  };

  // src/generate-text/extract-reasoning-content.ts
  function extractReasoningContent$1(content) {
    const parts = content.filter(
      (content2) => content2.type === "reasoning"
    );
    return parts.length === 0 ? void 0 : parts.map((content2) => content2.text).join("\n");
  }
  var noSchemaOutputStrategy = {
    type: "no-schema",
    jsonSchema: void 0,
    async validatePartialResult({ value, textDelta }) {
      return { success: true, value: { partial: value, textDelta } };
    },
    async validateFinalResult(value, context) {
      return value === void 0 ? {
        success: false,
        error: new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          text: context.text,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        })
      } : { success: true, value };
    },
    createElementStream() {
      throw new UnsupportedFunctionalityError$1({
        functionality: "element streams in no-schema mode"
      });
    }
  };
  var objectOutputStrategy = (schema) => ({
    type: "object",
    jsonSchema: schema.jsonSchema,
    async validatePartialResult({ value, textDelta }) {
      return {
        success: true,
        value: {
          // Note: currently no validation of partial results:
          partial: value,
          textDelta
        }
      };
    },
    async validateFinalResult(value) {
      return safeValidateTypes$1({ value, schema });
    },
    createElementStream() {
      throw new UnsupportedFunctionalityError$1({
        functionality: "element streams in object mode"
      });
    }
  });
  var arrayOutputStrategy = (schema) => {
    const { $schema, ...itemSchema } = schema.jsonSchema;
    return {
      type: "enum",
      // wrap in object that contains array of elements, since most LLMs will not
      // be able to generate an array directly:
      // possible future optimization: use arrays directly when model supports grammar-guided generation
      jsonSchema: {
        $schema: "http://json-schema.org/draft-07/schema#",
        type: "object",
        properties: {
          elements: { type: "array", items: itemSchema }
        },
        required: ["elements"],
        additionalProperties: false
      },
      async validatePartialResult({
        value,
        latestObject,
        isFirstDelta,
        isFinalDelta
      }) {
        var _a17;
        if (!isJSONObject(value) || !isJSONArray(value.elements)) {
          return {
            success: false,
            error: new TypeValidationError$1({
              value,
              cause: "value must be an object that contains an array of elements"
            })
          };
        }
        const inputArray = value.elements;
        const resultArray = [];
        for (let i = 0; i < inputArray.length; i++) {
          const element = inputArray[i];
          const result = await safeValidateTypes$1({ value: element, schema });
          if (i === inputArray.length - 1 && !isFinalDelta) {
            continue;
          }
          if (!result.success) {
            return result;
          }
          resultArray.push(result.value);
        }
        const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;
        let textDelta = "";
        if (isFirstDelta) {
          textDelta += "[";
        }
        if (publishedElementCount > 0) {
          textDelta += ",";
        }
        textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(",");
        if (isFinalDelta) {
          textDelta += "]";
        }
        return {
          success: true,
          value: {
            partial: resultArray,
            textDelta
          }
        };
      },
      async validateFinalResult(value) {
        if (!isJSONObject(value) || !isJSONArray(value.elements)) {
          return {
            success: false,
            error: new TypeValidationError$1({
              value,
              cause: "value must be an object that contains an array of elements"
            })
          };
        }
        const inputArray = value.elements;
        for (const element of inputArray) {
          const result = await safeValidateTypes$1({ value: element, schema });
          if (!result.success) {
            return result;
          }
        }
        return { success: true, value: inputArray };
      },
      createElementStream(originalStream) {
        let publishedElements = 0;
        return createAsyncIterableStream(
          originalStream.pipeThrough(
            new TransformStream({
              transform(chunk, controller) {
                switch (chunk.type) {
                  case "object": {
                    const array = chunk.object;
                    for (; publishedElements < array.length; publishedElements++) {
                      controller.enqueue(array[publishedElements]);
                    }
                    break;
                  }
                  case "text-delta":
                  case "finish":
                  case "error":
                    break;
                  default: {
                    const _exhaustiveCheck = chunk;
                    throw new Error(
                      `Unsupported chunk type: ${_exhaustiveCheck}`
                    );
                  }
                }
              }
            })
          )
        );
      }
    };
  };
  var enumOutputStrategy = (enumValues) => {
    return {
      type: "enum",
      // wrap in object that contains result, since most LLMs will not
      // be able to generate an enum value directly:
      // possible future optimization: use enums directly when model supports top-level enums
      jsonSchema: {
        $schema: "http://json-schema.org/draft-07/schema#",
        type: "object",
        properties: {
          result: { type: "string", enum: enumValues }
        },
        required: ["result"],
        additionalProperties: false
      },
      async validateFinalResult(value) {
        if (!isJSONObject(value) || typeof value.result !== "string") {
          return {
            success: false,
            error: new TypeValidationError$1({
              value,
              cause: 'value must be an object that contains a string in the "result" property.'
            })
          };
        }
        const result = value.result;
        return enumValues.includes(result) ? { success: true, value: result } : {
          success: false,
          error: new TypeValidationError$1({
            value,
            cause: "value must be a string in the enum"
          })
        };
      },
      async validatePartialResult({ value, textDelta }) {
        if (!isJSONObject(value) || typeof value.result !== "string") {
          return {
            success: false,
            error: new TypeValidationError$1({
              value,
              cause: 'value must be an object that contains a string in the "result" property.'
            })
          };
        }
        const result = value.result;
        const possibleEnumValues = enumValues.filter(
          (enumValue) => enumValue.startsWith(result)
        );
        if (value.result.length === 0 || possibleEnumValues.length === 0) {
          return {
            success: false,
            error: new TypeValidationError$1({
              value,
              cause: "value must be a string in the enum"
            })
          };
        }
        return {
          success: true,
          value: {
            partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],
            textDelta
          }
        };
      },
      createElementStream() {
        throw new UnsupportedFunctionalityError$1({
          functionality: "element streams in enum mode"
        });
      }
    };
  };
  function getOutputStrategy({
    output,
    schema,
    enumValues
  }) {
    switch (output) {
      case "object":
        return objectOutputStrategy(asSchema(schema));
      case "array":
        return arrayOutputStrategy(asSchema(schema));
      case "enum":
        return enumOutputStrategy(enumValues);
      case "no-schema":
        return noSchemaOutputStrategy;
      default: {
        const _exhaustiveCheck = output;
        throw new Error(`Unsupported output: ${_exhaustiveCheck}`);
      }
    }
  }
  async function parseAndValidateObjectResult(result, outputStrategy, context) {
    const parseResult = await safeParseJSON$1({ text: result });
    if (!parseResult.success) {
      throw new NoObjectGeneratedError({
        message: "No object generated: could not parse the response.",
        cause: parseResult.error,
        text: result,
        response: context.response,
        usage: context.usage,
        finishReason: context.finishReason
      });
    }
    const validationResult = await outputStrategy.validateFinalResult(
      parseResult.value,
      {
        text: result,
        response: context.response,
        usage: context.usage
      }
    );
    if (!validationResult.success) {
      throw new NoObjectGeneratedError({
        message: "No object generated: response did not match schema.",
        cause: validationResult.error,
        text: result,
        response: context.response,
        usage: context.usage,
        finishReason: context.finishReason
      });
    }
    return validationResult.value;
  }
  async function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context) {
    try {
      return await parseAndValidateObjectResult(result, outputStrategy, context);
    } catch (error) {
      if (repairText != null && NoObjectGeneratedError.isInstance(error) && (JSONParseError$1.isInstance(error.cause) || TypeValidationError$1.isInstance(error.cause))) {
        const repairedText = await repairText({
          text: result,
          error: error.cause
        });
        if (repairedText === null) {
          throw error;
        }
        return await parseAndValidateObjectResult(
          repairedText,
          outputStrategy,
          context
        );
      }
      throw error;
    }
  }

  // src/generate-object/validate-object-generation-input.ts
  function validateObjectGenerationInput({
    output,
    schema,
    schemaName,
    schemaDescription,
    enumValues
  }) {
    if (output != null && output !== "object" && output !== "array" && output !== "enum" && output !== "no-schema") {
      throw new InvalidArgumentError$1({
        parameter: "output",
        value: output,
        message: "Invalid output type."
      });
    }
    if (output === "no-schema") {
      if (schema != null) {
        throw new InvalidArgumentError$1({
          parameter: "schema",
          value: schema,
          message: "Schema is not supported for no-schema output."
        });
      }
      if (schemaDescription != null) {
        throw new InvalidArgumentError$1({
          parameter: "schemaDescription",
          value: schemaDescription,
          message: "Schema description is not supported for no-schema output."
        });
      }
      if (schemaName != null) {
        throw new InvalidArgumentError$1({
          parameter: "schemaName",
          value: schemaName,
          message: "Schema name is not supported for no-schema output."
        });
      }
      if (enumValues != null) {
        throw new InvalidArgumentError$1({
          parameter: "enumValues",
          value: enumValues,
          message: "Enum values are not supported for no-schema output."
        });
      }
    }
    if (output === "object") {
      if (schema == null) {
        throw new InvalidArgumentError$1({
          parameter: "schema",
          value: schema,
          message: "Schema is required for object output."
        });
      }
      if (enumValues != null) {
        throw new InvalidArgumentError$1({
          parameter: "enumValues",
          value: enumValues,
          message: "Enum values are not supported for object output."
        });
      }
    }
    if (output === "array") {
      if (schema == null) {
        throw new InvalidArgumentError$1({
          parameter: "schema",
          value: schema,
          message: "Element schema is required for array output."
        });
      }
      if (enumValues != null) {
        throw new InvalidArgumentError$1({
          parameter: "enumValues",
          value: enumValues,
          message: "Enum values are not supported for array output."
        });
      }
    }
    if (output === "enum") {
      if (schema != null) {
        throw new InvalidArgumentError$1({
          parameter: "schema",
          value: schema,
          message: "Schema is not supported for enum output."
        });
      }
      if (schemaDescription != null) {
        throw new InvalidArgumentError$1({
          parameter: "schemaDescription",
          value: schemaDescription,
          message: "Schema description is not supported for enum output."
        });
      }
      if (schemaName != null) {
        throw new InvalidArgumentError$1({
          parameter: "schemaName",
          value: schemaName,
          message: "Schema name is not supported for enum output."
        });
      }
      if (enumValues == null) {
        throw new InvalidArgumentError$1({
          parameter: "enumValues",
          value: enumValues,
          message: "Enum values are required for enum output."
        });
      }
      for (const value of enumValues) {
        if (typeof value !== "string") {
          throw new InvalidArgumentError$1({
            parameter: "enumValues",
            value,
            message: "Enum values must be strings."
          });
        }
      }
    }
  }

  // src/generate-object/generate-object.ts
  var originalGenerateId3 = createIdGenerator$1({ prefix: "aiobj", size: 24 });
  async function generateObject(options) {
    const {
      model: modelArg,
      output = "object",
      system,
      prompt,
      messages,
      maxRetries: maxRetriesArg,
      abortSignal,
      headers,
      experimental_repairText: repairText,
      experimental_telemetry: telemetry,
      experimental_download: download2,
      providerOptions,
      _internal: {
        generateId: generateId3 = originalGenerateId3,
        currentDate = () => /* @__PURE__ */ new Date()
      } = {},
      ...settings
    } = options;
    const model = resolveLanguageModel(modelArg);
    const enumValues = "enum" in options ? options.enum : void 0;
    const {
      schema: inputSchema,
      schemaDescription,
      schemaName
    } = "schema" in options ? options : {};
    validateObjectGenerationInput({
      output,
      schema: inputSchema,
      schemaName,
      schemaDescription,
      enumValues
    });
    const { maxRetries, retry } = prepareRetries({
      maxRetries: maxRetriesArg,
      abortSignal
    });
    const outputStrategy = getOutputStrategy({
      output,
      schema: inputSchema,
      enumValues
    });
    const callSettings = prepareCallSettings(settings);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
      model,
      telemetry,
      headers,
      settings: { ...callSettings, maxRetries }
    });
    const tracer = getTracer(telemetry);
    try {
      return await recordSpan({
        name: "ai.generateObject",
        attributes: selectTelemetryAttributes({
          telemetry,
          attributes: {
            ...assembleOperationName({
              operationId: "ai.generateObject",
              telemetry
            }),
            ...baseTelemetryAttributes,
            // specific settings that only make sense on the outer level:
            "ai.prompt": {
              input: () => JSON.stringify({ system, prompt, messages })
            },
            "ai.schema": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,
            "ai.schema.name": schemaName,
            "ai.schema.description": schemaDescription,
            "ai.settings.output": outputStrategy.type
          }
        }),
        tracer,
        fn: async (span) => {
          var _a17;
          let result;
          let finishReason;
          let usage;
          let warnings;
          let response;
          let request;
          let resultProviderMetadata;
          let reasoning;
          const standardizedPrompt = await standardizePrompt({
            system,
            prompt,
            messages
          });
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: standardizedPrompt,
            supportedUrls: await model.supportedUrls,
            download: download2
          });
          const generateResult = await retry(
            () => recordSpan({
              name: "ai.generateObject.doGenerate",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.generateObject.doGenerate",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.prompt.messages": {
                    input: () => stringifyForTelemetry(promptMessages)
                  },
                  // standardized gen-ai llm span attributes:
                  "gen_ai.system": model.provider,
                  "gen_ai.request.model": model.modelId,
                  "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                  "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                  "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                  "gen_ai.request.temperature": callSettings.temperature,
                  "gen_ai.request.top_k": callSettings.topK,
                  "gen_ai.request.top_p": callSettings.topP
                }
              }),
              tracer,
              fn: async (span2) => {
                var _a18, _b, _c, _d, _e, _f, _g, _h;
                const result2 = await model.doGenerate({
                  responseFormat: {
                    type: "json",
                    schema: outputStrategy.jsonSchema,
                    name: schemaName,
                    description: schemaDescription
                  },
                  ...prepareCallSettings(settings),
                  prompt: promptMessages,
                  providerOptions,
                  abortSignal,
                  headers
                });
                const responseData = {
                  id: (_b = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b : generateId3(),
                  timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),
                  modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,
                  headers: (_g = result2.response) == null ? void 0 : _g.headers,
                  body: (_h = result2.response) == null ? void 0 : _h.body
                };
                const text2 = extractTextContent$1(result2.content);
                const reasoning2 = extractReasoningContent$1(result2.content);
                if (text2 === void 0) {
                  throw new NoObjectGeneratedError({
                    message: "No object generated: the model did not return a response.",
                    response: responseData,
                    usage: result2.usage,
                    finishReason: result2.finishReason
                  });
                }
                span2.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": result2.finishReason,
                      "ai.response.object": { output: () => text2 },
                      "ai.response.id": responseData.id,
                      "ai.response.model": responseData.modelId,
                      "ai.response.timestamp": responseData.timestamp.toISOString(),
                      "ai.response.providerMetadata": JSON.stringify(
                        result2.providerMetadata
                      ),
                      // TODO rename telemetry attributes to inputTokens and outputTokens
                      "ai.usage.promptTokens": result2.usage.inputTokens,
                      "ai.usage.completionTokens": result2.usage.outputTokens,
                      // standardized gen-ai llm span attributes:
                      "gen_ai.response.finish_reasons": [result2.finishReason],
                      "gen_ai.response.id": responseData.id,
                      "gen_ai.response.model": responseData.modelId,
                      "gen_ai.usage.input_tokens": result2.usage.inputTokens,
                      "gen_ai.usage.output_tokens": result2.usage.outputTokens
                    }
                  })
                );
                return {
                  ...result2,
                  objectText: text2,
                  reasoning: reasoning2,
                  responseData
                };
              }
            })
          );
          result = generateResult.objectText;
          finishReason = generateResult.finishReason;
          usage = generateResult.usage;
          warnings = generateResult.warnings;
          resultProviderMetadata = generateResult.providerMetadata;
          request = (_a17 = generateResult.request) != null ? _a17 : {};
          response = generateResult.responseData;
          reasoning = generateResult.reasoning;
          logWarnings(warnings);
          const object2 = await parseAndValidateObjectResultWithRepair(
            result,
            outputStrategy,
            repairText,
            {
              response,
              usage,
              finishReason
            }
          );
          span.setAttributes(
            selectTelemetryAttributes({
              telemetry,
              attributes: {
                "ai.response.finishReason": finishReason,
                "ai.response.object": {
                  output: () => JSON.stringify(object2)
                },
                "ai.response.providerMetadata": JSON.stringify(
                  resultProviderMetadata
                ),
                // TODO rename telemetry attributes to inputTokens and outputTokens
                "ai.usage.promptTokens": usage.inputTokens,
                "ai.usage.completionTokens": usage.outputTokens
              }
            })
          );
          return new DefaultGenerateObjectResult({
            object: object2,
            reasoning,
            finishReason,
            usage,
            warnings,
            request,
            response,
            providerMetadata: resultProviderMetadata
          });
        }
      });
    } catch (error) {
      throw wrapGatewayError(error);
    }
  }
  var DefaultGenerateObjectResult = class {
    constructor(options) {
      this.object = options.object;
      this.finishReason = options.finishReason;
      this.usage = options.usage;
      this.warnings = options.warnings;
      this.providerMetadata = options.providerMetadata;
      this.response = options.response;
      this.request = options.request;
      this.reasoning = options.reasoning;
    }
    toJsonResponse(init) {
      var _a17;
      return new Response(JSON.stringify(this.object), {
        status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
        headers: prepareHeaders(init == null ? void 0 : init.headers, {
          "content-type": "application/json; charset=utf-8"
        })
      });
    }
  };

  // src/generate-object/stream-object.ts
  createIdGenerator$1({ prefix: "aiobj", size: 24 });

  // src/generate-text/output.ts
  var output_exports = {};
  __export(output_exports, {
    object: () => object,
    text: () => text
  });
  var text = () => ({
    type: "text",
    responseFormat: { type: "text" },
    async parsePartial({ text: text2 }) {
      return { partial: text2 };
    },
    async parseOutput({ text: text2 }) {
      return text2;
    }
  });
  var object = ({
    schema: inputSchema
  }) => {
    const schema = asSchema(inputSchema);
    return {
      type: "object",
      responseFormat: {
        type: "json",
        schema: schema.jsonSchema
      },
      async parsePartial({ text: text2 }) {
        const result = await parsePartialJson(text2);
        switch (result.state) {
          case "failed-parse":
          case "undefined-input":
            return void 0;
          case "repaired-parse":
          case "successful-parse":
            return {
              // Note: currently no validation of partial results:
              partial: result.value
            };
          default: {
            const _exhaustiveCheck = result.state;
            throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
          }
        }
      },
      async parseOutput({ text: text2 }, context) {
        const parseResult = await safeParseJSON$1({ text: text2 });
        if (!parseResult.success) {
          throw new NoObjectGeneratedError({
            message: "No object generated: could not parse the response.",
            cause: parseResult.error,
            text: text2,
            response: context.response,
            usage: context.usage,
            finishReason: context.finishReason
          });
        }
        const validationResult = await safeValidateTypes$1({
          value: parseResult.value,
          schema
        });
        if (!validationResult.success) {
          throw new NoObjectGeneratedError({
            message: "No object generated: response did not match schema.",
            cause: validationResult.error,
            text: text2,
            response: context.response,
            usage: context.usage,
            finishReason: context.finishReason
          });
        }
        return validationResult.value;
      }
    };
  };
  var ClientOrServerImplementationSchema = looseObject({
    name: string$1(),
    version: string$1()
  });
  var BaseParamsSchema = looseObject({
    _meta: optional(object$1({}).loose())
  });
  var ResultSchema = BaseParamsSchema;
  var RequestSchema = object$1({
    method: string$1(),
    params: optional(BaseParamsSchema)
  });
  var ServerCapabilitiesSchema = looseObject({
    experimental: optional(object$1({}).loose()),
    logging: optional(object$1({}).loose()),
    prompts: optional(
      looseObject({
        listChanged: optional(boolean$1())
      })
    ),
    resources: optional(
      looseObject({
        subscribe: optional(boolean$1()),
        listChanged: optional(boolean$1())
      })
    ),
    tools: optional(
      looseObject({
        listChanged: optional(boolean$1())
      })
    )
  });
  ResultSchema.extend({
    protocolVersion: string$1(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ClientOrServerImplementationSchema,
    instructions: optional(string$1())
  });
  var PaginatedResultSchema = ResultSchema.extend({
    nextCursor: optional(string$1())
  });
  var ToolSchema = object$1({
    name: string$1(),
    description: optional(string$1()),
    inputSchema: object$1({
      type: literal("object"),
      properties: optional(object$1({}).loose())
    }).loose()
  }).loose();
  PaginatedResultSchema.extend({
    tools: array(ToolSchema)
  });
  var TextContentSchema = object$1({
    type: literal("text"),
    text: string$1()
  }).loose();
  var ImageContentSchema = object$1({
    type: literal("image"),
    data: base64(),
    mimeType: string$1()
  }).loose();
  var ResourceContentsSchema = object$1({
    /**
     * The URI of this resource.
     */
    uri: string$1(),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: optional(string$1())
  }).loose();
  var TextResourceContentsSchema = ResourceContentsSchema.extend({
    text: string$1()
  });
  var BlobResourceContentsSchema = ResourceContentsSchema.extend({
    blob: base64()
  });
  var EmbeddedResourceSchema = object$1({
    type: literal("resource"),
    resource: union([TextResourceContentsSchema, BlobResourceContentsSchema])
  }).loose();
  ResultSchema.extend({
    content: array(
      union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])
    ),
    isError: boolean$1().default(false).optional()
  }).or(
    ResultSchema.extend({
      toolResult: unknown()
    })
  );

  // src/tool/mcp/json-rpc-message.ts
  var JSONRPC_VERSION = "2.0";
  var JSONRPCRequestSchema = object$1({
    jsonrpc: literal(JSONRPC_VERSION),
    id: union([string$1(), number$1().int()])
  }).merge(RequestSchema).strict();
  var JSONRPCResponseSchema = object$1({
    jsonrpc: literal(JSONRPC_VERSION),
    id: union([string$1(), number$1().int()]),
    result: ResultSchema
  }).strict();
  var JSONRPCErrorSchema = object$1({
    jsonrpc: literal(JSONRPC_VERSION),
    id: union([string$1(), number$1().int()]),
    error: object$1({
      code: number$1().int(),
      message: string$1(),
      data: optional(unknown())
    })
  }).strict();
  var JSONRPCNotificationSchema = object$1({
    jsonrpc: literal(JSONRPC_VERSION)
  }).merge(
    object$1({
      method: string$1(),
      params: optional(BaseParamsSchema)
    })
  ).strict();
  union([
    JSONRPCRequestSchema,
    JSONRPCNotificationSchema,
    JSONRPCResponseSchema,
    JSONRPCErrorSchema
  ]);
  var textUIPartSchema = object$1({
    type: literal("text"),
    text: string$1(),
    state: _enum(["streaming", "done"]).optional(),
    providerMetadata: providerMetadataSchema.optional()
  });
  var reasoningUIPartSchema = object$1({
    type: literal("reasoning"),
    text: string$1(),
    state: _enum(["streaming", "done"]).optional(),
    providerMetadata: providerMetadataSchema.optional()
  });
  var sourceUrlUIPartSchema = object$1({
    type: literal("source-url"),
    sourceId: string$1(),
    url: string$1(),
    title: string$1().optional(),
    providerMetadata: providerMetadataSchema.optional()
  });
  var sourceDocumentUIPartSchema = object$1({
    type: literal("source-document"),
    sourceId: string$1(),
    mediaType: string$1(),
    title: string$1(),
    filename: string$1().optional(),
    providerMetadata: providerMetadataSchema.optional()
  });
  var fileUIPartSchema = object$1({
    type: literal("file"),
    mediaType: string$1(),
    filename: string$1().optional(),
    url: string$1(),
    providerMetadata: providerMetadataSchema.optional()
  });
  var stepStartUIPartSchema = object$1({
    type: literal("step-start")
  });
  var dataUIPartSchema = object$1({
    type: string$1().startsWith("data-"),
    id: string$1().optional(),
    data: unknown()
  });
  var dynamicToolUIPartSchemas = [
    object$1({
      type: literal("dynamic-tool"),
      toolName: string$1(),
      toolCallId: string$1(),
      state: literal("input-streaming"),
      input: unknown().optional(),
      output: never().optional(),
      errorText: never().optional()
    }),
    object$1({
      type: literal("dynamic-tool"),
      toolName: string$1(),
      toolCallId: string$1(),
      state: literal("input-available"),
      input: unknown(),
      output: never().optional(),
      errorText: never().optional(),
      callProviderMetadata: providerMetadataSchema.optional()
    }),
    object$1({
      type: literal("dynamic-tool"),
      toolName: string$1(),
      toolCallId: string$1(),
      state: literal("output-available"),
      input: unknown(),
      output: unknown(),
      errorText: never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      preliminary: boolean$1().optional()
    }),
    object$1({
      type: literal("dynamic-tool"),
      toolName: string$1(),
      toolCallId: string$1(),
      state: literal("output-error"),
      input: unknown(),
      output: never().optional(),
      errorText: string$1(),
      callProviderMetadata: providerMetadataSchema.optional()
    })
  ];
  var toolUIPartSchemas = [
    object$1({
      type: string$1().startsWith("tool-"),
      toolCallId: string$1(),
      state: literal("input-streaming"),
      input: unknown().optional(),
      output: never().optional(),
      errorText: never().optional()
    }),
    object$1({
      type: string$1().startsWith("tool-"),
      toolCallId: string$1(),
      state: literal("input-available"),
      input: unknown(),
      output: never().optional(),
      errorText: never().optional(),
      callProviderMetadata: providerMetadataSchema.optional()
    }),
    object$1({
      type: string$1().startsWith("tool-"),
      toolCallId: string$1(),
      state: literal("output-available"),
      input: unknown(),
      output: unknown(),
      errorText: never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      preliminary: boolean$1().optional()
    }),
    object$1({
      type: string$1().startsWith("tool-"),
      toolCallId: string$1(),
      state: literal("output-error"),
      input: unknown(),
      output: never().optional(),
      errorText: string$1(),
      callProviderMetadata: providerMetadataSchema.optional()
    })
  ];
  object$1({
    id: string$1(),
    role: _enum(["system", "user", "assistant"]),
    metadata: unknown().optional(),
    parts: array(
      union([
        textUIPartSchema,
        reasoningUIPartSchema,
        sourceUrlUIPartSchema,
        sourceDocumentUIPartSchema,
        fileUIPartSchema,
        stepStartUIPartSchema,
        dataUIPartSchema,
        ...dynamicToolUIPartSchemas,
        ...toolUIPartSchemas
      ])
    )
  });

  // src/mistral-provider.ts
  function convertToMistralChatMessages(prompt) {
    const messages = [];
    for (let i = 0; i < prompt.length; i++) {
      const { role, content } = prompt[i];
      const isLastMessage = i === prompt.length - 1;
      switch (role) {
        case "system": {
          messages.push({ role: "system", content });
          break;
        }
        case "user": {
          messages.push({
            role: "user",
            content: content.map((part) => {
              switch (part.type) {
                case "text": {
                  return { type: "text", text: part.text };
                }
                case "file": {
                  if (part.mediaType.startsWith("image/")) {
                    const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                    return {
                      type: "image_url",
                      image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    };
                  } else if (part.mediaType === "application/pdf") {
                    return {
                      type: "document_url",
                      document_url: part.data.toString()
                    };
                  } else {
                    throw new UnsupportedFunctionalityError$1({
                      functionality: "Only images and PDF file parts are supported"
                    });
                  }
                }
              }
            })
          });
          break;
        }
        case "assistant": {
          let text = "";
          const toolCalls = [];
          for (const part of content) {
            switch (part.type) {
              case "text": {
                text += part.text;
                break;
              }
              case "tool-call": {
                toolCalls.push({
                  id: part.toolCallId,
                  type: "function",
                  function: {
                    name: part.toolName,
                    arguments: JSON.stringify(part.input)
                  }
                });
                break;
              }
              case "reasoning": {
                text += part.text;
                break;
              }
              default: {
                throw new Error(
                  `Unsupported content type in assistant message: ${part.type}`
                );
              }
            }
          }
          messages.push({
            role: "assistant",
            content: text,
            prefix: isLastMessage ? true : void 0,
            tool_calls: toolCalls.length > 0 ? toolCalls : void 0
          });
          break;
        }
        case "tool": {
          for (const toolResponse of content) {
            const output = toolResponse.output;
            let contentValue;
            switch (output.type) {
              case "text":
              case "error-text":
                contentValue = output.value;
                break;
              case "content":
              case "json":
              case "error-json":
                contentValue = JSON.stringify(output.value);
                break;
            }
            messages.push({
              role: "tool",
              name: toolResponse.toolName,
              tool_call_id: toolResponse.toolCallId,
              content: contentValue
            });
          }
          break;
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return messages;
  }

  // src/get-response-metadata.ts
  function getResponseMetadata$3({
    id,
    model,
    created
  }) {
    return {
      id: id != null ? id : void 0,
      modelId: model != null ? model : void 0,
      timestamp: created != null ? new Date(created * 1e3) : void 0
    };
  }

  // src/map-mistral-finish-reason.ts
  function mapMistralFinishReason(finishReason) {
    switch (finishReason) {
      case "stop":
        return "stop";
      case "length":
      case "model_length":
        return "length";
      case "tool_calls":
        return "tool-calls";
      default:
        return "unknown";
    }
  }
  var mistralLanguageModelOptions = object$1({
    /**
    Whether to inject a safety prompt before all conversations.
    
    Defaults to `false`.
       */
    safePrompt: boolean$1().optional(),
    documentImageLimit: number$1().optional(),
    documentPageLimit: number$1().optional(),
    /**
     * Whether to use structured outputs.
     *
     * @default true
     */
    structuredOutputs: boolean$1().optional(),
    /**
     * Whether to use strict JSON schema validation.
     *
     * @default false
     */
    strictJsonSchema: boolean$1().optional()
  });
  var mistralErrorDataSchema = object$1({
    object: literal("error"),
    message: string$1(),
    type: string$1(),
    param: string$1().nullable(),
    code: string$1().nullable()
  });
  var mistralFailedResponseHandler = createJsonErrorResponseHandler$1({
    errorSchema: mistralErrorDataSchema,
    errorToMessage: (data) => data.message
  });
  function prepareTools$4({
    tools,
    toolChoice
  }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
      return { tools: void 0, toolChoice: void 0, toolWarnings };
    }
    const mistralTools = [];
    for (const tool of tools) {
      if (tool.type === "provider-defined") {
        toolWarnings.push({ type: "unsupported-tool", tool });
      } else {
        mistralTools.push({
          type: "function",
          function: {
            name: tool.name,
            description: tool.description,
            parameters: tool.inputSchema
          }
        });
      }
    }
    if (toolChoice == null) {
      return { tools: mistralTools, toolChoice: void 0, toolWarnings };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
      case "none":
        return { tools: mistralTools, toolChoice: type, toolWarnings };
      case "required":
        return { tools: mistralTools, toolChoice: "any", toolWarnings };
      case "tool":
        return {
          tools: mistralTools.filter(
            (tool) => tool.function.name === toolChoice.toolName
          ),
          toolChoice: "any",
          toolWarnings
        };
      default: {
        const _exhaustiveCheck = type;
        throw new UnsupportedFunctionalityError$1({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }

  // src/mistral-chat-language-model.ts
  var MistralChatLanguageModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.supportedUrls = {
        "application/pdf": [/^https:\/\/.*$/]
      };
      var _a;
      this.modelId = modelId;
      this.config = config;
      this.generateId = (_a = config.generateId) != null ? _a : generateId$1;
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      providerOptions,
      tools,
      toolChoice
    }) {
      var _a, _b, _c, _d;
      const warnings = [];
      const options = (_a = await parseProviderOptions({
        provider: "mistral",
        providerOptions,
        schema: mistralLanguageModelOptions
      })) != null ? _a : {};
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (stopSequences != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "stopSequences"
        });
      }
      const structuredOutputs = (_b = options.structuredOutputs) != null ? _b : true;
      const strictJsonSchema = (_c = options.strictJsonSchema) != null ? _c : false;
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && !(responseFormat == null ? void 0 : responseFormat.schema)) {
        prompt = injectJsonInstructionIntoMessages({
          messages: prompt,
          schema: responseFormat.schema
        });
      }
      const baseArgs = {
        // model id:
        model: this.modelId,
        // model specific settings:
        safe_prompt: options.safePrompt,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        random_seed: seed,
        // response format:
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && (responseFormat == null ? void 0 : responseFormat.schema) != null ? {
          type: "json_schema",
          json_schema: {
            schema: responseFormat.schema,
            strict: strictJsonSchema,
            name: (_d = responseFormat.name) != null ? _d : "response",
            description: responseFormat.description
          }
        } : { type: "json_object" } : void 0,
        // mistral-specific provider options:
        document_image_limit: options.documentImageLimit,
        document_page_limit: options.documentPageLimit,
        // messages:
        messages: convertToMistralChatMessages(prompt)
      };
      const {
        tools: mistralTools,
        toolChoice: mistralToolChoice,
        toolWarnings
      } = prepareTools$4({
        tools,
        toolChoice
      });
      return {
        args: {
          ...baseArgs,
          tools: mistralTools,
          tool_choice: mistralToolChoice
        },
        warnings: [...warnings, ...toolWarnings]
      };
    }
    async doGenerate(options) {
      const { args: body, warnings } = await this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url: `${this.config.baseURL}/chat/completions`,
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: mistralFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          mistralChatResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      if (choice.message.content != null && Array.isArray(choice.message.content)) {
        for (const part of choice.message.content) {
          if (part.type === "thinking") {
            const reasoningText = extractReasoningContent(part.thinking);
            if (reasoningText.length > 0) {
              content.push({ type: "reasoning", text: reasoningText });
            }
          } else if (part.type === "text") {
            if (part.text.length > 0) {
              content.push({ type: "text", text: part.text });
            }
          }
        }
      } else {
        const text = extractTextContent(choice.message.content);
        if (text != null && text.length > 0) {
          content.push({ type: "text", text });
        }
      }
      if (choice.message.tool_calls != null) {
        for (const toolCall of choice.message.tool_calls) {
          content.push({
            type: "tool-call",
            toolCallId: toolCall.id,
            toolName: toolCall.function.name,
            input: toolCall.function.arguments
          });
        }
      }
      return {
        content,
        finishReason: mapMistralFinishReason(choice.finish_reason),
        usage: {
          inputTokens: response.usage.prompt_tokens,
          outputTokens: response.usage.completion_tokens,
          totalTokens: response.usage.total_tokens
        },
        request: { body },
        response: {
          ...getResponseMetadata$3(response),
          headers: responseHeaders,
          body: rawResponse
        },
        warnings
      };
    }
    async doStream(options) {
      const { args, warnings } = await this.getArgs(options);
      const body = { ...args, stream: true };
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: `${this.config.baseURL}/chat/completions`,
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: mistralFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          mistralChatChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      let activeText = false;
      let activeReasoningId = null;
      const generateId2 = this.generateId;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue({
                  type: "response-metadata",
                  ...getResponseMetadata$3(value)
                });
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                usage.totalTokens = value.usage.total_tokens;
              }
              const choice = value.choices[0];
              const delta = choice.delta;
              const textContent = extractTextContent(delta.content);
              if (delta.content != null && Array.isArray(delta.content)) {
                for (const part of delta.content) {
                  if (part.type === "thinking") {
                    const reasoningDelta = extractReasoningContent(part.thinking);
                    if (reasoningDelta.length > 0) {
                      if (activeReasoningId == null) {
                        if (activeText) {
                          controller.enqueue({ type: "text-end", id: "0" });
                          activeText = false;
                        }
                        activeReasoningId = generateId2();
                        controller.enqueue({
                          type: "reasoning-start",
                          id: activeReasoningId
                        });
                      }
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: activeReasoningId,
                        delta: reasoningDelta
                      });
                    }
                  }
                }
              }
              if (textContent != null && textContent.length > 0) {
                if (!activeText) {
                  if (activeReasoningId != null) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: activeReasoningId
                    });
                    activeReasoningId = null;
                  }
                  controller.enqueue({ type: "text-start", id: "0" });
                  activeText = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: textContent
                });
              }
              if ((delta == null ? void 0 : delta.tool_calls) != null) {
                for (const toolCall of delta.tool_calls) {
                  const toolCallId = toolCall.id;
                  const toolName = toolCall.function.name;
                  const input = toolCall.function.arguments;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCallId,
                    toolName
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCallId,
                    delta: input
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCallId
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId,
                    toolName,
                    input
                  });
                }
              }
              if (choice.finish_reason != null) {
                finishReason = mapMistralFinishReason(choice.finish_reason);
              }
            },
            flush(controller) {
              if (activeReasoningId != null) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: activeReasoningId
                });
              }
              if (activeText) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    }
  };
  function extractReasoningContent(thinking) {
    return thinking.filter((chunk) => chunk.type === "text").map((chunk) => chunk.text).join("");
  }
  function extractTextContent(content) {
    if (typeof content === "string") {
      return content;
    }
    if (content == null) {
      return void 0;
    }
    const textContent = [];
    for (const chunk of content) {
      const { type } = chunk;
      switch (type) {
        case "text":
          textContent.push(chunk.text);
          break;
        case "thinking":
        case "image_url":
        case "reference":
          break;
        default: {
          const _exhaustiveCheck = type;
          throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
        }
      }
    }
    return textContent.length ? textContent.join("") : void 0;
  }
  var mistralContentSchema = union([
    string$1(),
    array(
      discriminatedUnion("type", [
        object$1({
          type: literal("text"),
          text: string$1()
        }),
        object$1({
          type: literal("image_url"),
          image_url: union([
            string$1(),
            object$1({
              url: string$1(),
              detail: string$1().nullable()
            })
          ])
        }),
        object$1({
          type: literal("reference"),
          reference_ids: array(number$1())
        }),
        object$1({
          type: literal("thinking"),
          thinking: array(
            object$1({
              type: literal("text"),
              text: string$1()
            })
          )
        })
      ])
    )
  ]).nullish();
  var mistralUsageSchema = object$1({
    prompt_tokens: number$1(),
    completion_tokens: number$1(),
    total_tokens: number$1()
  });
  var mistralChatResponseSchema = object$1({
    id: string$1().nullish(),
    created: number$1().nullish(),
    model: string$1().nullish(),
    choices: array(
      object$1({
        message: object$1({
          role: literal("assistant"),
          content: mistralContentSchema,
          tool_calls: array(
            object$1({
              id: string$1(),
              function: object$1({ name: string$1(), arguments: string$1() })
            })
          ).nullish()
        }),
        index: number$1(),
        finish_reason: string$1().nullish()
      })
    ),
    object: literal("chat.completion"),
    usage: mistralUsageSchema
  });
  var mistralChatChunkSchema = object$1({
    id: string$1().nullish(),
    created: number$1().nullish(),
    model: string$1().nullish(),
    choices: array(
      object$1({
        delta: object$1({
          role: _enum(["assistant"]).optional(),
          content: mistralContentSchema,
          tool_calls: array(
            object$1({
              id: string$1(),
              function: object$1({ name: string$1(), arguments: string$1() })
            })
          ).nullish()
        }),
        finish_reason: string$1().nullish(),
        index: number$1()
      })
    ),
    usage: mistralUsageSchema.nullish()
  });
  var MistralEmbeddingModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.maxEmbeddingsPerCall = 32;
      this.supportsParallelCalls = false;
      this.modelId = modelId;
      this.config = config;
    }
    get provider() {
      return this.config.provider;
    }
    async doEmbed({
      values,
      abortSignal,
      headers
    }) {
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new TooManyEmbeddingValuesForCallError$1({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const {
        responseHeaders,
        value: response,
        rawValue
      } = await postJsonToApi$1({
        url: `${this.config.baseURL}/embeddings`,
        headers: combineHeaders$1(this.config.headers(), headers),
        body: {
          model: this.modelId,
          input: values,
          encoding_format: "float"
        },
        failedResponseHandler: mistralFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          MistralTextEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.data.map((item) => item.embedding),
        usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
        response: { headers: responseHeaders, body: rawValue }
      };
    }
  };
  var MistralTextEmbeddingResponseSchema = object$1({
    data: array(object$1({ embedding: array(number$1()) })),
    usage: object$1({ prompt_tokens: number$1() }).nullish()
  });

  // src/mistral-provider.ts
  function createMistral(options = {}) {
    var _a;
    const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://api.mistral.ai/v1";
    const getHeaders = () => ({
      Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "MISTRAL_API_KEY",
      description: "Mistral"
    })}`,
      ...options.headers
    });
    const createChatModel = (modelId) => new MistralChatLanguageModel(modelId, {
      provider: "mistral.chat",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: options.generateId
    });
    const createEmbeddingModel = (modelId) => new MistralEmbeddingModel(modelId, {
      provider: "mistral.embedding",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    });
    const provider = function(modelId) {
      if (new.target) {
        throw new Error(
          "The Mistral model function cannot be called with the new keyword."
        );
      }
      return createChatModel(modelId);
    };
    provider.languageModel = createChatModel;
    provider.chat = createChatModel;
    provider.embedding = createEmbeddingModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    provider.imageModel = (modelId) => {
      throw new NoSuchModelError({ modelId, modelType: "imageModel" });
    };
    return provider;
  }
  createMistral();

  // src/google-provider.ts
  var googleErrorDataSchema = object$1({
    error: object$1({
      code: number$1().nullable(),
      message: string$1(),
      status: string$1()
    })
  });
  var googleFailedResponseHandler = createJsonErrorResponseHandler$1({
    errorSchema: googleErrorDataSchema,
    errorToMessage: (data) => data.error.message
  });
  var googleGenerativeAIEmbeddingProviderOptions = object$1({
    /**
     * Optional. Optional reduced dimension for the output embedding.
     * If set, excessive values in the output embedding are truncated from the end.
     */
    outputDimensionality: number$1().optional(),
    /**
     * Optional. Specifies the task type for generating embeddings.
     * Supported task types:
     * - SEMANTIC_SIMILARITY: Optimized for text similarity.
     * - CLASSIFICATION: Optimized for text classification.
     * - CLUSTERING: Optimized for clustering texts based on similarity.
     * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
     * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
     * - QUESTION_ANSWERING: Optimized for answering questions.
     * - FACT_VERIFICATION: Optimized for verifying factual information.
     * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
     */
    taskType: _enum([
      "SEMANTIC_SIMILARITY",
      "CLASSIFICATION",
      "CLUSTERING",
      "RETRIEVAL_DOCUMENT",
      "RETRIEVAL_QUERY",
      "QUESTION_ANSWERING",
      "FACT_VERIFICATION",
      "CODE_RETRIEVAL_QUERY"
    ]).optional()
  });

  // src/google-generative-ai-embedding-model.ts
  var GoogleGenerativeAIEmbeddingModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.maxEmbeddingsPerCall = 2048;
      this.supportsParallelCalls = true;
      this.modelId = modelId;
      this.config = config;
    }
    get provider() {
      return this.config.provider;
    }
    async doEmbed({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      const googleOptions = await parseProviderOptions({
        provider: "google",
        providerOptions,
        schema: googleGenerativeAIEmbeddingProviderOptions
      });
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new TooManyEmbeddingValuesForCallError$1({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const mergedHeaders = combineHeaders$1(
        await resolve(this.config.headers),
        headers
      );
      if (values.length === 1) {
        const {
          responseHeaders: responseHeaders2,
          value: response2,
          rawValue: rawValue2
        } = await postJsonToApi$1({
          url: `${this.config.baseURL}/models/${this.modelId}:embedContent`,
          headers: mergedHeaders,
          body: {
            model: `models/${this.modelId}`,
            content: {
              parts: [{ text: values[0] }]
            },
            outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
            taskType: googleOptions == null ? void 0 : googleOptions.taskType
          },
          failedResponseHandler: googleFailedResponseHandler,
          successfulResponseHandler: createJsonResponseHandler$1(
            googleGenerativeAISingleEmbeddingResponseSchema
          ),
          abortSignal,
          fetch: this.config.fetch
        });
        return {
          embeddings: [response2.embedding.values],
          usage: void 0,
          response: { headers: responseHeaders2, body: rawValue2 }
        };
      }
      const {
        responseHeaders,
        value: response,
        rawValue
      } = await postJsonToApi$1({
        url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
        headers: mergedHeaders,
        body: {
          requests: values.map((value) => ({
            model: `models/${this.modelId}`,
            content: { role: "user", parts: [{ text: value }] },
            outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
            taskType: googleOptions == null ? void 0 : googleOptions.taskType
          }))
        },
        failedResponseHandler: googleFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          googleGenerativeAITextEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.embeddings.map((item) => item.values),
        usage: void 0,
        response: { headers: responseHeaders, body: rawValue }
      };
    }
  };
  var googleGenerativeAITextEmbeddingResponseSchema = object$1({
    embeddings: array(object$1({ values: array(number$1()) }))
  });
  var googleGenerativeAISingleEmbeddingResponseSchema = object$1({
    embedding: object$1({ values: array(number$1()) })
  });

  // src/convert-json-schema-to-openapi-schema.ts
  function convertJSONSchemaToOpenAPISchema(jsonSchema) {
    if (jsonSchema == null || isEmptyObjectSchema(jsonSchema)) {
      return void 0;
    }
    if (typeof jsonSchema === "boolean") {
      return { type: "boolean", properties: {} };
    }
    const {
      type,
      description,
      required,
      properties,
      items,
      allOf,
      anyOf,
      oneOf,
      format,
      const: constValue,
      minLength,
      enum: enumValues
    } = jsonSchema;
    const result = {};
    if (description)
      result.description = description;
    if (required)
      result.required = required;
    if (format)
      result.format = format;
    if (constValue !== void 0) {
      result.enum = [constValue];
    }
    if (type) {
      if (Array.isArray(type)) {
        if (type.includes("null")) {
          result.type = type.filter((t) => t !== "null")[0];
          result.nullable = true;
        } else {
          result.type = type;
        }
      } else if (type === "null") {
        result.type = "null";
      } else {
        result.type = type;
      }
    }
    if (enumValues !== void 0) {
      result.enum = enumValues;
    }
    if (properties != null) {
      result.properties = Object.entries(properties).reduce(
        (acc, [key, value]) => {
          acc[key] = convertJSONSchemaToOpenAPISchema(value);
          return acc;
        },
        {}
      );
    }
    if (items) {
      result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);
    }
    if (allOf) {
      result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);
    }
    if (anyOf) {
      if (anyOf.some(
        (schema) => typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"
      )) {
        const nonNullSchemas = anyOf.filter(
          (schema) => !(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")
        );
        if (nonNullSchemas.length === 1) {
          const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);
          if (typeof converted === "object") {
            result.nullable = true;
            Object.assign(result, converted);
          }
        } else {
          result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);
          result.nullable = true;
        }
      } else {
        result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);
      }
    }
    if (oneOf) {
      result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);
    }
    if (minLength !== void 0) {
      result.minLength = minLength;
    }
    return result;
  }
  function isEmptyObjectSchema(jsonSchema) {
    return jsonSchema != null && typeof jsonSchema === "object" && jsonSchema.type === "object" && (jsonSchema.properties == null || Object.keys(jsonSchema.properties).length === 0) && !jsonSchema.additionalProperties;
  }
  function convertToGoogleGenerativeAIMessages(prompt, options) {
    var _a;
    const systemInstructionParts = [];
    const contents = [];
    let systemMessagesAllowed = true;
    const isGemmaModel = (_a = options == null ? void 0 : options.isGemmaModel) != null ? _a : false;
    for (const { role, content } of prompt) {
      switch (role) {
        case "system": {
          if (!systemMessagesAllowed) {
            throw new UnsupportedFunctionalityError$1({
              functionality: "system messages are only supported at the beginning of the conversation"
            });
          }
          systemInstructionParts.push({ text: content });
          break;
        }
        case "user": {
          systemMessagesAllowed = false;
          const parts = [];
          for (const part of content) {
            switch (part.type) {
              case "text": {
                parts.push({ text: part.text });
                break;
              }
              case "file": {
                const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                parts.push(
                  part.data instanceof URL ? {
                    fileData: {
                      mimeType: mediaType,
                      fileUri: part.data.toString()
                    }
                  } : {
                    inlineData: {
                      mimeType: mediaType,
                      data: convertToBase64(part.data)
                    }
                  }
                );
                break;
              }
            }
          }
          contents.push({ role: "user", parts });
          break;
        }
        case "assistant": {
          systemMessagesAllowed = false;
          contents.push({
            role: "model",
            parts: content.map((part) => {
              var _a2, _b, _c, _d, _e, _f;
              switch (part.type) {
                case "text": {
                  return part.text.length === 0 ? void 0 : {
                    text: part.text,
                    thoughtSignature: (_b = (_a2 = part.providerOptions) == null ? void 0 : _a2.google) == null ? void 0 : _b.thoughtSignature
                  };
                }
                case "reasoning": {
                  return part.text.length === 0 ? void 0 : {
                    text: part.text,
                    thought: true,
                    thoughtSignature: (_d = (_c = part.providerOptions) == null ? void 0 : _c.google) == null ? void 0 : _d.thoughtSignature
                  };
                }
                case "file": {
                  if (part.mediaType !== "image/png") {
                    throw new UnsupportedFunctionalityError$1({
                      functionality: "Only PNG images are supported in assistant messages"
                    });
                  }
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError$1({
                      functionality: "File data URLs in assistant messages are not supported"
                    });
                  }
                  return {
                    inlineData: {
                      mimeType: part.mediaType,
                      data: convertToBase64(part.data)
                    }
                  };
                }
                case "tool-call": {
                  return {
                    functionCall: {
                      name: part.toolName,
                      args: part.input
                    },
                    thoughtSignature: (_f = (_e = part.providerOptions) == null ? void 0 : _e.google) == null ? void 0 : _f.thoughtSignature
                  };
                }
              }
            }).filter((part) => part !== void 0)
          });
          break;
        }
        case "tool": {
          systemMessagesAllowed = false;
          contents.push({
            role: "user",
            parts: content.map((part) => ({
              functionResponse: {
                name: part.toolName,
                response: {
                  name: part.toolName,
                  content: part.output.value
                }
              }
            }))
          });
          break;
        }
      }
    }
    if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
      const systemText = systemInstructionParts.map((part) => part.text).join("\n\n");
      contents[0].parts.unshift({ text: systemText + "\n\n" });
    }
    return {
      systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? { parts: systemInstructionParts } : void 0,
      contents
    };
  }

  // src/get-model-path.ts
  function getModelPath(modelId) {
    return modelId.includes("/") ? modelId : `models/${modelId}`;
  }
  var googleGenerativeAIProviderOptions = object$1({
    responseModalities: array(_enum(["TEXT", "IMAGE"])).optional(),
    thinkingConfig: object$1({
      thinkingBudget: number$1().optional(),
      includeThoughts: boolean$1().optional()
    }).optional(),
    /**
    Optional.
    The name of the cached content used as context to serve the prediction.
    Format: cachedContents/{cachedContent}
       */
    cachedContent: string$1().optional(),
    /**
     * Optional. Enable structured output. Default is true.
     *
     * This is useful when the JSON Schema contains elements that are
     * not supported by the OpenAPI schema version that
     * Google Generative AI uses. You can use this to disable
     * structured outputs if you need to.
     */
    structuredOutputs: boolean$1().optional(),
    /**
    Optional. A list of unique safety settings for blocking unsafe content.
     */
    safetySettings: array(
      object$1({
        category: _enum([
          "HARM_CATEGORY_UNSPECIFIED",
          "HARM_CATEGORY_HATE_SPEECH",
          "HARM_CATEGORY_DANGEROUS_CONTENT",
          "HARM_CATEGORY_HARASSMENT",
          "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          "HARM_CATEGORY_CIVIC_INTEGRITY"
        ]),
        threshold: _enum([
          "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
          "BLOCK_LOW_AND_ABOVE",
          "BLOCK_MEDIUM_AND_ABOVE",
          "BLOCK_ONLY_HIGH",
          "BLOCK_NONE",
          "OFF"
        ])
      })
    ).optional(),
    threshold: _enum([
      "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
      "BLOCK_LOW_AND_ABOVE",
      "BLOCK_MEDIUM_AND_ABOVE",
      "BLOCK_ONLY_HIGH",
      "BLOCK_NONE",
      "OFF"
    ]).optional(),
    /**
     * Optional. Enables timestamp understanding for audio-only files.
     *
     * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/audio-understanding
     */
    audioTimestamp: boolean$1().optional(),
    /**
     * Optional. Defines labels used in billing reports. Available on Vertex AI only.
     *
     * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls
     */
    labels: record(string$1(), string$1()).optional()
  });
  function prepareTools$3({
    tools,
    toolChoice,
    modelId
  }) {
    var _a;
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    const isGemini2 = modelId.includes("gemini-2");
    const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
    if (tools == null) {
      return { tools: void 0, toolConfig: void 0, toolWarnings };
    }
    const hasFunctionTools = tools.some((tool) => tool.type === "function");
    const hasProviderDefinedTools = tools.some(
      (tool) => tool.type === "provider-defined"
    );
    if (hasFunctionTools && hasProviderDefinedTools) {
      toolWarnings.push({
        type: "unsupported-tool",
        tool: tools.find((tool) => tool.type === "function"),
        details: "Cannot mix function tools with provider-defined tools in the same request. Please use either function tools or provider-defined tools, but not both."
      });
    }
    if (hasProviderDefinedTools) {
      const googleTools2 = {};
      const providerDefinedTools = tools.filter(
        (tool) => tool.type === "provider-defined"
      );
      providerDefinedTools.forEach((tool) => {
        switch (tool.id) {
          case "google.google_search":
            if (isGemini2) {
              googleTools2.googleSearch = {};
            } else if (supportsDynamicRetrieval) {
              googleTools2.googleSearchRetrieval = {
                dynamicRetrievalConfig: {
                  mode: tool.args.mode,
                  dynamicThreshold: tool.args.dynamicThreshold
                }
              };
            } else {
              googleTools2.googleSearchRetrieval = {};
            }
            break;
          case "google.url_context":
            if (isGemini2) {
              googleTools2.urlContext = {};
            } else {
              toolWarnings.push({
                type: "unsupported-tool",
                tool,
                details: "The URL context tool is not supported with other Gemini models than Gemini 2."
              });
            }
            break;
          case "google.code_execution":
            if (isGemini2) {
              googleTools2.codeExecution = {};
            } else {
              toolWarnings.push({
                type: "unsupported-tool",
                tool,
                details: "The code execution tools is not supported with other Gemini models than Gemini 2."
              });
            }
            break;
          default:
            toolWarnings.push({ type: "unsupported-tool", tool });
            break;
        }
      });
      return {
        tools: Object.keys(googleTools2).length > 0 ? googleTools2 : void 0,
        toolConfig: void 0,
        toolWarnings
      };
    }
    const functionDeclarations = [];
    for (const tool of tools) {
      switch (tool.type) {
        case "function":
          functionDeclarations.push({
            name: tool.name,
            description: (_a = tool.description) != null ? _a : "",
            parameters: convertJSONSchemaToOpenAPISchema(tool.inputSchema)
          });
          break;
        default:
          toolWarnings.push({ type: "unsupported-tool", tool });
          break;
      }
    }
    if (toolChoice == null) {
      return {
        tools: { functionDeclarations },
        toolConfig: void 0,
        toolWarnings
      };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
        return {
          tools: { functionDeclarations },
          toolConfig: { functionCallingConfig: { mode: "AUTO" } },
          toolWarnings
        };
      case "none":
        return {
          tools: { functionDeclarations },
          toolConfig: { functionCallingConfig: { mode: "NONE" } },
          toolWarnings
        };
      case "required":
        return {
          tools: { functionDeclarations },
          toolConfig: { functionCallingConfig: { mode: "ANY" } },
          toolWarnings
        };
      case "tool":
        return {
          tools: { functionDeclarations },
          toolConfig: {
            functionCallingConfig: {
              mode: "ANY",
              allowedFunctionNames: [toolChoice.toolName]
            }
          },
          toolWarnings
        };
      default: {
        const _exhaustiveCheck = type;
        throw new UnsupportedFunctionalityError$1({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }

  // src/map-google-generative-ai-finish-reason.ts
  function mapGoogleGenerativeAIFinishReason({
    finishReason,
    hasToolCalls
  }) {
    switch (finishReason) {
      case "STOP":
        return hasToolCalls ? "tool-calls" : "stop";
      case "MAX_TOKENS":
        return "length";
      case "IMAGE_SAFETY":
      case "RECITATION":
      case "SAFETY":
      case "BLOCKLIST":
      case "PROHIBITED_CONTENT":
      case "SPII":
        return "content-filter";
      case "FINISH_REASON_UNSPECIFIED":
      case "OTHER":
        return "other";
      case "MALFORMED_FUNCTION_CALL":
        return "error";
      default:
        return "unknown";
    }
  }
  var groundingChunkSchema = object$1({
    web: object$1({ uri: string$1(), title: string$1() }).nullish(),
    retrievedContext: object$1({ uri: string$1(), title: string$1() }).nullish()
  });
  var groundingMetadataSchema = object$1({
    webSearchQueries: array(string$1()).nullish(),
    retrievalQueries: array(string$1()).nullish(),
    searchEntryPoint: object$1({ renderedContent: string$1() }).nullish(),
    groundingChunks: array(groundingChunkSchema).nullish(),
    groundingSupports: array(
      object$1({
        segment: object$1({
          startIndex: number$1().nullish(),
          endIndex: number$1().nullish(),
          text: string$1().nullish()
        }),
        segment_text: string$1().nullish(),
        groundingChunkIndices: array(number$1()).nullish(),
        supportChunkIndices: array(number$1()).nullish(),
        confidenceScores: array(number$1()).nullish(),
        confidenceScore: array(number$1()).nullish()
      })
    ).nullish(),
    retrievalMetadata: union([
      object$1({
        webDynamicRetrievalScore: number$1()
      }),
      object$1({})
    ]).nullish()
  });
  var googleSearch = createProviderDefinedToolFactory({
    id: "google.google_search",
    name: "google_search",
    inputSchema: object$1({
      mode: _enum(["MODE_DYNAMIC", "MODE_UNSPECIFIED"]).default("MODE_UNSPECIFIED"),
      dynamicThreshold: number$1().default(1)
    })
  });
  var urlMetadataSchema = object$1({
    retrievedUrl: string$1(),
    urlRetrievalStatus: string$1()
  });
  var urlContextMetadataSchema = object$1({
    urlMetadata: array(urlMetadataSchema)
  });
  var urlContext = createProviderDefinedToolFactory({
    id: "google.url_context",
    name: "url_context",
    inputSchema: object$1({})
  });

  // src/google-generative-ai-language-model.ts
  var GoogleGenerativeAILanguageModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      var _a;
      this.modelId = modelId;
      this.config = config;
      this.generateId = (_a = config.generateId) != null ? _a : generateId$1;
    }
    get provider() {
      return this.config.provider;
    }
    get supportedUrls() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
    }
    async getArgs({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a, _b;
      const warnings = [];
      const googleOptions = await parseProviderOptions({
        provider: "google",
        providerOptions,
        schema: googleGenerativeAIProviderOptions
      });
      if (((_a = googleOptions == null ? void 0 : googleOptions.thinkingConfig) == null ? void 0 : _a.includeThoughts) === true && !this.config.provider.startsWith("google.vertex.")) {
        warnings.push({
          type: "other",
          message: `The 'includeThoughts' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
        });
      }
      const isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-");
      const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(
        prompt,
        { isGemmaModel }
      );
      const {
        tools: googleTools2,
        toolConfig: googleToolConfig,
        toolWarnings
      } = prepareTools$3({
        tools,
        toolChoice,
        modelId: this.modelId
      });
      return {
        args: {
          generationConfig: {
            // standardized settings:
            maxOutputTokens,
            temperature,
            topK,
            topP,
            frequencyPenalty,
            presencePenalty,
            stopSequences,
            seed,
            // response format:
            responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
            responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,
            // so this is needed as an escape hatch:
            // TODO convert into provider option
            ((_b = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _b : true) ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0,
            ...(googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
              audioTimestamp: googleOptions.audioTimestamp
            },
            // provider options:
            responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
            thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig
          },
          contents,
          systemInstruction: isGemmaModel ? void 0 : systemInstruction,
          safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
          tools: googleTools2,
          toolConfig: googleToolConfig,
          cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
          labels: googleOptions == null ? void 0 : googleOptions.labels
        },
        warnings: [...warnings, ...toolWarnings]
      };
    }
    async doGenerate(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      const { args, warnings } = await this.getArgs(options);
      const body = JSON.stringify(args);
      const mergedHeaders = combineHeaders$1(
        await resolve(this.config.headers),
        options.headers
      );
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url: `${this.config.baseURL}/${getModelPath(
        this.modelId
      )}:generateContent`,
        headers: mergedHeaders,
        body: args,
        failedResponseHandler: googleFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(responseSchema),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const candidate = response.candidates[0];
      const content = [];
      const parts = (_b = (_a = candidate.content) == null ? void 0 : _a.parts) != null ? _b : [];
      const usageMetadata = response.usageMetadata;
      let lastCodeExecutionToolCallId;
      for (const part of parts) {
        if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
          const toolCallId = this.config.generateId();
          lastCodeExecutionToolCallId = toolCallId;
          content.push({
            type: "tool-call",
            toolCallId,
            toolName: "code_execution",
            input: JSON.stringify(part.executableCode),
            providerExecuted: true
          });
        } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
          content.push({
            type: "tool-result",
            // Assumes a result directly follows its corresponding call part.
            toolCallId: lastCodeExecutionToolCallId,
            toolName: "code_execution",
            result: {
              outcome: part.codeExecutionResult.outcome,
              output: part.codeExecutionResult.output
            },
            providerExecuted: true
          });
          lastCodeExecutionToolCallId = void 0;
        } else if ("text" in part && part.text != null && part.text.length > 0) {
          content.push({
            type: part.thought === true ? "reasoning" : "text",
            text: part.text,
            providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
          });
        } else if ("functionCall" in part) {
          content.push({
            type: "tool-call",
            toolCallId: this.config.generateId(),
            toolName: part.functionCall.name,
            input: JSON.stringify(part.functionCall.args),
            providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
          });
        } else if ("inlineData" in part) {
          content.push({
            type: "file",
            data: part.inlineData.data,
            mediaType: part.inlineData.mimeType
          });
        }
      }
      const sources = (_d = extractSources({
        groundingMetadata: candidate.groundingMetadata,
        generateId: this.config.generateId
      })) != null ? _d : [];
      for (const source of sources) {
        content.push(source);
      }
      return {
        content,
        finishReason: mapGoogleGenerativeAIFinishReason({
          finishReason: candidate.finishReason,
          hasToolCalls: content.some((part) => part.type === "tool-call")
        }),
        usage: {
          inputTokens: (_e = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _e : void 0,
          outputTokens: (_f = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _f : void 0,
          totalTokens: (_g = usageMetadata == null ? void 0 : usageMetadata.totalTokenCount) != null ? _g : void 0,
          reasoningTokens: (_h = usageMetadata == null ? void 0 : usageMetadata.thoughtsTokenCount) != null ? _h : void 0,
          cachedInputTokens: (_i = usageMetadata == null ? void 0 : usageMetadata.cachedContentTokenCount) != null ? _i : void 0
        },
        warnings,
        providerMetadata: {
          google: {
            groundingMetadata: (_j = candidate.groundingMetadata) != null ? _j : null,
            urlContextMetadata: (_k = candidate.urlContextMetadata) != null ? _k : null,
            safetyRatings: (_l = candidate.safetyRatings) != null ? _l : null,
            usageMetadata: usageMetadata != null ? usageMetadata : null
          }
        },
        request: { body },
        response: {
          // TODO timestamp, model id, id
          headers: responseHeaders,
          body: rawResponse
        }
      };
    }
    async doStream(options) {
      const { args, warnings } = await this.getArgs(options);
      const body = JSON.stringify(args);
      const headers = combineHeaders$1(
        await resolve(this.config.headers),
        options.headers
      );
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: `${this.config.baseURL}/${getModelPath(
        this.modelId
      )}:streamGenerateContent?alt=sse`,
        headers,
        body: args,
        failedResponseHandler: googleFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(chunkSchema),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let providerMetadata = void 0;
      const generateId3 = this.config.generateId;
      let hasToolCalls = false;
      let currentTextBlockId = null;
      let currentReasoningBlockId = null;
      let blockCounter = 0;
      const emittedSourceUrls = /* @__PURE__ */ new Set();
      let lastCodeExecutionToolCallId;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              const usageMetadata = value.usageMetadata;
              if (usageMetadata != null) {
                usage.inputTokens = (_a = usageMetadata.promptTokenCount) != null ? _a : void 0;
                usage.outputTokens = (_b = usageMetadata.candidatesTokenCount) != null ? _b : void 0;
                usage.totalTokens = (_c = usageMetadata.totalTokenCount) != null ? _c : void 0;
                usage.reasoningTokens = (_d = usageMetadata.thoughtsTokenCount) != null ? _d : void 0;
                usage.cachedInputTokens = (_e = usageMetadata.cachedContentTokenCount) != null ? _e : void 0;
              }
              const candidate = (_f = value.candidates) == null ? void 0 : _f[0];
              if (candidate == null) {
                return;
              }
              const content = candidate.content;
              const sources = extractSources({
                groundingMetadata: candidate.groundingMetadata,
                generateId: generateId3
              });
              if (sources != null) {
                for (const source of sources) {
                  if (source.sourceType === "url" && !emittedSourceUrls.has(source.url)) {
                    emittedSourceUrls.add(source.url);
                    controller.enqueue(source);
                  }
                }
              }
              if (content != null) {
                const parts = (_g = content.parts) != null ? _g : [];
                for (const part of parts) {
                  if ("executableCode" in part && ((_h = part.executableCode) == null ? void 0 : _h.code)) {
                    const toolCallId = generateId3();
                    lastCodeExecutionToolCallId = toolCallId;
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId,
                      toolName: "code_execution",
                      input: JSON.stringify(part.executableCode),
                      providerExecuted: true
                    });
                    hasToolCalls = true;
                  } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                    const toolCallId = lastCodeExecutionToolCallId;
                    if (toolCallId) {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId,
                        toolName: "code_execution",
                        result: {
                          outcome: part.codeExecutionResult.outcome,
                          output: part.codeExecutionResult.output
                        },
                        providerExecuted: true
                      });
                      lastCodeExecutionToolCallId = void 0;
                    }
                  } else if ("text" in part && part.text != null && part.text.length > 0) {
                    if (part.thought === true) {
                      if (currentTextBlockId !== null) {
                        controller.enqueue({
                          type: "text-end",
                          id: currentTextBlockId
                        });
                        currentTextBlockId = null;
                      }
                      if (currentReasoningBlockId === null) {
                        currentReasoningBlockId = String(blockCounter++);
                        controller.enqueue({
                          type: "reasoning-start",
                          id: currentReasoningBlockId,
                          providerMetadata: part.thoughtSignature ? {
                            google: {
                              thoughtSignature: part.thoughtSignature
                            }
                          } : void 0
                        });
                      }
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: currentReasoningBlockId,
                        delta: part.text,
                        providerMetadata: part.thoughtSignature ? {
                          google: { thoughtSignature: part.thoughtSignature }
                        } : void 0
                      });
                    } else {
                      if (currentReasoningBlockId !== null) {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: currentReasoningBlockId
                        });
                        currentReasoningBlockId = null;
                      }
                      if (currentTextBlockId === null) {
                        currentTextBlockId = String(blockCounter++);
                        controller.enqueue({
                          type: "text-start",
                          id: currentTextBlockId,
                          providerMetadata: part.thoughtSignature ? {
                            google: {
                              thoughtSignature: part.thoughtSignature
                            }
                          } : void 0
                        });
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: currentTextBlockId,
                        delta: part.text,
                        providerMetadata: part.thoughtSignature ? {
                          google: { thoughtSignature: part.thoughtSignature }
                        } : void 0
                      });
                    }
                  }
                }
                const inlineDataParts = getInlineDataParts(content.parts);
                if (inlineDataParts != null) {
                  for (const part of inlineDataParts) {
                    controller.enqueue({
                      type: "file",
                      mediaType: part.inlineData.mimeType,
                      data: part.inlineData.data
                    });
                  }
                }
                const toolCallDeltas = getToolCallsFromParts({
                  parts: content.parts,
                  generateId: generateId3
                });
                if (toolCallDeltas != null) {
                  for (const toolCall of toolCallDeltas) {
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCall.toolCallId,
                      toolName: toolCall.toolName,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall.toolCallId,
                      delta: toolCall.args,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.toolCallId,
                      providerMetadata: toolCall.providerMetadata
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: toolCall.toolCallId,
                      toolName: toolCall.toolName,
                      input: toolCall.args,
                      providerMetadata: toolCall.providerMetadata
                    });
                    hasToolCalls = true;
                  }
                }
              }
              if (candidate.finishReason != null) {
                finishReason = mapGoogleGenerativeAIFinishReason({
                  finishReason: candidate.finishReason,
                  hasToolCalls
                });
                providerMetadata = {
                  google: {
                    groundingMetadata: (_i = candidate.groundingMetadata) != null ? _i : null,
                    urlContextMetadata: (_j = candidate.urlContextMetadata) != null ? _j : null,
                    safetyRatings: (_k = candidate.safetyRatings) != null ? _k : null
                  }
                };
                if (usageMetadata != null) {
                  providerMetadata.google.usageMetadata = usageMetadata;
                }
              }
            },
            flush(controller) {
              if (currentTextBlockId !== null) {
                controller.enqueue({
                  type: "text-end",
                  id: currentTextBlockId
                });
              }
              if (currentReasoningBlockId !== null) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: currentReasoningBlockId
                });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          })
        ),
        response: { headers: responseHeaders },
        request: { body }
      };
    }
  };
  function getToolCallsFromParts({
    parts,
    generateId: generateId3
  }) {
    const functionCallParts = parts == null ? void 0 : parts.filter(
      (part) => "functionCall" in part
    );
    return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({
      type: "tool-call",
      toolCallId: generateId3(),
      toolName: part.functionCall.name,
      args: JSON.stringify(part.functionCall.args),
      providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
    }));
  }
  function getInlineDataParts(parts) {
    return parts == null ? void 0 : parts.filter(
      (part) => "inlineData" in part
    );
  }
  function extractSources({
    groundingMetadata,
    generateId: generateId3
  }) {
    var _a;
    return (_a = groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks) == null ? void 0 : _a.filter(
      (chunk) => chunk.web != null
    ).map((chunk) => ({
      type: "source",
      sourceType: "url",
      id: generateId3(),
      url: chunk.web.uri,
      title: chunk.web.title
    }));
  }
  var contentSchema = object$1({
    parts: array(
      union([
        // note: order matters since text can be fully empty
        object$1({
          functionCall: object$1({
            name: string$1(),
            args: unknown()
          }),
          thoughtSignature: string$1().nullish()
        }),
        object$1({
          inlineData: object$1({
            mimeType: string$1(),
            data: string$1()
          })
        }),
        object$1({
          executableCode: object$1({
            language: string$1(),
            code: string$1()
          }).nullish(),
          codeExecutionResult: object$1({
            outcome: string$1(),
            output: string$1()
          }).nullish(),
          text: string$1().nullish(),
          thought: boolean$1().nullish(),
          thoughtSignature: string$1().nullish()
        })
      ])
    ).nullish()
  });
  var safetyRatingSchema = object$1({
    category: string$1().nullish(),
    probability: string$1().nullish(),
    probabilityScore: number$1().nullish(),
    severity: string$1().nullish(),
    severityScore: number$1().nullish(),
    blocked: boolean$1().nullish()
  });
  var usageSchema$2 = object$1({
    cachedContentTokenCount: number$1().nullish(),
    thoughtsTokenCount: number$1().nullish(),
    promptTokenCount: number$1().nullish(),
    candidatesTokenCount: number$1().nullish(),
    totalTokenCount: number$1().nullish()
  });
  var responseSchema = object$1({
    candidates: array(
      object$1({
        content: contentSchema.nullish().or(object$1({}).strict()),
        finishReason: string$1().nullish(),
        safetyRatings: array(safetyRatingSchema).nullish(),
        groundingMetadata: groundingMetadataSchema.nullish(),
        urlContextMetadata: urlContextMetadataSchema.nullish()
      })
    ),
    usageMetadata: usageSchema$2.nullish()
  });
  var chunkSchema = object$1({
    candidates: array(
      object$1({
        content: contentSchema.nullish(),
        finishReason: string$1().nullish(),
        safetyRatings: array(safetyRatingSchema).nullish(),
        groundingMetadata: groundingMetadataSchema.nullish(),
        urlContextMetadata: urlContextMetadataSchema.nullish()
      })
    ).nullish(),
    usageMetadata: usageSchema$2.nullish()
  });
  var codeExecution = createProviderDefinedToolFactoryWithOutputSchema({
    id: "google.code_execution",
    name: "code_execution",
    inputSchema: object$1({
      language: string$1().describe("The programming language of the code."),
      code: string$1().describe("The code to be executed.")
    }),
    outputSchema: object$1({
      outcome: string$1().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
      output: string$1().describe("The output from the code execution.")
    })
  });

  // src/google-tools.ts
  var googleTools = {
    /**
     * Creates a Google search tool that gives Google direct access to real-time web content.
     * Must have name "google_search".
     */
    googleSearch,
    /**
     * Creates a URL context tool that gives Google direct access to real-time web content.
     * Must have name "url_context".
     */
    urlContext,
    /**
     * A tool that enables the model to generate and run Python code.
     * Must have name "code_execution".
     *
     * @note Ensure the selected model supports Code Execution.
     * Multi-tool usage with the code execution tool is typically compatible with Gemini >=2 models.
     *
     * @see https://ai.google.dev/gemini-api/docs/code-execution (Google AI)
     * @see https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/code-execution-api (Vertex AI)
     */
    codeExecution
  };
  var GoogleGenerativeAIImageModel = class {
    constructor(modelId, settings, config) {
      this.modelId = modelId;
      this.settings = settings;
      this.config = config;
      this.specificationVersion = "v2";
    }
    get maxImagesPerCall() {
      var _a;
      return (_a = this.settings.maxImagesPerCall) != null ? _a : 4;
    }
    get provider() {
      return this.config.provider;
    }
    async doGenerate(options) {
      var _a, _b, _c;
      const {
        prompt,
        n = 1,
        size = "1024x1024",
        aspectRatio = "1:1",
        seed,
        providerOptions,
        headers,
        abortSignal
      } = options;
      const warnings = [];
      if (size != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "size",
          details: "This model does not support the `size` option. Use `aspectRatio` instead."
        });
      }
      if (seed != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "seed",
          details: "This model does not support the `seed` option through this provider."
        });
      }
      const googleOptions = await parseProviderOptions({
        provider: "google",
        providerOptions,
        schema: googleImageProviderOptionsSchema
      });
      const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
      const parameters = {
        sampleCount: n
      };
      if (aspectRatio != null) {
        parameters.aspectRatio = aspectRatio;
      }
      if (googleOptions) {
        Object.assign(parameters, googleOptions);
      }
      const body = {
        instances: [{ prompt }],
        parameters
      };
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: `${this.config.baseURL}/models/${this.modelId}:predict`,
        headers: combineHeaders$1(await resolve(this.config.headers), headers),
        body,
        failedResponseHandler: googleFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          googleImageResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response.predictions.map(
          (p) => p.bytesBase64Encoded
        ),
        warnings: warnings != null ? warnings : [],
        providerMetadata: {
          google: {
            images: response.predictions.map((prediction) => ({
              // Add any prediction-specific metadata here
            }))
          }
        },
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    }
  };
  var googleImageResponseSchema = object$1({
    predictions: array(object$1({ bytesBase64Encoded: string$1() })).default([])
  });
  var googleImageProviderOptionsSchema = object$1({
    personGeneration: _enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
    aspectRatio: _enum(["1:1", "3:4", "4:3", "9:16", "16:9"]).nullish()
  });

  // src/google-provider.ts
  function createGoogleGenerativeAI(options = {}) {
    var _a;
    const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://generativelanguage.googleapis.com/v1beta";
    const getHeaders = () => ({
      "x-goog-api-key": loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
        description: "Google Generative AI"
      }),
      ...options.headers
    });
    const createChatModel = (modelId) => {
      var _a2;
      return new GoogleGenerativeAILanguageModel(modelId, {
        provider: "google.generative-ai",
        baseURL,
        headers: getHeaders,
        generateId: (_a2 = options.generateId) != null ? _a2 : generateId$1,
        supportedUrls: () => ({
          "*": [
            // Google Generative Language "files" endpoint
            // e.g. https://generativelanguage.googleapis.com/v1beta/files/...
            new RegExp(`^${baseURL}/files/.*$`),
            // YouTube URLs (public or unlisted videos)
            new RegExp(
              `^https://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+(?:&[\\w=&.-]*)?$`
            ),
            new RegExp(`^https://youtu\\.be/[\\w-]+(?:\\?[\\w=&.-]*)?$`)
          ]
        }),
        fetch: options.fetch
      });
    };
    const createEmbeddingModel = (modelId) => new GoogleGenerativeAIEmbeddingModel(modelId, {
      provider: "google.generative-ai",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    });
    const createImageModel = (modelId, settings = {}) => new GoogleGenerativeAIImageModel(modelId, settings, {
      provider: "google.generative-ai",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    });
    const provider = function(modelId) {
      if (new.target) {
        throw new Error(
          "The Google Generative AI model function cannot be called with the new keyword."
        );
      }
      return createChatModel(modelId);
    };
    provider.languageModel = createChatModel;
    provider.chat = createChatModel;
    provider.generativeAI = createChatModel;
    provider.embedding = createEmbeddingModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    provider.image = createImageModel;
    provider.imageModel = createImageModel;
    provider.tools = googleTools;
    return provider;
  }
  createGoogleGenerativeAI();

  // src/openai-provider.ts
  var openaiErrorDataSchema = object$1({
    error: object$1({
      message: string$1(),
      // The additional information below is handled loosely to support
      // OpenAI-compatible providers that have slightly different error
      // responses:
      type: string$1().nullish(),
      param: any().nullish(),
      code: union([string$1(), number$1()]).nullish()
    })
  });
  var openaiFailedResponseHandler = createJsonErrorResponseHandler$1({
    errorSchema: openaiErrorDataSchema,
    errorToMessage: (data) => data.error.message
  });
  function convertToOpenAIChatMessages({
    prompt,
    systemMessageMode = "system"
  }) {
    const messages = [];
    const warnings = [];
    for (const { role, content } of prompt) {
      switch (role) {
        case "system": {
          switch (systemMessageMode) {
            case "system": {
              messages.push({ role: "system", content });
              break;
            }
            case "developer": {
              messages.push({ role: "developer", content });
              break;
            }
            case "remove": {
              warnings.push({
                type: "other",
                message: "system messages are removed for this model"
              });
              break;
            }
            default: {
              const _exhaustiveCheck = systemMessageMode;
              throw new Error(
                `Unsupported system message mode: ${_exhaustiveCheck}`
              );
            }
          }
          break;
        }
        case "user": {
          if (content.length === 1 && content[0].type === "text") {
            messages.push({ role: "user", content: content[0].text });
            break;
          }
          messages.push({
            role: "user",
            content: content.map((part, index) => {
              var _a, _b, _c;
              switch (part.type) {
                case "text": {
                  return { type: "text", text: part.text };
                }
                case "file": {
                  if (part.mediaType.startsWith("image/")) {
                    const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                    return {
                      type: "image_url",
                      image_url: {
                        url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                        // OpenAI specific extension: image detail
                        detail: (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.imageDetail
                      }
                    };
                  } else if (part.mediaType.startsWith("audio/")) {
                    if (part.data instanceof URL) {
                      throw new UnsupportedFunctionalityError$1({
                        functionality: "audio file parts with URLs"
                      });
                    }
                    switch (part.mediaType) {
                      case "audio/wav": {
                        return {
                          type: "input_audio",
                          input_audio: {
                            data: convertToBase64(part.data),
                            format: "wav"
                          }
                        };
                      }
                      case "audio/mp3":
                      case "audio/mpeg": {
                        return {
                          type: "input_audio",
                          input_audio: {
                            data: convertToBase64(part.data),
                            format: "mp3"
                          }
                        };
                      }
                      default: {
                        throw new UnsupportedFunctionalityError$1({
                          functionality: `audio content parts with media type ${part.mediaType}`
                        });
                      }
                    }
                  } else if (part.mediaType === "application/pdf") {
                    if (part.data instanceof URL) {
                      throw new UnsupportedFunctionalityError$1({
                        functionality: "PDF file parts with URLs"
                      });
                    }
                    return {
                      type: "file",
                      file: typeof part.data === "string" && part.data.startsWith("file-") ? { file_id: part.data } : {
                        filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                        file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                      }
                    };
                  } else {
                    throw new UnsupportedFunctionalityError$1({
                      functionality: `file part media type ${part.mediaType}`
                    });
                  }
                }
              }
            })
          });
          break;
        }
        case "assistant": {
          let text = "";
          const toolCalls = [];
          for (const part of content) {
            switch (part.type) {
              case "text": {
                text += part.text;
                break;
              }
              case "tool-call": {
                toolCalls.push({
                  id: part.toolCallId,
                  type: "function",
                  function: {
                    name: part.toolName,
                    arguments: JSON.stringify(part.input)
                  }
                });
                break;
              }
            }
          }
          messages.push({
            role: "assistant",
            content: text,
            tool_calls: toolCalls.length > 0 ? toolCalls : void 0
          });
          break;
        }
        case "tool": {
          for (const toolResponse of content) {
            const output = toolResponse.output;
            let contentValue;
            switch (output.type) {
              case "text":
              case "error-text":
                contentValue = output.value;
                break;
              case "content":
              case "json":
              case "error-json":
                contentValue = JSON.stringify(output.value);
                break;
            }
            messages.push({
              role: "tool",
              tool_call_id: toolResponse.toolCallId,
              content: contentValue
            });
          }
          break;
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return { messages, warnings };
  }

  // src/chat/get-response-metadata.ts
  function getResponseMetadata$2({
    id,
    model,
    created
  }) {
    return {
      id: id != null ? id : void 0,
      modelId: model != null ? model : void 0,
      timestamp: created != null ? new Date(created * 1e3) : void 0
    };
  }

  // src/chat/map-openai-finish-reason.ts
  function mapOpenAIFinishReason(finishReason) {
    switch (finishReason) {
      case "stop":
        return "stop";
      case "length":
        return "length";
      case "content_filter":
        return "content-filter";
      case "function_call":
      case "tool_calls":
        return "tool-calls";
      default:
        return "unknown";
    }
  }
  var openaiProviderOptions = object$1({
    /**
     * Modify the likelihood of specified tokens appearing in the completion.
     *
     * Accepts a JSON object that maps tokens (specified by their token ID in
     * the GPT tokenizer) to an associated bias value from -100 to 100.
     */
    logitBias: record(number(), number$1()).optional(),
    /**
     * Return the log probabilities of the tokens.
     *
     * Setting to true will return the log probabilities of the tokens that
     * were generated.
     *
     * Setting to a number will return the log probabilities of the top n
     * tokens that were generated.
     */
    logprobs: union([boolean$1(), number$1()]).optional(),
    /**
     * Whether to enable parallel function calling during tool use. Default to true.
     */
    parallelToolCalls: boolean$1().optional(),
    /**
     * A unique identifier representing your end-user, which can help OpenAI to
     * monitor and detect abuse.
     */
    user: string$1().optional(),
    /**
     * Reasoning effort for reasoning models. Defaults to `medium`.
     */
    reasoningEffort: _enum(["minimal", "low", "medium", "high"]).optional(),
    /**
     * Maximum number of completion tokens to generate. Useful for reasoning models.
     */
    maxCompletionTokens: number$1().optional(),
    /**
     * Whether to enable persistence in responses API.
     */
    store: boolean$1().optional(),
    /**
     * Metadata to associate with the request.
     */
    metadata: record(string$1().max(64), string$1().max(512)).optional(),
    /**
     * Parameters for prediction mode.
     */
    prediction: record(string$1(), any()).optional(),
    /**
     * Whether to use structured outputs.
     *
     * @default true
     */
    structuredOutputs: boolean$1().optional(),
    /**
     * Service tier for the request.
     * - 'auto': Default service tier
     * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
     * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
     *
     * @default 'auto'
     */
    serviceTier: _enum(["auto", "flex", "priority"]).optional(),
    /**
     * Whether to use strict JSON schema validation.
     *
     * @default false
     */
    strictJsonSchema: boolean$1().optional(),
    /**
     * Controls the verbosity of the model's responses.
     * Lower values will result in more concise responses, while higher values will result in more verbose responses.
     */
    textVerbosity: _enum(["low", "medium", "high"]).optional(),
    /**
     * A cache key for prompt caching. Allows manual control over prompt caching behavior.
     * Useful for improving cache hit rates and working around automatic caching issues.
     */
    promptCacheKey: string$1().optional(),
    /**
     * A stable identifier used to help detect users of your application
     * that may be violating OpenAI's usage policies. The IDs should be a
     * string that uniquely identifies each user. We recommend hashing their
     * username or email address, in order to avoid sending us any identifying
     * information.
     */
    safetyIdentifier: string$1().optional()
  });
  var comparisonFilterSchema = object$1({
    key: string$1(),
    type: _enum(["eq", "ne", "gt", "gte", "lt", "lte"]),
    value: union([string$1(), number$1(), boolean$1()])
  });
  var compoundFilterSchema = object$1({
    type: _enum(["and", "or"]),
    filters: array(
      union([comparisonFilterSchema, lazy(() => compoundFilterSchema)])
    )
  });
  var filtersSchema = union([comparisonFilterSchema, compoundFilterSchema]);
  var fileSearchArgsSchema = object$1({
    /**
     * List of vector store IDs to search through. If not provided, searches all available vector stores.
     */
    vectorStoreIds: array(string$1()).optional(),
    /**
     * Maximum number of search results to return. Defaults to 10.
     */
    maxNumResults: number$1().optional(),
    /**
     * Ranking options for the search.
     */
    ranking: object$1({
      ranker: _enum(["auto", "default-2024-08-21"]).optional()
    }).optional(),
    /**
     * A filter to apply based on file attributes.
     */
    filters: filtersSchema.optional()
  });
  var fileSearch = createProviderDefinedToolFactory({
    id: "openai.file_search",
    name: "file_search",
    inputSchema: object$1({
      query: string$1()
    })
  });
  var webSearchPreviewArgsSchema = object$1({
    /**
     * Search context size to use for the web search.
     * - high: Most comprehensive context, highest cost, slower response
     * - medium: Balanced context, cost, and latency (default)
     * - low: Least context, lowest cost, fastest response
     */
    searchContextSize: _enum(["low", "medium", "high"]).optional(),
    /**
     * User location information to provide geographically relevant search results.
     */
    userLocation: object$1({
      /**
       * Type of location (always 'approximate')
       */
      type: literal("approximate"),
      /**
       * Two-letter ISO country code (e.g., 'US', 'GB')
       */
      country: string$1().optional(),
      /**
       * City name (free text, e.g., 'Minneapolis')
       */
      city: string$1().optional(),
      /**
       * Region name (free text, e.g., 'Minnesota')
       */
      region: string$1().optional(),
      /**
       * IANA timezone (e.g., 'America/Chicago')
       */
      timezone: string$1().optional()
    }).optional()
  });
  var webSearchPreview = createProviderDefinedToolFactory({
    id: "openai.web_search_preview",
    name: "web_search_preview",
    inputSchema: object$1({
      action: discriminatedUnion("type", [
        object$1({
          type: literal("search"),
          query: string$1().nullish()
        }),
        object$1({
          type: literal("open_page"),
          url: string$1()
        }),
        object$1({
          type: literal("find"),
          url: string$1(),
          pattern: string$1()
        })
      ]).nullish()
    })
  });

  // src/chat/openai-chat-prepare-tools.ts
  function prepareChatTools({
    tools,
    toolChoice,
    structuredOutputs,
    strictJsonSchema
  }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
      return { tools: void 0, toolChoice: void 0, toolWarnings };
    }
    const openaiTools2 = [];
    for (const tool of tools) {
      switch (tool.type) {
        case "function":
          openaiTools2.push({
            type: "function",
            function: {
              name: tool.name,
              description: tool.description,
              parameters: tool.inputSchema,
              strict: structuredOutputs ? strictJsonSchema : void 0
            }
          });
          break;
        case "provider-defined":
          switch (tool.id) {
            case "openai.file_search": {
              const args = fileSearchArgsSchema.parse(tool.args);
              openaiTools2.push({
                type: "file_search",
                vector_store_ids: args.vectorStoreIds,
                max_num_results: args.maxNumResults,
                ranking_options: args.ranking ? { ranker: args.ranking.ranker } : void 0,
                filters: args.filters
              });
              break;
            }
            case "openai.web_search_preview": {
              const args = webSearchPreviewArgsSchema.parse(tool.args);
              openaiTools2.push({
                type: "web_search_preview",
                search_context_size: args.searchContextSize,
                user_location: args.userLocation
              });
              break;
            }
            default:
              toolWarnings.push({ type: "unsupported-tool", tool });
              break;
          }
          break;
        default:
          toolWarnings.push({ type: "unsupported-tool", tool });
          break;
      }
    }
    if (toolChoice == null) {
      return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
      case "none":
      case "required":
        return { tools: openaiTools2, toolChoice: type, toolWarnings };
      case "tool":
        return {
          tools: openaiTools2,
          toolChoice: {
            type: "function",
            function: {
              name: toolChoice.toolName
            }
          },
          toolWarnings
        };
      default: {
        const _exhaustiveCheck = type;
        throw new UnsupportedFunctionalityError$1({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }

  // src/chat/openai-chat-language-model.ts
  var OpenAIChatLanguageModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.supportedUrls = {
        "image/*": [/^https?:\/\/.*$/]
      };
      this.modelId = modelId;
      this.config = config;
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a, _b, _c, _d;
      const warnings = [];
      const openaiOptions = (_a = await parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiProviderOptions
      })) != null ? _a : {};
      const structuredOutputs = (_b = openaiOptions.structuredOutputs) != null ? _b : true;
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format schema is only supported with structuredOutputs"
        });
      }
      const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(
        {
          prompt,
          systemMessageMode: getSystemMessageMode(this.modelId)
        }
      );
      warnings.push(...messageWarnings);
      const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;
      const baseArgs = {
        // model id:
        model: this.modelId,
        // model specific settings:
        logit_bias: openaiOptions.logitBias,
        logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
        top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
        user: openaiOptions.user,
        parallel_tool_calls: openaiOptions.parallelToolCalls,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            schema: responseFormat.schema,
            strict: strictJsonSchema,
            name: (_d = responseFormat.name) != null ? _d : "response",
            description: responseFormat.description
          }
        } : { type: "json_object" } : void 0,
        stop: stopSequences,
        seed,
        verbosity: openaiOptions.textVerbosity,
        // openai specific settings:
        // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
        max_completion_tokens: openaiOptions.maxCompletionTokens,
        store: openaiOptions.store,
        metadata: openaiOptions.metadata,
        prediction: openaiOptions.prediction,
        reasoning_effort: openaiOptions.reasoningEffort,
        service_tier: openaiOptions.serviceTier,
        prompt_cache_key: openaiOptions.promptCacheKey,
        safety_identifier: openaiOptions.safetyIdentifier,
        // messages:
        messages
      };
      if (isReasoningModel(this.modelId)) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for reasoning models"
          });
        }
        if (baseArgs.top_p != null) {
          baseArgs.top_p = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topP",
            details: "topP is not supported for reasoning models"
          });
        }
        if (baseArgs.frequency_penalty != null) {
          baseArgs.frequency_penalty = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "frequencyPenalty",
            details: "frequencyPenalty is not supported for reasoning models"
          });
        }
        if (baseArgs.presence_penalty != null) {
          baseArgs.presence_penalty = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "presencePenalty",
            details: "presencePenalty is not supported for reasoning models"
          });
        }
        if (baseArgs.logit_bias != null) {
          baseArgs.logit_bias = void 0;
          warnings.push({
            type: "other",
            message: "logitBias is not supported for reasoning models"
          });
        }
        if (baseArgs.logprobs != null) {
          baseArgs.logprobs = void 0;
          warnings.push({
            type: "other",
            message: "logprobs is not supported for reasoning models"
          });
        }
        if (baseArgs.top_logprobs != null) {
          baseArgs.top_logprobs = void 0;
          warnings.push({
            type: "other",
            message: "topLogprobs is not supported for reasoning models"
          });
        }
        if (baseArgs.max_tokens != null) {
          if (baseArgs.max_completion_tokens == null) {
            baseArgs.max_completion_tokens = baseArgs.max_tokens;
          }
          baseArgs.max_tokens = void 0;
        }
      } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for the search preview models and has been removed."
          });
        }
      }
      if (openaiOptions.serviceTier === "flex" && !supportsFlexProcessing(this.modelId)) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
        });
        baseArgs.service_tier = void 0;
      }
      if (openaiOptions.serviceTier === "priority" && !supportsPriorityProcessing(this.modelId)) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
        });
        baseArgs.service_tier = void 0;
      }
      const {
        tools: openaiTools2,
        toolChoice: openaiToolChoice,
        toolWarnings
      } = prepareChatTools({
        tools,
        toolChoice,
        structuredOutputs,
        strictJsonSchema
      });
      return {
        args: {
          ...baseArgs,
          tools: openaiTools2,
          tool_choice: openaiToolChoice
        },
        warnings: [...warnings, ...toolWarnings]
      };
    }
    async doGenerate(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      const { args: body, warnings } = await this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          openaiChatResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      const text = choice.message.content;
      if (text != null && text.length > 0) {
        content.push({ type: "text", text });
      }
      for (const toolCall of (_a = choice.message.tool_calls) != null ? _a : []) {
        content.push({
          type: "tool-call",
          toolCallId: (_b = toolCall.id) != null ? _b : generateId$1(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
      for (const annotation of (_c = choice.message.annotations) != null ? _c : []) {
        content.push({
          type: "source",
          sourceType: "url",
          id: generateId$1(),
          url: annotation.url,
          title: annotation.title
        });
      }
      const completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details;
      const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
      const providerMetadata = { openai: {} };
      if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
        providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
      }
      if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
        providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
      }
      if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {
        providerMetadata.openai.logprobs = choice.logprobs.content;
      }
      return {
        content,
        finishReason: mapOpenAIFinishReason(choice.finish_reason),
        usage: {
          inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,
          outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,
          totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,
          reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,
          cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0
        },
        request: { body },
        response: {
          ...getResponseMetadata$2(response),
          headers: responseHeaders,
          body: rawResponse
        },
        warnings,
        providerMetadata
      };
    }
    async doStream(options) {
      const { args, warnings } = await this.getArgs(options);
      const body = {
        ...args,
        stream: true,
        stream_options: {
          include_usage: true
        }
      };
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiChatChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const toolCalls = [];
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      let isActiveText = false;
      const providerMetadata = { openai: {} };
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue({
                  type: "response-metadata",
                  ...getResponseMetadata$2(value)
                });
              }
              if (value.usage != null) {
                usage.inputTokens = (_a = value.usage.prompt_tokens) != null ? _a : void 0;
                usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                usage.reasoningTokens = (_e = (_d = value.usage.completion_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : void 0;
                usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;
                if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {
                  providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;
                }
                if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {
                  providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;
                }
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapOpenAIFinishReason(choice.finish_reason);
              }
              if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {
                providerMetadata.openai.logprobs = choice.logprobs.content;
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              if (delta.content != null) {
                if (!isActiveText) {
                  controller.enqueue({ type: "text-start", id: "0" });
                  isActiveText = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: delta.content
                });
              }
              if (delta.tool_calls != null) {
                for (const toolCallDelta of delta.tool_calls) {
                  const index = toolCallDelta.index;
                  if (toolCalls[index] == null) {
                    if (toolCallDelta.type !== "function") {
                      throw new InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function' type.`
                      });
                    }
                    if (toolCallDelta.id == null) {
                      throw new InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'id' to be a string.`
                      });
                    }
                    if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {
                      throw new InvalidResponseDataError({
                        data: toolCallDelta,
                        message: `Expected 'function.name' to be a string.`
                      });
                    }
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCallDelta.id,
                      toolName: toolCallDelta.function.name
                    });
                    toolCalls[index] = {
                      id: toolCallDelta.id,
                      type: "function",
                      function: {
                        name: toolCallDelta.function.name,
                        arguments: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                      },
                      hasFinished: false
                    };
                    const toolCall2 = toolCalls[index];
                    if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {
                      if (toolCall2.function.arguments.length > 0) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall2.id,
                          delta: toolCall2.function.arguments
                        });
                      }
                      if (isParsableJson(toolCall2.function.arguments)) {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: toolCall2.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: (_q = toolCall2.id) != null ? _q : generateId$1(),
                          toolName: toolCall2.function.name,
                          input: toolCall2.function.arguments
                        });
                        toolCall2.hasFinished = true;
                      }
                    }
                    continue;
                  }
                  const toolCall = toolCalls[index];
                  if (toolCall.hasFinished) {
                    continue;
                  }
                  if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {
                    toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : "";
                  }
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.id,
                    delta: (_u = toolCallDelta.function.arguments) != null ? _u : ""
                  });
                  if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: (_x = toolCall.id) != null ? _x : generateId$1(),
                      toolName: toolCall.function.name,
                      input: toolCall.function.arguments
                    });
                    toolCall.hasFinished = true;
                  }
                }
              }
              if (delta.annotations != null) {
                for (const annotation of delta.annotations) {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: generateId$1(),
                    url: annotation.url,
                    title: annotation.title
                  });
                }
              }
            },
            flush(controller) {
              if (isActiveText) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                ...providerMetadata != null ? { providerMetadata } : {}
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    }
  };
  var openaiTokenUsageSchema = object$1({
    prompt_tokens: number$1().nullish(),
    completion_tokens: number$1().nullish(),
    total_tokens: number$1().nullish(),
    prompt_tokens_details: object$1({
      cached_tokens: number$1().nullish()
    }).nullish(),
    completion_tokens_details: object$1({
      reasoning_tokens: number$1().nullish(),
      accepted_prediction_tokens: number$1().nullish(),
      rejected_prediction_tokens: number$1().nullish()
    }).nullish()
  }).nullish();
  var openaiChatResponseSchema = object$1({
    id: string$1().nullish(),
    created: number$1().nullish(),
    model: string$1().nullish(),
    choices: array(
      object$1({
        message: object$1({
          role: literal("assistant").nullish(),
          content: string$1().nullish(),
          tool_calls: array(
            object$1({
              id: string$1().nullish(),
              type: literal("function"),
              function: object$1({
                name: string$1(),
                arguments: string$1()
              })
            })
          ).nullish(),
          annotations: array(
            object$1({
              type: literal("url_citation"),
              start_index: number$1(),
              end_index: number$1(),
              url: string$1(),
              title: string$1()
            })
          ).nullish()
        }),
        index: number$1(),
        logprobs: object$1({
          content: array(
            object$1({
              token: string$1(),
              logprob: number$1(),
              top_logprobs: array(
                object$1({
                  token: string$1(),
                  logprob: number$1()
                })
              )
            })
          ).nullish()
        }).nullish(),
        finish_reason: string$1().nullish()
      })
    ),
    usage: openaiTokenUsageSchema
  });
  var openaiChatChunkSchema = union([
    object$1({
      id: string$1().nullish(),
      created: number$1().nullish(),
      model: string$1().nullish(),
      choices: array(
        object$1({
          delta: object$1({
            role: _enum(["assistant"]).nullish(),
            content: string$1().nullish(),
            tool_calls: array(
              object$1({
                index: number$1(),
                id: string$1().nullish(),
                type: literal("function").nullish(),
                function: object$1({
                  name: string$1().nullish(),
                  arguments: string$1().nullish()
                })
              })
            ).nullish(),
            annotations: array(
              object$1({
                type: literal("url_citation"),
                start_index: number$1(),
                end_index: number$1(),
                url: string$1(),
                title: string$1()
              })
            ).nullish()
          }).nullish(),
          logprobs: object$1({
            content: array(
              object$1({
                token: string$1(),
                logprob: number$1(),
                top_logprobs: array(
                  object$1({
                    token: string$1(),
                    logprob: number$1()
                  })
                )
              })
            ).nullish()
          }).nullish(),
          finish_reason: string$1().nullish(),
          index: number$1()
        })
      ),
      usage: openaiTokenUsageSchema
    }),
    openaiErrorDataSchema
  ]);
  function isReasoningModel(modelId) {
    return (modelId.startsWith("o") || modelId.startsWith("gpt-5")) && !modelId.startsWith("gpt-5-chat");
  }
  function supportsFlexProcessing(modelId) {
    return modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
  }
  function supportsPriorityProcessing(modelId) {
    return modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
  }
  function getSystemMessageMode(modelId) {
    var _a, _b;
    if (!isReasoningModel(modelId)) {
      return "system";
    }
    return (_b = (_a = reasoningModels[modelId]) == null ? void 0 : _a.systemMessageMode) != null ? _b : "developer";
  }
  var reasoningModels = {
    "o1-mini": {
      systemMessageMode: "remove"
    },
    "o1-mini-2024-09-12": {
      systemMessageMode: "remove"
    },
    "o1-preview": {
      systemMessageMode: "remove"
    },
    "o1-preview-2024-09-12": {
      systemMessageMode: "remove"
    },
    o3: {
      systemMessageMode: "developer"
    },
    "o3-2025-04-16": {
      systemMessageMode: "developer"
    },
    "o3-mini": {
      systemMessageMode: "developer"
    },
    "o3-mini-2025-01-31": {
      systemMessageMode: "developer"
    },
    "o4-mini": {
      systemMessageMode: "developer"
    },
    "o4-mini-2025-04-16": {
      systemMessageMode: "developer"
    }
  };
  function convertToOpenAICompletionPrompt({
    prompt,
    user = "user",
    assistant = "assistant"
  }) {
    let text = "";
    if (prompt[0].role === "system") {
      text += `${prompt[0].content}

`;
      prompt = prompt.slice(1);
    }
    for (const { role, content } of prompt) {
      switch (role) {
        case "system": {
          throw new InvalidPromptError({
            message: "Unexpected system message in prompt: ${content}",
            prompt
          });
        }
        case "user": {
          const userMessage = content.map((part) => {
            switch (part.type) {
              case "text": {
                return part.text;
              }
            }
          }).filter(Boolean).join("");
          text += `${user}:
${userMessage}

`;
          break;
        }
        case "assistant": {
          const assistantMessage = content.map((part) => {
            switch (part.type) {
              case "text": {
                return part.text;
              }
              case "tool-call": {
                throw new UnsupportedFunctionalityError$1({
                  functionality: "tool-call messages"
                });
              }
            }
          }).join("");
          text += `${assistant}:
${assistantMessage}

`;
          break;
        }
        case "tool": {
          throw new UnsupportedFunctionalityError$1({
            functionality: "tool messages"
          });
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    text += `${assistant}:
`;
    return {
      prompt: text,
      stopSequences: [`
${user}:`]
    };
  }

  // src/completion/get-response-metadata.ts
  function getResponseMetadata2({
    id,
    model,
    created
  }) {
    return {
      id: id != null ? id : void 0,
      modelId: model != null ? model : void 0,
      timestamp: created != null ? new Date(created * 1e3) : void 0
    };
  }

  // src/completion/map-openai-finish-reason.ts
  function mapOpenAIFinishReason2(finishReason) {
    switch (finishReason) {
      case "stop":
        return "stop";
      case "length":
        return "length";
      case "content_filter":
        return "content-filter";
      case "function_call":
      case "tool_calls":
        return "tool-calls";
      default:
        return "unknown";
    }
  }
  var openaiCompletionProviderOptions = object$1({
    /**
    Echo back the prompt in addition to the completion.
       */
    echo: boolean$1().optional(),
    /**
    Modify the likelihood of specified tokens appearing in the completion.
    
    Accepts a JSON object that maps tokens (specified by their token ID in
    the GPT tokenizer) to an associated bias value from -100 to 100. You
    can use this tokenizer tool to convert text to token IDs. Mathematically,
    the bias is added to the logits generated by the model prior to sampling.
    The exact effect will vary per model, but values between -1 and 1 should
    decrease or increase likelihood of selection; values like -100 or 100
    should result in a ban or exclusive selection of the relevant token.
    
    As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
    token from being generated.
     */
    logitBias: record(string$1(), number$1()).optional(),
    /**
    The suffix that comes after a completion of inserted text.
     */
    suffix: string$1().optional(),
    /**
    A unique identifier representing your end-user, which can help OpenAI to
    monitor and detect abuse. Learn more.
     */
    user: string$1().optional(),
    /**
    Return the log probabilities of the tokens. Including logprobs will increase
    the response size and can slow down response times. However, it can
    be useful to better understand how the model is behaving.
    Setting to true will return the log probabilities of the tokens that
    were generated.
    Setting to a number will return the log probabilities of the top n
    tokens that were generated.
       */
    logprobs: union([boolean$1(), number$1()]).optional()
  });

  // src/completion/openai-completion-language-model.ts
  var OpenAICompletionLanguageModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.supportedUrls = {
        // No URLs are supported for completion models.
      };
      this.modelId = modelId;
      this.config = config;
    }
    get providerOptionsName() {
      return this.config.provider.split(".")[0].trim();
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences: userStopSequences,
      responseFormat,
      tools,
      toolChoice,
      seed,
      providerOptions
    }) {
      const warnings = [];
      const openaiOptions = {
        ...await parseProviderOptions({
          provider: "openai",
          providerOptions,
          schema: openaiCompletionProviderOptions
        }),
        ...await parseProviderOptions({
          provider: this.providerOptionsName,
          providerOptions,
          schema: openaiCompletionProviderOptions
        })
      };
      if (topK != null) {
        warnings.push({ type: "unsupported-setting", setting: "topK" });
      }
      if (tools == null ? void 0 : tools.length) {
        warnings.push({ type: "unsupported-setting", setting: "tools" });
      }
      if (toolChoice != null) {
        warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
      }
      if (responseFormat != null && responseFormat.type !== "text") {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format is not supported."
        });
      }
      const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt });
      const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
      return {
        args: {
          // model id:
          model: this.modelId,
          // model specific settings:
          echo: openaiOptions.echo,
          logit_bias: openaiOptions.logitBias,
          logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
          suffix: openaiOptions.suffix,
          user: openaiOptions.user,
          // standardized settings:
          max_tokens: maxOutputTokens,
          temperature,
          top_p: topP,
          frequency_penalty: frequencyPenalty,
          presence_penalty: presencePenalty,
          seed,
          // prompt:
          prompt: completionPrompt,
          // stop sequences:
          stop: stop.length > 0 ? stop : void 0
        },
        warnings
      };
    }
    async doGenerate(options) {
      var _a, _b, _c;
      const { args, warnings } = await this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body: args,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          openaiCompletionResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const providerMetadata = { openai: {} };
      if (choice.logprobs != null) {
        providerMetadata.openai.logprobs = choice.logprobs;
      }
      return {
        content: [{ type: "text", text: choice.text }],
        usage: {
          inputTokens: (_a = response.usage) == null ? void 0 : _a.prompt_tokens,
          outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
          totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens
        },
        finishReason: mapOpenAIFinishReason2(choice.finish_reason),
        request: { body: args },
        response: {
          ...getResponseMetadata2(response),
          headers: responseHeaders,
          body: rawResponse
        },
        providerMetadata,
        warnings
      };
    }
    async doStream(options) {
      const { args, warnings } = await this.getArgs(options);
      const body = {
        ...args,
        stream: true,
        stream_options: {
          include_usage: true
        }
      };
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiCompletionChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const providerMetadata = { openai: {} };
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if ("error" in value) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              if (isFirstChunk) {
                isFirstChunk = false;
                controller.enqueue({
                  type: "response-metadata",
                  ...getResponseMetadata2(value)
                });
                controller.enqueue({ type: "text-start", id: "0" });
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                usage.totalTokens = value.usage.total_tokens;
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapOpenAIFinishReason2(choice.finish_reason);
              }
              if ((choice == null ? void 0 : choice.logprobs) != null) {
                providerMetadata.openai.logprobs = choice.logprobs;
              }
              if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: choice.text
                });
              }
            },
            flush(controller) {
              if (!isFirstChunk) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                providerMetadata,
                usage
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    }
  };
  var usageSchema$1 = object$1({
    prompt_tokens: number$1(),
    completion_tokens: number$1(),
    total_tokens: number$1()
  });
  var openaiCompletionResponseSchema = object$1({
    id: string$1().nullish(),
    created: number$1().nullish(),
    model: string$1().nullish(),
    choices: array(
      object$1({
        text: string$1(),
        finish_reason: string$1(),
        logprobs: object$1({
          tokens: array(string$1()),
          token_logprobs: array(number$1()),
          top_logprobs: array(record(string$1(), number$1())).nullish()
        }).nullish()
      })
    ),
    usage: usageSchema$1.nullish()
  });
  var openaiCompletionChunkSchema = union([
    object$1({
      id: string$1().nullish(),
      created: number$1().nullish(),
      model: string$1().nullish(),
      choices: array(
        object$1({
          text: string$1(),
          finish_reason: string$1().nullish(),
          index: number$1(),
          logprobs: object$1({
            tokens: array(string$1()),
            token_logprobs: array(number$1()),
            top_logprobs: array(record(string$1(), number$1())).nullish()
          }).nullish()
        })
      ),
      usage: usageSchema$1.nullish()
    }),
    openaiErrorDataSchema
  ]);
  var openaiEmbeddingProviderOptions = object$1({
    /**
    The number of dimensions the resulting output embeddings should have.
    Only supported in text-embedding-3 and later models.
       */
    dimensions: number$1().optional(),
    /**
    A unique identifier representing your end-user, which can help OpenAI to
    monitor and detect abuse. Learn more.
    */
    user: string$1().optional()
  });

  // src/embedding/openai-embedding-model.ts
  var OpenAIEmbeddingModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.maxEmbeddingsPerCall = 2048;
      this.supportsParallelCalls = true;
      this.modelId = modelId;
      this.config = config;
    }
    get provider() {
      return this.config.provider;
    }
    async doEmbed({
      values,
      headers,
      abortSignal,
      providerOptions
    }) {
      var _a;
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new TooManyEmbeddingValuesForCallError$1({
          provider: this.provider,
          modelId: this.modelId,
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          values
        });
      }
      const openaiOptions = (_a = await parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiEmbeddingProviderOptions
      })) != null ? _a : {};
      const {
        responseHeaders,
        value: response,
        rawValue
      } = await postJsonToApi$1({
        url: this.config.url({
          path: "/embeddings",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), headers),
        body: {
          model: this.modelId,
          input: values,
          encoding_format: "float",
          dimensions: openaiOptions.dimensions,
          user: openaiOptions.user
        },
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          openaiTextEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: response.data.map((item) => item.embedding),
        usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
        response: { headers: responseHeaders, body: rawValue }
      };
    }
  };
  var openaiTextEmbeddingResponseSchema = object$1({
    data: array(object$1({ embedding: array(number$1()) })),
    usage: object$1({ prompt_tokens: number$1() }).nullish()
  });

  // src/image/openai-image-options.ts
  var modelMaxImagesPerCall = {
    "dall-e-3": 1,
    "dall-e-2": 10,
    "gpt-image-1": 10
  };
  var hasDefaultResponseFormat = /* @__PURE__ */ new Set(["gpt-image-1"]);

  // src/image/openai-image-model.ts
  var OpenAIImageModel = class {
    constructor(modelId, config) {
      this.modelId = modelId;
      this.config = config;
      this.specificationVersion = "v2";
    }
    get maxImagesPerCall() {
      var _a;
      return (_a = modelMaxImagesPerCall[this.modelId]) != null ? _a : 1;
    }
    get provider() {
      return this.config.provider;
    }
    async doGenerate({
      prompt,
      n,
      size,
      aspectRatio,
      seed,
      providerOptions,
      headers,
      abortSignal
    }) {
      var _a, _b, _c, _d;
      const warnings = [];
      if (aspectRatio != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "aspectRatio",
          details: "This model does not support aspect ratio. Use `size` instead."
        });
      }
      if (seed != null) {
        warnings.push({ type: "unsupported-setting", setting: "seed" });
      }
      const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
      const { value: response, responseHeaders } = await postJsonToApi$1({
        url: this.config.url({
          path: "/images/generations",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), headers),
        body: {
          model: this.modelId,
          prompt,
          n,
          size,
          ...(_d = providerOptions.openai) != null ? _d : {},
          ...!hasDefaultResponseFormat.has(this.modelId) ? { response_format: "b64_json" } : {}
        },
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          openaiImageResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response.data.map((item) => item.b64_json),
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        },
        providerMetadata: {
          openai: {
            images: response.data.map(
              (item) => item.revised_prompt ? {
                revisedPrompt: item.revised_prompt
              } : null
            )
          }
        }
      };
    }
  };
  var openaiImageResponseSchema = object$1({
    data: array(
      object$1({ b64_json: string$1(), revised_prompt: string$1().optional() })
    )
  });
  var codeInterpreterArgsSchema = object$1({
    container: union([
      string$1(),
      object$1({
        fileIds: array(string$1()).optional()
      })
    ]).optional()
  });
  var codeInterpreter = createProviderDefinedToolFactory({
    id: "openai.code_interpreter",
    name: "code_interpreter",
    inputSchema: object$1({})
  });

  // src/openai-tools.ts
  var openaiTools = {
    codeInterpreter,
    fileSearch,
    webSearchPreview
  };
  function isFileId(data, prefixes) {
    if (!prefixes) return false;
    return prefixes.some((prefix) => data.startsWith(prefix));
  }
  async function convertToOpenAIResponsesMessages({
    prompt,
    systemMessageMode,
    fileIdPrefixes
  }) {
    var _a, _b, _c, _d, _e, _f;
    const messages = [];
    const warnings = [];
    for (const { role, content } of prompt) {
      switch (role) {
        case "system": {
          switch (systemMessageMode) {
            case "system": {
              messages.push({ role: "system", content });
              break;
            }
            case "developer": {
              messages.push({ role: "developer", content });
              break;
            }
            case "remove": {
              warnings.push({
                type: "other",
                message: "system messages are removed for this model"
              });
              break;
            }
            default: {
              const _exhaustiveCheck = systemMessageMode;
              throw new Error(
                `Unsupported system message mode: ${_exhaustiveCheck}`
              );
            }
          }
          break;
        }
        case "user": {
          messages.push({
            role: "user",
            content: content.map((part, index) => {
              var _a2, _b2, _c2;
              switch (part.type) {
                case "text": {
                  return { type: "input_text", text: part.text };
                }
                case "file": {
                  if (part.mediaType.startsWith("image/")) {
                    const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                    return {
                      type: "input_image",
                      ...part.data instanceof URL ? { image_url: part.data.toString() } : typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                        image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                      },
                      detail: (_b2 = (_a2 = part.providerOptions) == null ? void 0 : _a2.openai) == null ? void 0 : _b2.imageDetail
                    };
                  } else if (part.mediaType === "application/pdf") {
                    if (part.data instanceof URL) {
                      return {
                        type: "input_file",
                        file_url: part.data.toString()
                      };
                    }
                    return {
                      type: "input_file",
                      ...typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                        filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                        file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                      }
                    };
                  } else {
                    throw new UnsupportedFunctionalityError$1({
                      functionality: `file part media type ${part.mediaType}`
                    });
                  }
                }
              }
            })
          });
          break;
        }
        case "assistant": {
          const reasoningMessages = {};
          for (const part of content) {
            switch (part.type) {
              case "text": {
                messages.push({
                  role: "assistant",
                  content: [{ type: "output_text", text: part.text }],
                  id: (_c = (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.itemId) != null ? _c : void 0
                });
                break;
              }
              case "tool-call": {
                if (part.providerExecuted) {
                  break;
                }
                messages.push({
                  type: "function_call",
                  call_id: part.toolCallId,
                  name: part.toolName,
                  arguments: JSON.stringify(part.input),
                  id: (_f = (_e = (_d = part.providerOptions) == null ? void 0 : _d.openai) == null ? void 0 : _e.itemId) != null ? _f : void 0
                });
                break;
              }
              case "tool-result": {
                warnings.push({
                  type: "other",
                  message: `tool result parts in assistant messages are not supported for OpenAI responses`
                });
                break;
              }
              case "reasoning": {
                const providerOptions = await parseProviderOptions({
                  provider: "openai",
                  providerOptions: part.providerOptions,
                  schema: openaiResponsesReasoningProviderOptionsSchema
                });
                const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
                if (reasoningId != null) {
                  const existingReasoningMessage = reasoningMessages[reasoningId];
                  const summaryParts = [];
                  if (part.text.length > 0) {
                    summaryParts.push({ type: "summary_text", text: part.text });
                  } else if (existingReasoningMessage !== void 0) {
                    warnings.push({
                      type: "other",
                      message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                    });
                  }
                  if (existingReasoningMessage === void 0) {
                    reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                      summary: summaryParts
                    };
                    messages.push(reasoningMessages[reasoningId]);
                  } else {
                    existingReasoningMessage.summary.push(...summaryParts);
                  }
                } else {
                  warnings.push({
                    type: "other",
                    message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                  });
                }
                break;
              }
            }
          }
          break;
        }
        case "tool": {
          for (const part of content) {
            const output = part.output;
            let contentValue;
            switch (output.type) {
              case "text":
              case "error-text":
                contentValue = output.value;
                break;
              case "content":
              case "json":
              case "error-json":
                contentValue = JSON.stringify(output.value);
                break;
            }
            messages.push({
              type: "function_call_output",
              call_id: part.toolCallId,
              output: contentValue
            });
          }
          break;
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return { messages, warnings };
  }
  var openaiResponsesReasoningProviderOptionsSchema = object$1({
    itemId: string$1().nullish(),
    reasoningEncryptedContent: string$1().nullish()
  });

  // src/responses/map-openai-responses-finish-reason.ts
  function mapOpenAIResponseFinishReason({
    finishReason,
    hasToolCalls
  }) {
    switch (finishReason) {
      case void 0:
      case null:
        return hasToolCalls ? "tool-calls" : "stop";
      case "max_output_tokens":
        return "length";
      case "content_filter":
        return "content-filter";
      default:
        return hasToolCalls ? "tool-calls" : "unknown";
    }
  }
  function prepareResponsesTools({
    tools,
    toolChoice,
    strictJsonSchema
  }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
      return { tools: void 0, toolChoice: void 0, toolWarnings };
    }
    const openaiTools2 = [];
    for (const tool of tools) {
      switch (tool.type) {
        case "function":
          openaiTools2.push({
            type: "function",
            name: tool.name,
            description: tool.description,
            parameters: tool.inputSchema,
            strict: strictJsonSchema
          });
          break;
        case "provider-defined": {
          switch (tool.id) {
            case "openai.file_search": {
              const args = fileSearchArgsSchema.parse(tool.args);
              openaiTools2.push({
                type: "file_search",
                vector_store_ids: args.vectorStoreIds,
                max_num_results: args.maxNumResults,
                ranking_options: args.ranking ? { ranker: args.ranking.ranker } : void 0,
                filters: args.filters
              });
              break;
            }
            case "openai.web_search_preview": {
              const args = webSearchPreviewArgsSchema.parse(tool.args);
              openaiTools2.push({
                type: "web_search_preview",
                search_context_size: args.searchContextSize,
                user_location: args.userLocation
              });
              break;
            }
            case "openai.code_interpreter": {
              const args = codeInterpreterArgsSchema.parse(tool.args);
              openaiTools2.push({
                type: "code_interpreter",
                container: args.container == null ? { type: "auto", file_ids: void 0 } : typeof args.container === "string" ? args.container : { type: "auto", file_ids: args.container.fileIds }
              });
              break;
            }
            default: {
              toolWarnings.push({ type: "unsupported-tool", tool });
              break;
            }
          }
          break;
        }
        default:
          toolWarnings.push({ type: "unsupported-tool", tool });
          break;
      }
    }
    if (toolChoice == null) {
      return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
      case "none":
      case "required":
        return { tools: openaiTools2, toolChoice: type, toolWarnings };
      case "tool":
        return {
          tools: openaiTools2,
          toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "web_search_preview" ? { type: toolChoice.toolName } : { type: "function", name: toolChoice.toolName },
          toolWarnings
        };
      default: {
        const _exhaustiveCheck = type;
        throw new UnsupportedFunctionalityError$1({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }

  // src/responses/openai-responses-language-model.ts
  var webSearchCallItem = object$1({
    type: literal("web_search_call"),
    id: string$1(),
    status: string$1(),
    action: discriminatedUnion("type", [
      object$1({
        type: literal("search"),
        query: string$1().nullish()
      }),
      object$1({
        type: literal("open_page"),
        url: string$1()
      }),
      object$1({
        type: literal("find"),
        url: string$1(),
        pattern: string$1()
      })
    ]).nullish()
  });
  var TOP_LOGPROBS_MAX = 20;
  var LOGPROBS_SCHEMA = array(
    object$1({
      token: string$1(),
      logprob: number$1(),
      top_logprobs: array(
        object$1({
          token: string$1(),
          logprob: number$1()
        })
      )
    })
  );
  var OpenAIResponsesLanguageModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.supportedUrls = {
        "image/*": [/^https?:\/\/.*$/],
        "application/pdf": [/^https?:\/\/.*$/]
      };
      this.modelId = modelId;
      this.config = config;
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs({
      maxOutputTokens,
      temperature,
      stopSequences,
      topP,
      topK,
      presencePenalty,
      frequencyPenalty,
      seed,
      prompt,
      providerOptions,
      tools,
      toolChoice,
      responseFormat
    }) {
      var _a, _b;
      const warnings = [];
      const modelConfig = getResponsesModelConfig(this.modelId);
      if (topK != null) {
        warnings.push({ type: "unsupported-setting", setting: "topK" });
      }
      if (seed != null) {
        warnings.push({ type: "unsupported-setting", setting: "seed" });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (stopSequences != null) {
        warnings.push({ type: "unsupported-setting", setting: "stopSequences" });
      }
      const { messages, warnings: messageWarnings } = await convertToOpenAIResponsesMessages({
        prompt,
        systemMessageMode: modelConfig.systemMessageMode,
        fileIdPrefixes: this.config.fileIdPrefixes
      });
      warnings.push(...messageWarnings);
      const openaiOptions = await parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiResponsesProviderOptionsSchema
      });
      const strictJsonSchema = (_a = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _a : false;
      const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX : void 0;
      const openaiOptionsInclude = topLogprobs ? Array.isArray(openaiOptions == null ? void 0 : openaiOptions.include) ? [...openaiOptions == null ? void 0 : openaiOptions.include, "message.output_text.logprobs"] : ["message.output_text.logprobs"] : openaiOptions == null ? void 0 : openaiOptions.include;
      const baseArgs = {
        model: this.modelId,
        input: messages,
        temperature,
        top_p: topP,
        max_output_tokens: maxOutputTokens,
        ...((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
          text: {
            ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
              format: responseFormat.schema != null ? {
                type: "json_schema",
                strict: strictJsonSchema,
                name: (_b = responseFormat.name) != null ? _b : "response",
                description: responseFormat.description,
                schema: responseFormat.schema
              } : { type: "json_object" }
            },
            ...(openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
              verbosity: openaiOptions.textVerbosity
            }
          }
        },
        // provider options:
        metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
        parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
        previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
        store: openaiOptions == null ? void 0 : openaiOptions.store,
        user: openaiOptions == null ? void 0 : openaiOptions.user,
        instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
        service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
        include: openaiOptionsInclude,
        prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
        safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
        top_logprobs: topLogprobs,
        // model-specific settings:
        ...modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
          reasoning: {
            ...(openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
              effort: openaiOptions.reasoningEffort
            },
            ...(openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
              summary: openaiOptions.reasoningSummary
            }
          }
        },
        ...modelConfig.requiredAutoTruncation && {
          truncation: "auto"
        }
      };
      if (modelConfig.isReasoningModel) {
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported for reasoning models"
          });
        }
        if (baseArgs.top_p != null) {
          baseArgs.top_p = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topP",
            details: "topP is not supported for reasoning models"
          });
        }
      } else {
        if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "reasoningEffort",
            details: "reasoningEffort is not supported for non-reasoning models"
          });
        }
        if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "reasoningSummary",
            details: "reasoningSummary is not supported for non-reasoning models"
          });
        }
      }
      if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelConfig.supportsFlexProcessing) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
        });
        delete baseArgs.service_tier;
      }
      if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelConfig.supportsPriorityProcessing) {
        warnings.push({
          type: "unsupported-setting",
          setting: "serviceTier",
          details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
        });
        delete baseArgs.service_tier;
      }
      const {
        tools: openaiTools2,
        toolChoice: openaiToolChoice,
        toolWarnings
      } = prepareResponsesTools({
        tools,
        toolChoice,
        strictJsonSchema
      });
      return {
        args: {
          ...baseArgs,
          tools: openaiTools2,
          tool_choice: openaiToolChoice
        },
        warnings: [...warnings, ...toolWarnings]
      };
    }
    async doGenerate(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
      const { args: body, warnings } = await this.getArgs(options);
      const url = this.config.url({
        path: "/responses",
        modelId: this.modelId
      });
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url,
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          object$1({
            id: string$1(),
            created_at: number$1(),
            error: object$1({
              code: string$1(),
              message: string$1()
            }).nullish(),
            model: string$1(),
            output: array(
              discriminatedUnion("type", [
                object$1({
                  type: literal("message"),
                  role: literal("assistant"),
                  id: string$1(),
                  content: array(
                    object$1({
                      type: literal("output_text"),
                      text: string$1(),
                      logprobs: LOGPROBS_SCHEMA.nullish(),
                      annotations: array(
                        discriminatedUnion("type", [
                          object$1({
                            type: literal("url_citation"),
                            start_index: number$1(),
                            end_index: number$1(),
                            url: string$1(),
                            title: string$1()
                          }),
                          object$1({
                            type: literal("file_citation"),
                            file_id: string$1(),
                            filename: string$1().nullish(),
                            index: number$1().nullish(),
                            start_index: number$1().nullish(),
                            end_index: number$1().nullish(),
                            quote: string$1().nullish()
                          })
                        ])
                      )
                    })
                  )
                }),
                object$1({
                  type: literal("function_call"),
                  call_id: string$1(),
                  name: string$1(),
                  arguments: string$1(),
                  id: string$1()
                }),
                webSearchCallItem,
                object$1({
                  type: literal("computer_call"),
                  id: string$1(),
                  status: string$1().optional()
                }),
                object$1({
                  type: literal("file_search_call"),
                  id: string$1(),
                  status: string$1().optional(),
                  queries: array(string$1()).nullish(),
                  results: array(
                    object$1({
                      attributes: object$1({
                        file_id: string$1(),
                        filename: string$1(),
                        score: number$1(),
                        text: string$1()
                      })
                    })
                  ).nullish()
                }),
                object$1({
                  type: literal("reasoning"),
                  id: string$1(),
                  encrypted_content: string$1().nullish(),
                  summary: array(
                    object$1({
                      type: literal("summary_text"),
                      text: string$1()
                    })
                  )
                })
              ])
            ),
            service_tier: string$1().nullish(),
            incomplete_details: object$1({ reason: string$1() }).nullable(),
            usage: usageSchema2
          })
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      if (response.error) {
        throw new APICallError$1({
          message: response.error.message,
          url,
          requestBodyValues: body,
          statusCode: 400,
          responseHeaders,
          responseBody: rawResponse,
          isRetryable: false
        });
      }
      const content = [];
      const logprobs = [];
      for (const part of response.output) {
        switch (part.type) {
          case "reasoning": {
            if (part.summary.length === 0) {
              part.summary.push({ type: "summary_text", text: "" });
            }
            for (const summary of part.summary) {
              content.push({
                type: "reasoning",
                text: summary.text,
                providerMetadata: {
                  openai: {
                    itemId: part.id,
                    reasoningEncryptedContent: (_a = part.encrypted_content) != null ? _a : null
                  }
                }
              });
            }
            break;
          }
          case "message": {
            for (const contentPart of part.content) {
              if (((_c = (_b = options.providerOptions) == null ? void 0 : _b.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
                logprobs.push(contentPart.logprobs);
              }
              content.push({
                type: "text",
                text: contentPart.text,
                providerMetadata: {
                  openai: {
                    itemId: part.id
                  }
                }
              });
              for (const annotation of contentPart.annotations) {
                if (annotation.type === "url_citation") {
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId$1(),
                    url: annotation.url,
                    title: annotation.title
                  });
                } else if (annotation.type === "file_citation") {
                  content.push({
                    type: "source",
                    sourceType: "document",
                    id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId$1(),
                    mediaType: "text/plain",
                    title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : "Document",
                    filename: (_l = annotation.filename) != null ? _l : annotation.file_id
                  });
                }
              }
            }
            break;
          }
          case "function_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.call_id,
              toolName: part.name,
              input: part.arguments,
              providerMetadata: {
                openai: {
                  itemId: part.id
                }
              }
            });
            break;
          }
          case "web_search_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "web_search_preview",
              input: JSON.stringify({ action: part.action }),
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "web_search_preview",
              result: { status: part.status },
              providerExecuted: true
            });
            break;
          }
          case "computer_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "computer_use",
              input: "",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "computer_use",
              result: {
                type: "computer_use_tool_result",
                status: part.status || "completed"
              },
              providerExecuted: true
            });
            break;
          }
          case "file_search_call": {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "file_search",
              input: "",
              providerExecuted: true
            });
            content.push({
              type: "tool-result",
              toolCallId: part.id,
              toolName: "file_search",
              result: {
                type: "file_search_tool_result",
                status: part.status || "completed",
                ...part.queries && { queries: part.queries },
                ...part.results && { results: part.results }
              },
              providerExecuted: true
            });
            break;
          }
        }
      }
      const providerMetadata = {
        openai: { responseId: response.id }
      };
      if (logprobs.length > 0) {
        providerMetadata.openai.logprobs = logprobs;
      }
      if (typeof response.service_tier === "string") {
        providerMetadata.openai.serviceTier = response.service_tier;
      }
      return {
        content,
        finishReason: mapOpenAIResponseFinishReason({
          finishReason: (_m = response.incomplete_details) == null ? void 0 : _m.reason,
          hasToolCalls: content.some((part) => part.type === "tool-call")
        }),
        usage: {
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens,
          totalTokens: response.usage.input_tokens + response.usage.output_tokens,
          reasoningTokens: (_o = (_n = response.usage.output_tokens_details) == null ? void 0 : _n.reasoning_tokens) != null ? _o : void 0,
          cachedInputTokens: (_q = (_p = response.usage.input_tokens_details) == null ? void 0 : _p.cached_tokens) != null ? _q : void 0
        },
        request: { body },
        response: {
          id: response.id,
          timestamp: new Date(response.created_at * 1e3),
          modelId: response.model,
          headers: responseHeaders,
          body: rawResponse
        },
        providerMetadata,
        warnings
      };
    }
    async doStream(options) {
      const { args: body, warnings } = await this.getArgs(options);
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: this.config.url({
          path: "/responses",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body: {
          ...body,
          stream: true
        },
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          openaiResponsesChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const self = this;
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      const logprobs = [];
      let responseId = null;
      const ongoingToolCalls = {};
      let hasToolCalls = false;
      const activeReasoning = {};
      let serviceTier;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                finishReason = "error";
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isResponseOutputItemAddedChunk(value)) {
                if (value.item.type === "function_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: value.item.name,
                    toolCallId: value.item.call_id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.call_id,
                    toolName: value.item.name
                  });
                } else if (value.item.type === "web_search_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: "web_search_preview",
                    toolCallId: value.item.id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: "web_search_preview"
                  });
                } else if (value.item.type === "computer_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: "computer_use",
                    toolCallId: value.item.id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: "computer_use"
                  });
                } else if (value.item.type === "file_search_call") {
                  ongoingToolCalls[value.output_index] = {
                    toolName: "file_search",
                    toolCallId: value.item.id
                  };
                  controller.enqueue({
                    type: "tool-input-start",
                    id: value.item.id,
                    toolName: "file_search"
                  });
                } else if (value.item.type === "message") {
                  controller.enqueue({
                    type: "text-start",
                    id: value.item.id,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id
                      }
                    }
                  });
                } else if (isResponseOutputItemAddedReasoningChunk(value)) {
                  activeReasoning[value.item.id] = {
                    encryptedContent: value.item.encrypted_content,
                    summaryParts: [0]
                  };
                  controller.enqueue({
                    type: "reasoning-start",
                    id: `${value.item.id}:0`,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id,
                        reasoningEncryptedContent: (_a = value.item.encrypted_content) != null ? _a : null
                      }
                    }
                  });
                }
              } else if (isResponseOutputItemDoneChunk(value)) {
                if (value.item.type === "function_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  hasToolCalls = true;
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.call_id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.call_id,
                    toolName: value.item.name,
                    input: value.item.arguments,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id
                      }
                    }
                  });
                } else if (value.item.type === "web_search_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  hasToolCalls = true;
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "web_search_preview",
                    input: JSON.stringify({ action: value.item.action }),
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "web_search_preview",
                    result: { status: value.item.status },
                    providerExecuted: true
                  });
                } else if (value.item.type === "computer_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  hasToolCalls = true;
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "computer_use",
                    input: "",
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "computer_use",
                    result: {
                      type: "computer_use_tool_result",
                      status: value.item.status || "completed"
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "file_search_call") {
                  ongoingToolCalls[value.output_index] = void 0;
                  hasToolCalls = true;
                  controller.enqueue({
                    type: "tool-input-end",
                    id: value.item.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: value.item.id,
                    toolName: "file_search",
                    input: "",
                    providerExecuted: true
                  });
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: value.item.id,
                    toolName: "file_search",
                    result: {
                      type: "file_search_tool_result",
                      status: value.item.status || "completed",
                      ...value.item.queries && { queries: value.item.queries },
                      ...value.item.results && { results: value.item.results }
                    },
                    providerExecuted: true
                  });
                } else if (value.item.type === "message") {
                  controller.enqueue({
                    type: "text-end",
                    id: value.item.id
                  });
                } else if (isResponseOutputItemDoneReasoningChunk(value)) {
                  const activeReasoningPart = activeReasoning[value.item.id];
                  for (const summaryIndex of activeReasoningPart.summaryParts) {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: `${value.item.id}:${summaryIndex}`,
                      providerMetadata: {
                        openai: {
                          itemId: value.item.id,
                          reasoningEncryptedContent: (_b = value.item.encrypted_content) != null ? _b : null
                        }
                      }
                    });
                  }
                  delete activeReasoning[value.item.id];
                }
              } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {
                const toolCall = ongoingToolCalls[value.output_index];
                if (toolCall != null) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    delta: value.delta
                  });
                }
              } else if (isResponseCreatedChunk(value)) {
                responseId = value.response.id;
                controller.enqueue({
                  type: "response-metadata",
                  id: value.response.id,
                  timestamp: new Date(value.response.created_at * 1e3),
                  modelId: value.response.model
                });
              } else if (isTextDeltaChunk(value)) {
                controller.enqueue({
                  type: "text-delta",
                  id: value.item_id,
                  delta: value.delta
                });
                if (((_d = (_c = options.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d.logprobs) && value.logprobs) {
                  logprobs.push(value.logprobs);
                }
              } else if (isResponseReasoningSummaryPartAddedChunk(value)) {
                if (value.summary_index > 0) {
                  (_e = activeReasoning[value.item_id]) == null ? void 0 : _e.summaryParts.push(
                    value.summary_index
                  );
                  controller.enqueue({
                    type: "reasoning-start",
                    id: `${value.item_id}:${value.summary_index}`,
                    providerMetadata: {
                      openai: {
                        itemId: value.item_id,
                        reasoningEncryptedContent: (_g = (_f = activeReasoning[value.item_id]) == null ? void 0 : _f.encryptedContent) != null ? _g : null
                      }
                    }
                  });
                }
              } else if (isResponseReasoningSummaryTextDeltaChunk(value)) {
                controller.enqueue({
                  type: "reasoning-delta",
                  id: `${value.item_id}:${value.summary_index}`,
                  delta: value.delta,
                  providerMetadata: {
                    openai: {
                      itemId: value.item_id
                    }
                  }
                });
              } else if (isResponseFinishedChunk(value)) {
                finishReason = mapOpenAIResponseFinishReason({
                  finishReason: (_h = value.response.incomplete_details) == null ? void 0 : _h.reason,
                  hasToolCalls
                });
                usage.inputTokens = value.response.usage.input_tokens;
                usage.outputTokens = value.response.usage.output_tokens;
                usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;
                usage.reasoningTokens = (_j = (_i = value.response.usage.output_tokens_details) == null ? void 0 : _i.reasoning_tokens) != null ? _j : void 0;
                usage.cachedInputTokens = (_l = (_k = value.response.usage.input_tokens_details) == null ? void 0 : _k.cached_tokens) != null ? _l : void 0;
                if (typeof value.response.service_tier === "string") {
                  serviceTier = value.response.service_tier;
                }
              } else if (isResponseAnnotationAddedChunk(value)) {
                if (value.annotation.type === "url_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: (_o = (_n = (_m = self.config).generateId) == null ? void 0 : _n.call(_m)) != null ? _o : generateId$1(),
                    url: value.annotation.url,
                    title: value.annotation.title
                  });
                } else if (value.annotation.type === "file_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "document",
                    id: (_r = (_q = (_p = self.config).generateId) == null ? void 0 : _q.call(_p)) != null ? _r : generateId$1(),
                    mediaType: "text/plain",
                    title: (_t = (_s = value.annotation.quote) != null ? _s : value.annotation.filename) != null ? _t : "Document",
                    filename: (_u = value.annotation.filename) != null ? _u : value.annotation.file_id
                  });
                }
              } else if (isErrorChunk(value)) {
                controller.enqueue({ type: "error", error: value });
              }
            },
            flush(controller) {
              const providerMetadata = {
                openai: {
                  responseId
                }
              };
              if (logprobs.length > 0) {
                providerMetadata.openai.logprobs = logprobs;
              }
              if (serviceTier !== void 0) {
                providerMetadata.openai.serviceTier = serviceTier;
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    }
  };
  var usageSchema2 = object$1({
    input_tokens: number$1(),
    input_tokens_details: object$1({ cached_tokens: number$1().nullish() }).nullish(),
    output_tokens: number$1(),
    output_tokens_details: object$1({ reasoning_tokens: number$1().nullish() }).nullish()
  });
  var textDeltaChunkSchema = object$1({
    type: literal("response.output_text.delta"),
    item_id: string$1(),
    delta: string$1(),
    logprobs: LOGPROBS_SCHEMA.nullish()
  });
  var errorChunkSchema = object$1({
    type: literal("error"),
    code: string$1(),
    message: string$1(),
    param: string$1().nullish(),
    sequence_number: number$1()
  });
  var responseFinishedChunkSchema = object$1({
    type: _enum(["response.completed", "response.incomplete"]),
    response: object$1({
      incomplete_details: object$1({ reason: string$1() }).nullish(),
      usage: usageSchema2,
      service_tier: string$1().nullish()
    })
  });
  var responseCreatedChunkSchema = object$1({
    type: literal("response.created"),
    response: object$1({
      id: string$1(),
      created_at: number$1(),
      model: string$1(),
      service_tier: string$1().nullish()
    })
  });
  var responseOutputItemAddedSchema = object$1({
    type: literal("response.output_item.added"),
    output_index: number$1(),
    item: discriminatedUnion("type", [
      object$1({
        type: literal("message"),
        id: string$1()
      }),
      object$1({
        type: literal("reasoning"),
        id: string$1(),
        encrypted_content: string$1().nullish()
      }),
      object$1({
        type: literal("function_call"),
        id: string$1(),
        call_id: string$1(),
        name: string$1(),
        arguments: string$1()
      }),
      object$1({
        type: literal("web_search_call"),
        id: string$1(),
        status: string$1(),
        action: object$1({
          type: literal("search"),
          query: string$1().optional()
        }).nullish()
      }),
      object$1({
        type: literal("computer_call"),
        id: string$1(),
        status: string$1()
      }),
      object$1({
        type: literal("file_search_call"),
        id: string$1(),
        status: string$1(),
        queries: array(string$1()).nullish(),
        results: array(
          object$1({
            attributes: object$1({
              file_id: string$1(),
              filename: string$1(),
              score: number$1(),
              text: string$1()
            })
          })
        ).optional()
      })
    ])
  });
  var responseOutputItemDoneSchema = object$1({
    type: literal("response.output_item.done"),
    output_index: number$1(),
    item: discriminatedUnion("type", [
      object$1({
        type: literal("message"),
        id: string$1()
      }),
      object$1({
        type: literal("reasoning"),
        id: string$1(),
        encrypted_content: string$1().nullish()
      }),
      object$1({
        type: literal("function_call"),
        id: string$1(),
        call_id: string$1(),
        name: string$1(),
        arguments: string$1(),
        status: literal("completed")
      }),
      webSearchCallItem,
      object$1({
        type: literal("computer_call"),
        id: string$1(),
        status: literal("completed")
      }),
      object$1({
        type: literal("file_search_call"),
        id: string$1(),
        status: literal("completed"),
        queries: array(string$1()).nullish(),
        results: array(
          object$1({
            attributes: object$1({
              file_id: string$1(),
              filename: string$1(),
              score: number$1(),
              text: string$1()
            })
          })
        ).nullish()
      })
    ])
  });
  var responseFunctionCallArgumentsDeltaSchema = object$1({
    type: literal("response.function_call_arguments.delta"),
    item_id: string$1(),
    output_index: number$1(),
    delta: string$1()
  });
  var responseAnnotationAddedSchema = object$1({
    type: literal("response.output_text.annotation.added"),
    annotation: discriminatedUnion("type", [
      object$1({
        type: literal("url_citation"),
        url: string$1(),
        title: string$1()
      }),
      object$1({
        type: literal("file_citation"),
        file_id: string$1(),
        filename: string$1().nullish(),
        index: number$1().nullish(),
        start_index: number$1().nullish(),
        end_index: number$1().nullish(),
        quote: string$1().nullish()
      })
    ])
  });
  var responseReasoningSummaryPartAddedSchema = object$1({
    type: literal("response.reasoning_summary_part.added"),
    item_id: string$1(),
    summary_index: number$1()
  });
  var responseReasoningSummaryTextDeltaSchema = object$1({
    type: literal("response.reasoning_summary_text.delta"),
    item_id: string$1(),
    summary_index: number$1(),
    delta: string$1()
  });
  var openaiResponsesChunkSchema = union([
    textDeltaChunkSchema,
    responseFinishedChunkSchema,
    responseCreatedChunkSchema,
    responseOutputItemAddedSchema,
    responseOutputItemDoneSchema,
    responseFunctionCallArgumentsDeltaSchema,
    responseAnnotationAddedSchema,
    responseReasoningSummaryPartAddedSchema,
    responseReasoningSummaryTextDeltaSchema,
    errorChunkSchema,
    object$1({ type: string$1() }).loose()
    // fallback for unknown chunks
  ]);
  function isTextDeltaChunk(chunk) {
    return chunk.type === "response.output_text.delta";
  }
  function isResponseOutputItemDoneChunk(chunk) {
    return chunk.type === "response.output_item.done";
  }
  function isResponseOutputItemDoneReasoningChunk(chunk) {
    return isResponseOutputItemDoneChunk(chunk) && chunk.item.type === "reasoning";
  }
  function isResponseFinishedChunk(chunk) {
    return chunk.type === "response.completed" || chunk.type === "response.incomplete";
  }
  function isResponseCreatedChunk(chunk) {
    return chunk.type === "response.created";
  }
  function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
    return chunk.type === "response.function_call_arguments.delta";
  }
  function isResponseOutputItemAddedChunk(chunk) {
    return chunk.type === "response.output_item.added";
  }
  function isResponseOutputItemAddedReasoningChunk(chunk) {
    return isResponseOutputItemAddedChunk(chunk) && chunk.item.type === "reasoning";
  }
  function isResponseAnnotationAddedChunk(chunk) {
    return chunk.type === "response.output_text.annotation.added";
  }
  function isResponseReasoningSummaryPartAddedChunk(chunk) {
    return chunk.type === "response.reasoning_summary_part.added";
  }
  function isResponseReasoningSummaryTextDeltaChunk(chunk) {
    return chunk.type === "response.reasoning_summary_text.delta";
  }
  function isErrorChunk(chunk) {
    return chunk.type === "error";
  }
  function getResponsesModelConfig(modelId) {
    const supportsFlexProcessing2 = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
    const supportsPriorityProcessing2 = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
    const defaults = {
      requiredAutoTruncation: false,
      systemMessageMode: "system",
      supportsFlexProcessing: supportsFlexProcessing2,
      supportsPriorityProcessing: supportsPriorityProcessing2
    };
    if (modelId.startsWith("gpt-5-chat")) {
      return {
        ...defaults,
        isReasoningModel: false
      };
    }
    if (modelId.startsWith("o") || modelId.startsWith("gpt-5") || modelId.startsWith("codex-") || modelId.startsWith("computer-use")) {
      if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
        return {
          ...defaults,
          isReasoningModel: true,
          systemMessageMode: "remove"
        };
      }
      return {
        ...defaults,
        isReasoningModel: true,
        systemMessageMode: "developer"
      };
    }
    return {
      ...defaults,
      isReasoningModel: false
    };
  }
  var openaiResponsesProviderOptionsSchema = object$1({
    metadata: any().nullish(),
    parallelToolCalls: boolean$1().nullish(),
    previousResponseId: string$1().nullish(),
    store: boolean$1().nullish(),
    user: string$1().nullish(),
    reasoningEffort: string$1().nullish(),
    strictJsonSchema: boolean$1().nullish(),
    instructions: string$1().nullish(),
    reasoningSummary: string$1().nullish(),
    serviceTier: _enum(["auto", "flex", "priority"]).nullish(),
    include: array(
      _enum([
        "reasoning.encrypted_content",
        "file_search_call.results",
        "message.output_text.logprobs"
      ])
    ).nullish(),
    textVerbosity: _enum(["low", "medium", "high"]).nullish(),
    promptCacheKey: string$1().nullish(),
    safetyIdentifier: string$1().nullish(),
    /**
     * Return the log probabilities of the tokens.
     *
     * Setting to true will return the log probabilities of the tokens that
     * were generated.
     *
     * Setting to a number will return the log probabilities of the top n
     * tokens that were generated.
     *
     * @see https://platform.openai.com/docs/api-reference/responses/create
     * @see https://cookbook.openai.com/examples/using_logprobs
     */
    logprobs: union([boolean$1(), number$1().min(1).max(TOP_LOGPROBS_MAX)]).optional()
  });
  var OpenAIProviderOptionsSchema = object$1({
    instructions: string$1().nullish(),
    speed: number$1().min(0.25).max(4).default(1).nullish()
  });
  var OpenAISpeechModel = class {
    constructor(modelId, config) {
      this.modelId = modelId;
      this.config = config;
      this.specificationVersion = "v2";
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs({
      text,
      voice = "alloy",
      outputFormat = "mp3",
      speed,
      instructions,
      language,
      providerOptions
    }) {
      const warnings = [];
      const openAIOptions = await parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: OpenAIProviderOptionsSchema
      });
      const requestBody = {
        model: this.modelId,
        input: text,
        voice,
        response_format: "mp3",
        speed,
        instructions
      };
      if (outputFormat) {
        if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat)) {
          requestBody.response_format = outputFormat;
        } else {
          warnings.push({
            type: "unsupported-setting",
            setting: "outputFormat",
            details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
          });
        }
      }
      if (openAIOptions) {
        const speechModelOptions = {};
        for (const key in speechModelOptions) {
          const value = speechModelOptions[key];
          if (value !== void 0) {
            requestBody[key] = value;
          }
        }
      }
      if (language) {
        warnings.push({
          type: "unsupported-setting",
          setting: "language",
          details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
        });
      }
      return {
        requestBody,
        warnings
      };
    }
    async doGenerate(options) {
      var _a, _b, _c;
      const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
      const { requestBody, warnings } = await this.getArgs(options);
      const {
        value: audio,
        responseHeaders,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url: this.config.url({
          path: "/audio/speech",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body: requestBody,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createBinaryResponseHandler(),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      return {
        audio,
        warnings,
        request: {
          body: JSON.stringify(requestBody)
        },
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders,
          body: rawResponse
        }
      };
    }
  };
  var openAITranscriptionProviderOptions = object$1({
    /**
     * Additional information to include in the transcription response.
     */
    include: array(string$1()).optional(),
    /**
     * The language of the input audio in ISO-639-1 format.
     */
    language: string$1().optional(),
    /**
     * An optional text to guide the model's style or continue a previous audio segment.
     */
    prompt: string$1().optional(),
    /**
     * The sampling temperature, between 0 and 1.
     * @default 0
     */
    temperature: number$1().min(0).max(1).default(0).optional(),
    /**
     * The timestamp granularities to populate for this transcription.
     * @default ['segment']
     */
    timestampGranularities: array(_enum(["word", "segment"])).default(["segment"]).optional()
  });

  // src/transcription/openai-transcription-model.ts
  var languageMap = {
    afrikaans: "af",
    arabic: "ar",
    armenian: "hy",
    azerbaijani: "az",
    belarusian: "be",
    bosnian: "bs",
    bulgarian: "bg",
    catalan: "ca",
    chinese: "zh",
    croatian: "hr",
    czech: "cs",
    danish: "da",
    dutch: "nl",
    english: "en",
    estonian: "et",
    finnish: "fi",
    french: "fr",
    galician: "gl",
    german: "de",
    greek: "el",
    hebrew: "he",
    hindi: "hi",
    hungarian: "hu",
    icelandic: "is",
    indonesian: "id",
    italian: "it",
    japanese: "ja",
    kannada: "kn",
    kazakh: "kk",
    korean: "ko",
    latvian: "lv",
    lithuanian: "lt",
    macedonian: "mk",
    malay: "ms",
    marathi: "mr",
    maori: "mi",
    nepali: "ne",
    norwegian: "no",
    persian: "fa",
    polish: "pl",
    portuguese: "pt",
    romanian: "ro",
    russian: "ru",
    serbian: "sr",
    slovak: "sk",
    slovenian: "sl",
    spanish: "es",
    swahili: "sw",
    swedish: "sv",
    tagalog: "tl",
    tamil: "ta",
    thai: "th",
    turkish: "tr",
    ukrainian: "uk",
    urdu: "ur",
    vietnamese: "vi",
    welsh: "cy"
  };
  var OpenAITranscriptionModel = class {
    constructor(modelId, config) {
      this.modelId = modelId;
      this.config = config;
      this.specificationVersion = "v2";
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs({
      audio,
      mediaType,
      providerOptions
    }) {
      const warnings = [];
      const openAIOptions = await parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openAITranscriptionProviderOptions
      });
      const formData = new FormData();
      const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
      formData.append("model", this.modelId);
      const fileExtension = mediaTypeToExtension(mediaType);
      formData.append(
        "file",
        new File([blob], "audio", { type: mediaType }),
        `audio.${fileExtension}`
      );
      if (openAIOptions) {
        const transcriptionModelOptions = {
          include: openAIOptions.include,
          language: openAIOptions.language,
          prompt: openAIOptions.prompt,
          // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
          // prefer verbose_json to get segments for models that support it
          response_format: [
            "gpt-4o-transcribe",
            "gpt-4o-mini-transcribe"
          ].includes(this.modelId) ? "json" : "verbose_json",
          temperature: openAIOptions.temperature,
          timestamp_granularities: openAIOptions.timestampGranularities
        };
        for (const [key, value] of Object.entries(transcriptionModelOptions)) {
          if (value != null) {
            formData.append(key, String(value));
          }
        }
      }
      return {
        formData,
        warnings
      };
    }
    async doGenerate(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
      const { formData, warnings } = await this.getArgs(options);
      const {
        value: response,
        responseHeaders,
        rawValue: rawResponse
      } = await postFormDataToApi({
        url: this.config.url({
          path: "/audio/transcriptions",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), options.headers),
        formData,
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          openaiTranscriptionResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
      return {
        text: response.text,
        segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map((segment) => ({
          text: segment.text,
          startSecond: segment.start,
          endSecond: segment.end
        }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word) => ({
          text: word.word,
          startSecond: word.start,
          endSecond: word.end
        }))) != null ? _g : [],
        language,
        durationInSeconds: (_h = response.duration) != null ? _h : void 0,
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders,
          body: rawResponse
        }
      };
    }
  };
  var openaiTranscriptionResponseSchema = object$1({
    text: string$1(),
    language: string$1().nullish(),
    duration: number$1().nullish(),
    words: array(
      object$1({
        word: string$1(),
        start: number$1(),
        end: number$1()
      })
    ).nullish(),
    segments: array(
      object$1({
        id: number$1(),
        seek: number$1(),
        start: number$1(),
        end: number$1(),
        text: string$1(),
        tokens: array(number$1()),
        temperature: number$1(),
        avg_logprob: number$1(),
        compression_ratio: number$1(),
        no_speech_prob: number$1()
      })
    ).nullish()
  });

  // src/openai-provider.ts
  function createOpenAI(options = {}) {
    var _a, _b;
    const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://api.openai.com/v1";
    const providerName = (_b = options.name) != null ? _b : "openai";
    const getHeaders = () => ({
      Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "OPENAI_API_KEY",
      description: "OpenAI"
    })}`,
      "OpenAI-Organization": options.organization,
      "OpenAI-Project": options.project,
      ...options.headers
    });
    const createChatModel = (modelId) => new OpenAIChatLanguageModel(modelId, {
      provider: `${providerName}.chat`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
    const createCompletionModel = (modelId) => new OpenAICompletionLanguageModel(modelId, {
      provider: `${providerName}.completion`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
    const createEmbeddingModel = (modelId) => new OpenAIEmbeddingModel(modelId, {
      provider: `${providerName}.embedding`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
    const createImageModel = (modelId) => new OpenAIImageModel(modelId, {
      provider: `${providerName}.image`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
    const createTranscriptionModel = (modelId) => new OpenAITranscriptionModel(modelId, {
      provider: `${providerName}.transcription`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
    const createSpeechModel = (modelId) => new OpenAISpeechModel(modelId, {
      provider: `${providerName}.speech`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
    const createLanguageModel = (modelId) => {
      if (new.target) {
        throw new Error(
          "The OpenAI model function cannot be called with the new keyword."
        );
      }
      return createResponsesModel(modelId);
    };
    const createResponsesModel = (modelId) => {
      return new OpenAIResponsesLanguageModel(modelId, {
        provider: `${providerName}.responses`,
        url: ({ path }) => `${baseURL}${path}`,
        headers: getHeaders,
        fetch: options.fetch,
        fileIdPrefixes: ["file-"]
      });
    };
    const provider = function(modelId) {
      return createLanguageModel(modelId);
    };
    provider.languageModel = createLanguageModel;
    provider.chat = createChatModel;
    provider.completion = createCompletionModel;
    provider.responses = createResponsesModel;
    provider.embedding = createEmbeddingModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    provider.image = createImageModel;
    provider.imageModel = createImageModel;
    provider.transcription = createTranscriptionModel;
    provider.transcriptionModel = createTranscriptionModel;
    provider.speech = createSpeechModel;
    provider.speechModel = createSpeechModel;
    provider.tools = openaiTools;
    return provider;
  }
  createOpenAI();

  // src/anthropic-provider.ts
  var anthropicErrorDataSchema = object$1({
    type: literal("error"),
    error: object$1({
      type: string$1(),
      message: string$1()
    })
  });
  var anthropicFailedResponseHandler = createJsonErrorResponseHandler$1({
    errorSchema: anthropicErrorDataSchema,
    errorToMessage: (data) => data.error.message
  });
  var anthropicFilePartProviderOptions = object$1({
    /**
     * Citation configuration for this document.
     * When enabled, this document will generate citations in the response.
     */
    citations: object$1({
      /**
       * Enable citations for this document
       */
      enabled: boolean$1()
    }).optional(),
    /**
     * Custom title for the document.
     * If not provided, the filename will be used.
     */
    title: string$1().optional(),
    /**
     * Context about the document that will be passed to the model
     * but not used towards cited content.
     * Useful for storing document metadata as text or stringified JSON.
     */
    context: string$1().optional()
  });
  var anthropicProviderOptions = object$1({
    sendReasoning: boolean$1().optional(),
    thinking: object$1({
      type: union([literal("enabled"), literal("disabled")]),
      budgetTokens: number$1().optional()
    }).optional(),
    /**
     * Whether to disable parallel function calling during tool use. Default is false.
     * When set to true, Claude will use at most one tool per response.
     */
    disableParallelToolUse: boolean$1().optional()
  });

  // src/get-cache-control.ts
  function getCacheControl(providerMetadata) {
    var _a;
    const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
    const cacheControlValue = (_a = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a : anthropic2 == null ? void 0 : anthropic2.cache_control;
    return cacheControlValue;
  }
  var webSearch_20250305ArgsSchema = object$1({
    /**
     * Maximum number of web searches Claude can perform during the conversation.
     */
    maxUses: number$1().optional(),
    /**
     * Optional list of domains that Claude is allowed to search.
     */
    allowedDomains: array(string$1()).optional(),
    /**
     * Optional list of domains that Claude should avoid when searching.
     */
    blockedDomains: array(string$1()).optional(),
    /**
     * Optional user location information to provide geographically relevant search results.
     */
    userLocation: object$1({
      type: literal("approximate"),
      city: string$1().optional(),
      region: string$1().optional(),
      country: string$1().optional(),
      timezone: string$1().optional()
    }).optional()
  });
  var webSearch_20250305OutputSchema = array(
    object$1({
      url: string$1(),
      title: string$1(),
      pageAge: string$1().nullable(),
      encryptedContent: string$1(),
      type: string$1()
    })
  );
  var factory = createProviderDefinedToolFactoryWithOutputSchema({
    id: "anthropic.web_search_20250305",
    name: "web_search",
    inputSchema: object$1({
      query: string$1()
    }),
    outputSchema: webSearch_20250305OutputSchema
  });
  var webSearch_20250305 = (args = {}) => {
    return factory(args);
  };

  // src/anthropic-prepare-tools.ts
  function isWebSearchTool(tool) {
    return typeof tool === "object" && tool !== null && "type" in tool && tool.type === "web_search_20250305";
  }
  function prepareTools$2({
    tools,
    toolChoice,
    disableParallelToolUse
  }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    const betas = /* @__PURE__ */ new Set();
    if (tools == null) {
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    }
    const anthropicTools2 = [];
    for (const tool of tools) {
      if (isWebSearchTool(tool)) {
        anthropicTools2.push(tool);
        continue;
      }
      switch (tool.type) {
        case "function":
          const cacheControl = getCacheControl(tool.providerOptions);
          anthropicTools2.push({
            name: tool.name,
            description: tool.description,
            input_schema: tool.inputSchema,
            cache_control: cacheControl
          });
          break;
        case "provider-defined":
          switch (tool.id) {
            case "anthropic.computer_20250124":
              betas.add("computer-use-2025-01-24");
              anthropicTools2.push({
                name: "computer",
                type: "computer_20250124",
                display_width_px: tool.args.displayWidthPx,
                display_height_px: tool.args.displayHeightPx,
                display_number: tool.args.displayNumber
              });
              break;
            case "anthropic.computer_20241022":
              betas.add("computer-use-2024-10-22");
              anthropicTools2.push({
                name: "computer",
                type: "computer_20241022",
                display_width_px: tool.args.displayWidthPx,
                display_height_px: tool.args.displayHeightPx,
                display_number: tool.args.displayNumber
              });
              break;
            case "anthropic.text_editor_20250124":
              betas.add("computer-use-2025-01-24");
              anthropicTools2.push({
                name: "str_replace_editor",
                type: "text_editor_20250124"
              });
              break;
            case "anthropic.text_editor_20241022":
              betas.add("computer-use-2024-10-22");
              anthropicTools2.push({
                name: "str_replace_editor",
                type: "text_editor_20241022"
              });
              break;
            case "anthropic.text_editor_20250429":
              betas.add("computer-use-2025-01-24");
              anthropicTools2.push({
                name: "str_replace_based_edit_tool",
                type: "text_editor_20250429"
              });
              break;
            case "anthropic.bash_20250124":
              betas.add("computer-use-2025-01-24");
              anthropicTools2.push({
                name: "bash",
                type: "bash_20250124"
              });
              break;
            case "anthropic.bash_20241022":
              betas.add("computer-use-2024-10-22");
              anthropicTools2.push({
                name: "bash",
                type: "bash_20241022"
              });
              break;
            case "anthropic.web_search_20250305": {
              const args = webSearch_20250305ArgsSchema.parse(tool.args);
              anthropicTools2.push({
                type: "web_search_20250305",
                name: "web_search",
                max_uses: args.maxUses,
                allowed_domains: args.allowedDomains,
                blocked_domains: args.blockedDomains,
                user_location: args.userLocation
              });
              break;
            }
            case "anthropic.code_execution_20250522": {
              betas.add("code-execution-2025-05-22");
              anthropicTools2.push({
                type: "code_execution_20250522",
                name: "code_execution"
              });
              break;
            }
            default:
              toolWarnings.push({ type: "unsupported-tool", tool });
              break;
          }
          break;
        default:
          toolWarnings.push({ type: "unsupported-tool", tool });
          break;
      }
    }
    if (toolChoice == null) {
      return {
        tools: anthropicTools2,
        toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
        toolWarnings,
        betas
      };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
        return {
          tools: anthropicTools2,
          toolChoice: {
            type: "auto",
            disable_parallel_tool_use: disableParallelToolUse
          },
          toolWarnings,
          betas
        };
      case "required":
        return {
          tools: anthropicTools2,
          toolChoice: {
            type: "any",
            disable_parallel_tool_use: disableParallelToolUse
          },
          toolWarnings,
          betas
        };
      case "none":
        return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
      case "tool":
        return {
          tools: anthropicTools2,
          toolChoice: {
            type: "tool",
            name: toolChoice.toolName,
            disable_parallel_tool_use: disableParallelToolUse
          },
          toolWarnings,
          betas
        };
      default: {
        const _exhaustiveCheck = type;
        throw new UnsupportedFunctionalityError$1({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }
  var codeExecution_20250522OutputSchema = object$1({
    type: literal("code_execution_result"),
    stdout: string$1(),
    stderr: string$1(),
    return_code: number$1()
  });
  var factory2 = createProviderDefinedToolFactoryWithOutputSchema({
    id: "anthropic.code_execution_20250522",
    name: "code_execution",
    inputSchema: object$1({
      code: string$1()
    }),
    outputSchema: codeExecution_20250522OutputSchema
  });
  var codeExecution_20250522 = (args = {}) => {
    return factory2(args);
  };

  // src/convert-to-anthropic-messages-prompt.ts
  function convertToString(data) {
    if (typeof data === "string") {
      return Buffer.from(data, "base64").toString("utf-8");
    }
    if (data instanceof Uint8Array) {
      return new TextDecoder().decode(data);
    }
    if (data instanceof URL) {
      throw new UnsupportedFunctionalityError$1({
        functionality: "URL-based text documents are not supported for citations"
      });
    }
    throw new UnsupportedFunctionalityError$1({
      functionality: `unsupported data type for text documents: ${typeof data}`
    });
  }
  async function convertToAnthropicMessagesPrompt({
    prompt,
    sendReasoning,
    warnings
  }) {
    var _a, _b, _c, _d, _e;
    const betas = /* @__PURE__ */ new Set();
    const blocks = groupIntoBlocks(prompt);
    let system = void 0;
    const messages = [];
    async function shouldEnableCitations(providerMetadata) {
      var _a2, _b2;
      const anthropicOptions = await parseProviderOptions({
        provider: "anthropic",
        providerOptions: providerMetadata,
        schema: anthropicFilePartProviderOptions
      });
      return (_b2 = (_a2 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a2.enabled) != null ? _b2 : false;
    }
    async function getDocumentMetadata(providerMetadata) {
      const anthropicOptions = await parseProviderOptions({
        provider: "anthropic",
        providerOptions: providerMetadata,
        schema: anthropicFilePartProviderOptions
      });
      return {
        title: anthropicOptions == null ? void 0 : anthropicOptions.title,
        context: anthropicOptions == null ? void 0 : anthropicOptions.context
      };
    }
    for (let i = 0; i < blocks.length; i++) {
      const block = blocks[i];
      const isLastBlock = i === blocks.length - 1;
      const type = block.type;
      switch (type) {
        case "system": {
          if (system != null) {
            throw new UnsupportedFunctionalityError$1({
              functionality: "Multiple system messages that are separated by user/assistant messages"
            });
          }
          system = block.messages.map(({ content, providerOptions }) => ({
            type: "text",
            text: content,
            cache_control: getCacheControl(providerOptions)
          }));
          break;
        }
        case "user": {
          const anthropicContent = [];
          for (const message of block.messages) {
            const { role, content } = message;
            switch (role) {
              case "user": {
                for (let j = 0; j < content.length; j++) {
                  const part = content[j];
                  const isLastPart = j === content.length - 1;
                  const cacheControl = (_a = getCacheControl(part.providerOptions)) != null ? _a : isLastPart ? getCacheControl(message.providerOptions) : void 0;
                  switch (part.type) {
                    case "text": {
                      anthropicContent.push({
                        type: "text",
                        text: part.text,
                        cache_control: cacheControl
                      });
                      break;
                    }
                    case "file": {
                      if (part.mediaType.startsWith("image/")) {
                        anthropicContent.push({
                          type: "image",
                          source: part.data instanceof URL ? {
                            type: "url",
                            url: part.data.toString()
                          } : {
                            type: "base64",
                            media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                            data: convertToBase64(part.data)
                          },
                          cache_control: cacheControl
                        });
                      } else if (part.mediaType === "application/pdf") {
                        betas.add("pdfs-2024-09-25");
                        const enableCitations = await shouldEnableCitations(
                          part.providerOptions
                        );
                        const metadata = await getDocumentMetadata(
                          part.providerOptions
                        );
                        anthropicContent.push({
                          type: "document",
                          source: part.data instanceof URL ? {
                            type: "url",
                            url: part.data.toString()
                          } : {
                            type: "base64",
                            media_type: "application/pdf",
                            data: convertToBase64(part.data)
                          },
                          title: (_b = metadata.title) != null ? _b : part.filename,
                          ...metadata.context && { context: metadata.context },
                          ...enableCitations && {
                            citations: { enabled: true }
                          },
                          cache_control: cacheControl
                        });
                      } else if (part.mediaType === "text/plain") {
                        const enableCitations = await shouldEnableCitations(
                          part.providerOptions
                        );
                        const metadata = await getDocumentMetadata(
                          part.providerOptions
                        );
                        anthropicContent.push({
                          type: "document",
                          source: part.data instanceof URL ? {
                            type: "url",
                            url: part.data.toString()
                          } : {
                            type: "text",
                            media_type: "text/plain",
                            data: convertToString(part.data)
                          },
                          title: (_c = metadata.title) != null ? _c : part.filename,
                          ...metadata.context && { context: metadata.context },
                          ...enableCitations && {
                            citations: { enabled: true }
                          },
                          cache_control: cacheControl
                        });
                      } else {
                        throw new UnsupportedFunctionalityError$1({
                          functionality: `media type: ${part.mediaType}`
                        });
                      }
                      break;
                    }
                  }
                }
                break;
              }
              case "tool": {
                for (let i2 = 0; i2 < content.length; i2++) {
                  const part = content[i2];
                  const isLastPart = i2 === content.length - 1;
                  const cacheControl = (_d = getCacheControl(part.providerOptions)) != null ? _d : isLastPart ? getCacheControl(message.providerOptions) : void 0;
                  const output = part.output;
                  let contentValue;
                  switch (output.type) {
                    case "content":
                      contentValue = output.value.map((contentPart) => {
                        switch (contentPart.type) {
                          case "text":
                            return {
                              type: "text",
                              text: contentPart.text,
                              cache_control: void 0
                            };
                          case "media": {
                            if (contentPart.mediaType.startsWith("image/")) {
                              return {
                                type: "image",
                                source: {
                                  type: "base64",
                                  media_type: contentPart.mediaType,
                                  data: contentPart.data
                                },
                                cache_control: void 0
                              };
                            }
                            throw new UnsupportedFunctionalityError$1({
                              functionality: `media type: ${contentPart.mediaType}`
                            });
                          }
                        }
                      });
                      break;
                    case "text":
                    case "error-text":
                      contentValue = output.value;
                      break;
                    case "json":
                    case "error-json":
                    default:
                      contentValue = JSON.stringify(output.value);
                      break;
                  }
                  anthropicContent.push({
                    type: "tool_result",
                    tool_use_id: part.toolCallId,
                    content: contentValue,
                    is_error: output.type === "error-text" || output.type === "error-json" ? true : void 0,
                    cache_control: cacheControl
                  });
                }
                break;
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          messages.push({ role: "user", content: anthropicContent });
          break;
        }
        case "assistant": {
          const anthropicContent = [];
          for (let j = 0; j < block.messages.length; j++) {
            const message = block.messages[j];
            const isLastMessage = j === block.messages.length - 1;
            const { content } = message;
            for (let k = 0; k < content.length; k++) {
              const part = content[k];
              const isLastContentPart = k === content.length - 1;
              const cacheControl = (_e = getCacheControl(part.providerOptions)) != null ? _e : isLastContentPart ? getCacheControl(message.providerOptions) : void 0;
              switch (part.type) {
                case "text": {
                  anthropicContent.push({
                    type: "text",
                    text: (
                      // trim the last text part if it's the last message in the block
                      // because Anthropic does not allow trailing whitespace
                      // in pre-filled assistant responses
                      isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text
                    ),
                    cache_control: cacheControl
                  });
                  break;
                }
                case "reasoning": {
                  if (sendReasoning) {
                    const reasoningMetadata = await parseProviderOptions({
                      provider: "anthropic",
                      providerOptions: part.providerOptions,
                      schema: anthropicReasoningMetadataSchema
                    });
                    if (reasoningMetadata != null) {
                      if (reasoningMetadata.signature != null) {
                        anthropicContent.push({
                          type: "thinking",
                          thinking: part.text,
                          signature: reasoningMetadata.signature,
                          cache_control: cacheControl
                        });
                      } else if (reasoningMetadata.redactedData != null) {
                        anthropicContent.push({
                          type: "redacted_thinking",
                          data: reasoningMetadata.redactedData,
                          cache_control: cacheControl
                        });
                      } else {
                        warnings.push({
                          type: "other",
                          message: "unsupported reasoning metadata"
                        });
                      }
                    } else {
                      warnings.push({
                        type: "other",
                        message: "unsupported reasoning metadata"
                      });
                    }
                  } else {
                    warnings.push({
                      type: "other",
                      message: "sending reasoning content is disabled for this model"
                    });
                  }
                  break;
                }
                case "tool-call": {
                  if (part.providerExecuted) {
                    if (part.toolName === "web_search") {
                      anthropicContent.push({
                        type: "server_tool_use",
                        id: part.toolCallId,
                        name: "web_search",
                        input: part.input,
                        cache_control: cacheControl
                      });
                      break;
                    }
                    if (part.toolName === "code_execution") {
                      anthropicContent.push({
                        type: "server_tool_use",
                        id: part.toolCallId,
                        name: "code_execution",
                        input: part.input,
                        cache_control: cacheControl
                      });
                      break;
                    }
                    warnings.push({
                      type: "other",
                      message: `provider executed tool call for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  anthropicContent.push({
                    type: "tool_use",
                    id: part.toolCallId,
                    name: part.toolName,
                    input: part.input,
                    cache_control: cacheControl
                  });
                  break;
                }
                case "tool-result": {
                  if (part.toolName === "web_search") {
                    const output = part.output;
                    if (output.type !== "json") {
                      warnings.push({
                        type: "other",
                        message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                      });
                      break;
                    }
                    const webSearchOutput = webSearch_20250305OutputSchema.parse(
                      output.value
                    );
                    anthropicContent.push({
                      type: "web_search_tool_result",
                      tool_use_id: part.toolCallId,
                      content: webSearchOutput.map((result) => ({
                        url: result.url,
                        title: result.title,
                        page_age: result.pageAge,
                        encrypted_content: result.encryptedContent,
                        type: result.type
                      })),
                      cache_control: cacheControl
                    });
                    break;
                  }
                  if (part.toolName === "code_execution") {
                    const output = part.output;
                    if (output.type !== "json") {
                      warnings.push({
                        type: "other",
                        message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                      });
                      break;
                    }
                    const codeExecutionOutput = codeExecution_20250522OutputSchema.parse(output.value);
                    anthropicContent.push({
                      type: "code_execution_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: codeExecutionOutput.type,
                        stdout: codeExecutionOutput.stdout,
                        stderr: codeExecutionOutput.stderr,
                        return_code: codeExecutionOutput.return_code
                      },
                      cache_control: cacheControl
                    });
                    break;
                  }
                  warnings.push({
                    type: "other",
                    message: `provider executed tool result for tool ${part.toolName} is not supported`
                  });
                  break;
                }
              }
            }
          }
          messages.push({ role: "assistant", content: anthropicContent });
          break;
        }
        default: {
          const _exhaustiveCheck = type;
          throw new Error(`content type: ${_exhaustiveCheck}`);
        }
      }
    }
    return {
      prompt: { system, messages },
      betas
    };
  }
  function groupIntoBlocks(prompt) {
    const blocks = [];
    let currentBlock = void 0;
    for (const message of prompt) {
      const { role } = message;
      switch (role) {
        case "system": {
          if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
            currentBlock = { type: "system", messages: [] };
            blocks.push(currentBlock);
          }
          currentBlock.messages.push(message);
          break;
        }
        case "assistant": {
          if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
            currentBlock = { type: "assistant", messages: [] };
            blocks.push(currentBlock);
          }
          currentBlock.messages.push(message);
          break;
        }
        case "user": {
          if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
            currentBlock = { type: "user", messages: [] };
            blocks.push(currentBlock);
          }
          currentBlock.messages.push(message);
          break;
        }
        case "tool": {
          if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
            currentBlock = { type: "user", messages: [] };
            blocks.push(currentBlock);
          }
          currentBlock.messages.push(message);
          break;
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return blocks;
  }

  // src/map-anthropic-stop-reason.ts
  function mapAnthropicStopReason({
    finishReason,
    isJsonResponseFromTool
  }) {
    switch (finishReason) {
      case "pause_turn":
      case "end_turn":
      case "stop_sequence":
        return "stop";
      case "refusal":
        return "content-filter";
      case "tool_use":
        return isJsonResponseFromTool ? "stop" : "tool-calls";
      case "max_tokens":
        return "length";
      default:
        return "unknown";
    }
  }

  // src/anthropic-messages-language-model.ts
  var citationSchemas = {
    webSearchResult: object$1({
      type: literal("web_search_result_location"),
      cited_text: string$1(),
      url: string$1(),
      title: string$1(),
      encrypted_index: string$1()
    }),
    pageLocation: object$1({
      type: literal("page_location"),
      cited_text: string$1(),
      document_index: number$1(),
      document_title: string$1().nullable(),
      start_page_number: number$1(),
      end_page_number: number$1()
    }),
    charLocation: object$1({
      type: literal("char_location"),
      cited_text: string$1(),
      document_index: number$1(),
      document_title: string$1().nullable(),
      start_char_index: number$1(),
      end_char_index: number$1()
    })
  };
  var citationSchema$1 = discriminatedUnion("type", [
    citationSchemas.webSearchResult,
    citationSchemas.pageLocation,
    citationSchemas.charLocation
  ]);
  discriminatedUnion("type", [
    citationSchemas.pageLocation,
    citationSchemas.charLocation
  ]);
  function processCitation(citation, citationDocuments, generateId3, onSource) {
    if (citation.type === "page_location" || citation.type === "char_location") {
      const source = createCitationSource(
        citation,
        citationDocuments,
        generateId3
      );
      if (source) {
        onSource(source);
      }
    }
  }
  function createCitationSource(citation, citationDocuments, generateId3) {
    var _a;
    const documentInfo = citationDocuments[citation.document_index];
    if (!documentInfo) {
      return null;
    }
    const providerMetadata = citation.type === "page_location" ? {
      citedText: citation.cited_text,
      startPageNumber: citation.start_page_number,
      endPageNumber: citation.end_page_number
    } : {
      citedText: citation.cited_text,
      startCharIndex: citation.start_char_index,
      endCharIndex: citation.end_char_index
    };
    return {
      type: "source",
      sourceType: "document",
      id: generateId3(),
      mediaType: documentInfo.mediaType,
      title: (_a = citation.document_title) != null ? _a : documentInfo.title,
      filename: documentInfo.filename,
      providerMetadata: {
        anthropic: providerMetadata
      }
    };
  }
  var AnthropicMessagesLanguageModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      var _a;
      this.modelId = modelId;
      this.config = config;
      this.generateId = (_a = config.generateId) != null ? _a : generateId$1;
    }
    supportsUrl(url) {
      return url.protocol === "https:";
    }
    get provider() {
      return this.config.provider;
    }
    get supportedUrls() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
    }
    async getArgs({
      prompt,
      maxOutputTokens = 4096,
      // 4096: max model output tokens TODO update default in v5
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      tools,
      toolChoice,
      providerOptions
    }) {
      var _a, _b, _c;
      const warnings = [];
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (seed != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "seed"
        });
      }
      if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
        if (responseFormat.schema == null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "responseFormat",
            details: "JSON response format requires a schema. The response format is ignored."
          });
        } else if (tools != null) {
          warnings.push({
            type: "unsupported-setting",
            setting: "tools",
            details: "JSON response format does not support tools. The provided tools are ignored."
          });
        }
      }
      const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
        type: "function",
        name: "json",
        description: "Respond with a JSON object.",
        inputSchema: responseFormat.schema
      } : void 0;
      const anthropicOptions = await parseProviderOptions({
        provider: "anthropic",
        providerOptions,
        schema: anthropicProviderOptions
      });
      const { prompt: messagesPrompt, betas: messagesBetas } = await convertToAnthropicMessagesPrompt({
        prompt,
        sendReasoning: (_a = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _a : true,
        warnings
      });
      const isThinking = ((_b = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _b.type) === "enabled";
      const thinkingBudget = (_c = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _c.budgetTokens;
      const baseArgs = {
        // model id:
        model: this.modelId,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_k: topK,
        top_p: topP,
        stop_sequences: stopSequences,
        // provider specific settings:
        ...isThinking && {
          thinking: { type: "enabled", budget_tokens: thinkingBudget }
        },
        // prompt:
        system: messagesPrompt.system,
        messages: messagesPrompt.messages
      };
      if (isThinking) {
        if (thinkingBudget == null) {
          throw new UnsupportedFunctionalityError$1({
            functionality: "thinking requires a budget"
          });
        }
        if (baseArgs.temperature != null) {
          baseArgs.temperature = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "temperature",
            details: "temperature is not supported when thinking is enabled"
          });
        }
        if (topK != null) {
          baseArgs.top_k = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topK",
            details: "topK is not supported when thinking is enabled"
          });
        }
        if (topP != null) {
          baseArgs.top_p = void 0;
          warnings.push({
            type: "unsupported-setting",
            setting: "topP",
            details: "topP is not supported when thinking is enabled"
          });
        }
        baseArgs.max_tokens = maxOutputTokens + thinkingBudget;
      }
      const {
        tools: anthropicTools2,
        toolChoice: anthropicToolChoice,
        toolWarnings,
        betas: toolsBetas
      } = prepareTools$2(
        jsonResponseTool != null ? {
          tools: [jsonResponseTool],
          toolChoice: { type: "tool", toolName: jsonResponseTool.name },
          disableParallelToolUse: true
        } : {
          tools: tools != null ? tools : [],
          toolChoice,
          disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse
        }
      );
      return {
        args: {
          ...baseArgs,
          tools: anthropicTools2,
          tool_choice: anthropicToolChoice
        },
        warnings: [...warnings, ...toolWarnings],
        betas: /* @__PURE__ */ new Set([...messagesBetas, ...toolsBetas]),
        usesJsonResponseTool: jsonResponseTool != null
      };
    }
    async getHeaders({
      betas,
      headers
    }) {
      return combineHeaders$1(
        await resolve(this.config.headers),
        betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {},
        headers
      );
    }
    buildRequestUrl(isStreaming) {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.config).buildRequestUrl) == null ? void 0 : _b.call(_a, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
    }
    transformRequestBody(args) {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.config).transformRequestBody) == null ? void 0 : _b.call(_a, args)) != null ? _c : args;
    }
    extractCitationDocuments(prompt) {
      const isCitationPart = (part) => {
        var _a, _b;
        if (part.type !== "file") {
          return false;
        }
        if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain") {
          return false;
        }
        const anthropic2 = (_a = part.providerOptions) == null ? void 0 : _a.anthropic;
        const citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
        return (_b = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b : false;
      };
      return prompt.filter((message) => message.role === "user").flatMap((message) => message.content).filter(isCitationPart).map((part) => {
        var _a;
        const filePart = part;
        return {
          title: (_a = filePart.filename) != null ? _a : "Untitled Document",
          filename: filePart.filename,
          mediaType: filePart.mediaType
        };
      });
    }
    async doGenerate(options) {
      var _a, _b, _c, _d, _e;
      const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
      const citationDocuments = this.extractCitationDocuments(options.prompt);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url: this.buildRequestUrl(false),
        headers: await this.getHeaders({ betas, headers: options.headers }),
        body: this.transformRequestBody(args),
        failedResponseHandler: anthropicFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          anthropicMessagesResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const content = [];
      for (const part of response.content) {
        switch (part.type) {
          case "text": {
            if (!usesJsonResponseTool) {
              content.push({ type: "text", text: part.text });
              if (part.citations) {
                for (const citation of part.citations) {
                  processCitation(
                    citation,
                    citationDocuments,
                    this.generateId,
                    (source) => content.push(source)
                  );
                }
              }
            }
            break;
          }
          case "thinking": {
            content.push({
              type: "reasoning",
              text: part.thinking,
              providerMetadata: {
                anthropic: {
                  signature: part.signature
                }
              }
            });
            break;
          }
          case "redacted_thinking": {
            content.push({
              type: "reasoning",
              text: "",
              providerMetadata: {
                anthropic: {
                  redactedData: part.data
                }
              }
            });
            break;
          }
          case "tool_use": {
            content.push(
              // when a json response tool is used, the tool call becomes the text:
              usesJsonResponseTool ? {
                type: "text",
                text: JSON.stringify(part.input)
              } : {
                type: "tool-call",
                toolCallId: part.id,
                toolName: part.name,
                input: JSON.stringify(part.input)
              }
            );
            break;
          }
          case "server_tool_use": {
            if (part.name === "web_search" || part.name === "code_execution") {
              content.push({
                type: "tool-call",
                toolCallId: part.id,
                toolName: part.name,
                input: JSON.stringify(part.input),
                providerExecuted: true
              });
            }
            break;
          }
          case "web_search_tool_result": {
            if (Array.isArray(part.content)) {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "web_search",
                result: part.content.map((result) => {
                  var _a2;
                  return {
                    url: result.url,
                    title: result.title,
                    pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                    encryptedContent: result.encrypted_content,
                    type: result.type
                  };
                }),
                providerExecuted: true
              });
              for (const result of part.content) {
                content.push({
                  type: "source",
                  sourceType: "url",
                  id: this.generateId(),
                  url: result.url,
                  title: result.title,
                  providerMetadata: {
                    anthropic: {
                      pageAge: (_a = result.page_age) != null ? _a : null
                    }
                  }
                });
              }
            } else {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "web_search",
                isError: true,
                result: {
                  type: "web_search_tool_result_error",
                  errorCode: part.content.error_code
                },
                providerExecuted: true
              });
            }
            break;
          }
          case "code_execution_tool_result": {
            if (part.content.type === "code_execution_result") {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "code_execution",
                result: {
                  type: part.content.type,
                  stdout: part.content.stdout,
                  stderr: part.content.stderr,
                  return_code: part.content.return_code
                },
                providerExecuted: true
              });
            } else if (part.content.type === "code_execution_tool_result_error") {
              content.push({
                type: "tool-result",
                toolCallId: part.tool_use_id,
                toolName: "code_execution",
                isError: true,
                result: {
                  type: "code_execution_tool_result_error",
                  errorCode: part.content.error_code
                },
                providerExecuted: true
              });
            }
            break;
          }
        }
      }
      return {
        content,
        finishReason: mapAnthropicStopReason({
          finishReason: response.stop_reason,
          isJsonResponseFromTool: usesJsonResponseTool
        }),
        usage: {
          inputTokens: response.usage.input_tokens,
          outputTokens: response.usage.output_tokens,
          totalTokens: response.usage.input_tokens + response.usage.output_tokens,
          cachedInputTokens: (_b = response.usage.cache_read_input_tokens) != null ? _b : void 0
        },
        request: { body: args },
        response: {
          id: (_c = response.id) != null ? _c : void 0,
          modelId: (_d = response.model) != null ? _d : void 0,
          headers: responseHeaders,
          body: rawResponse
        },
        warnings,
        providerMetadata: {
          anthropic: {
            usage: response.usage,
            cacheCreationInputTokens: (_e = response.usage.cache_creation_input_tokens) != null ? _e : null
          }
        }
      };
    }
    async doStream(options) {
      const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
      const citationDocuments = this.extractCitationDocuments(options.prompt);
      const body = { ...args, stream: true };
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: this.buildRequestUrl(true),
        headers: await this.getHeaders({ betas, headers: options.headers }),
        body: this.transformRequestBody(body),
        failedResponseHandler: anthropicFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(
          anthropicMessagesChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      const contentBlocks = {};
      let providerMetadata = void 0;
      let blockType = void 0;
      const generateId3 = this.generateId;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a, _b, _c, _d, _e, _f, _g;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              switch (value.type) {
                case "ping": {
                  return;
                }
                case "content_block_start": {
                  const contentBlockType = value.content_block.type;
                  blockType = contentBlockType;
                  switch (contentBlockType) {
                    case "text": {
                      contentBlocks[value.index] = { type: "text" };
                      controller.enqueue({
                        type: "text-start",
                        id: String(value.index)
                      });
                      return;
                    }
                    case "thinking": {
                      contentBlocks[value.index] = { type: "reasoning" };
                      controller.enqueue({
                        type: "reasoning-start",
                        id: String(value.index)
                      });
                      return;
                    }
                    case "redacted_thinking": {
                      contentBlocks[value.index] = { type: "reasoning" };
                      controller.enqueue({
                        type: "reasoning-start",
                        id: String(value.index),
                        providerMetadata: {
                          anthropic: {
                            redactedData: value.content_block.data
                          }
                        }
                      });
                      return;
                    }
                    case "tool_use": {
                      contentBlocks[value.index] = usesJsonResponseTool ? { type: "text" } : {
                        type: "tool-call",
                        toolCallId: value.content_block.id,
                        toolName: value.content_block.name,
                        input: ""
                      };
                      controller.enqueue(
                        usesJsonResponseTool ? { type: "text-start", id: String(value.index) } : {
                          type: "tool-input-start",
                          id: value.content_block.id,
                          toolName: value.content_block.name
                        }
                      );
                      return;
                    }
                    case "server_tool_use": {
                      if (value.content_block.name === "web_search" || value.content_block.name === "code_execution") {
                        contentBlocks[value.index] = {
                          type: "tool-call",
                          toolCallId: value.content_block.id,
                          toolName: value.content_block.name,
                          input: "",
                          providerExecuted: true
                        };
                        controller.enqueue({
                          type: "tool-input-start",
                          id: value.content_block.id,
                          toolName: value.content_block.name,
                          providerExecuted: true
                        });
                      }
                      return;
                    }
                    case "web_search_tool_result": {
                      const part = value.content_block;
                      if (Array.isArray(part.content)) {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: "web_search",
                          result: part.content.map((result) => {
                            var _a2;
                            return {
                              url: result.url,
                              title: result.title,
                              pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                              encryptedContent: result.encrypted_content,
                              type: result.type
                            };
                          }),
                          providerExecuted: true
                        });
                        for (const result of part.content) {
                          controller.enqueue({
                            type: "source",
                            sourceType: "url",
                            id: generateId3(),
                            url: result.url,
                            title: result.title,
                            providerMetadata: {
                              anthropic: {
                                pageAge: (_a = result.page_age) != null ? _a : null
                              }
                            }
                          });
                        }
                      } else {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: "web_search",
                          isError: true,
                          result: {
                            type: "web_search_tool_result_error",
                            errorCode: part.content.error_code
                          },
                          providerExecuted: true
                        });
                      }
                      return;
                    }
                    case "code_execution_tool_result": {
                      const part = value.content_block;
                      if (part.content.type === "code_execution_result") {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: "code_execution",
                          result: {
                            type: part.content.type,
                            stdout: part.content.stdout,
                            stderr: part.content.stderr,
                            return_code: part.content.return_code
                          },
                          providerExecuted: true
                        });
                      } else if (part.content.type === "code_execution_tool_result_error") {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: part.tool_use_id,
                          toolName: "code_execution",
                          isError: true,
                          result: {
                            type: "code_execution_tool_result_error",
                            errorCode: part.content.error_code
                          },
                          providerExecuted: true
                        });
                      }
                      return;
                    }
                    default: {
                      const _exhaustiveCheck = contentBlockType;
                      throw new Error(
                        `Unsupported content block type: ${_exhaustiveCheck}`
                      );
                    }
                  }
                }
                case "content_block_stop": {
                  if (contentBlocks[value.index] != null) {
                    const contentBlock = contentBlocks[value.index];
                    switch (contentBlock.type) {
                      case "text": {
                        controller.enqueue({
                          type: "text-end",
                          id: String(value.index)
                        });
                        break;
                      }
                      case "reasoning": {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: String(value.index)
                        });
                        break;
                      }
                      case "tool-call":
                        if (!usesJsonResponseTool) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: contentBlock.toolCallId
                          });
                          controller.enqueue(contentBlock);
                        }
                        break;
                    }
                    delete contentBlocks[value.index];
                  }
                  blockType = void 0;
                  return;
                }
                case "content_block_delta": {
                  const deltaType = value.delta.type;
                  switch (deltaType) {
                    case "text_delta": {
                      if (usesJsonResponseTool) {
                        return;
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: String(value.index),
                        delta: value.delta.text
                      });
                      return;
                    }
                    case "thinking_delta": {
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: String(value.index),
                        delta: value.delta.thinking
                      });
                      return;
                    }
                    case "signature_delta": {
                      if (blockType === "thinking") {
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: String(value.index),
                          delta: "",
                          providerMetadata: {
                            anthropic: {
                              signature: value.delta.signature
                            }
                          }
                        });
                      }
                      return;
                    }
                    case "input_json_delta": {
                      const contentBlock = contentBlocks[value.index];
                      const delta = value.delta.partial_json;
                      if (usesJsonResponseTool) {
                        if ((contentBlock == null ? void 0 : contentBlock.type) !== "text") {
                          return;
                        }
                        controller.enqueue({
                          type: "text-delta",
                          id: String(value.index),
                          delta
                        });
                      } else {
                        if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call") {
                          return;
                        }
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: contentBlock.toolCallId,
                          delta
                        });
                        contentBlock.input += delta;
                      }
                      return;
                    }
                    case "citations_delta": {
                      const citation = value.delta.citation;
                      processCitation(
                        citation,
                        citationDocuments,
                        generateId3,
                        (source) => controller.enqueue(source)
                      );
                      return;
                    }
                    default: {
                      const _exhaustiveCheck = deltaType;
                      throw new Error(
                        `Unsupported delta type: ${_exhaustiveCheck}`
                      );
                    }
                  }
                }
                case "message_start": {
                  usage.inputTokens = value.message.usage.input_tokens;
                  usage.cachedInputTokens = (_b = value.message.usage.cache_read_input_tokens) != null ? _b : void 0;
                  providerMetadata = {
                    anthropic: {
                      usage: value.message.usage,
                      cacheCreationInputTokens: (_c = value.message.usage.cache_creation_input_tokens) != null ? _c : null
                    }
                  };
                  controller.enqueue({
                    type: "response-metadata",
                    id: (_d = value.message.id) != null ? _d : void 0,
                    modelId: (_e = value.message.model) != null ? _e : void 0
                  });
                  return;
                }
                case "message_delta": {
                  usage.outputTokens = value.usage.output_tokens;
                  usage.totalTokens = ((_f = usage.inputTokens) != null ? _f : 0) + ((_g = value.usage.output_tokens) != null ? _g : 0);
                  finishReason = mapAnthropicStopReason({
                    finishReason: value.delta.stop_reason,
                    isJsonResponseFromTool: usesJsonResponseTool
                  });
                  return;
                }
                case "message_stop": {
                  controller.enqueue({
                    type: "finish",
                    finishReason,
                    usage,
                    providerMetadata
                  });
                  return;
                }
                case "error": {
                  controller.enqueue({ type: "error", error: value.error });
                  return;
                }
                default: {
                  const _exhaustiveCheck = value;
                  throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                }
              }
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    }
  };
  var anthropicMessagesResponseSchema = object$1({
    type: literal("message"),
    id: string$1().nullish(),
    model: string$1().nullish(),
    content: array(
      discriminatedUnion("type", [
        object$1({
          type: literal("text"),
          text: string$1(),
          citations: array(citationSchema$1).optional()
        }),
        object$1({
          type: literal("thinking"),
          thinking: string$1(),
          signature: string$1()
        }),
        object$1({
          type: literal("redacted_thinking"),
          data: string$1()
        }),
        object$1({
          type: literal("tool_use"),
          id: string$1(),
          name: string$1(),
          input: unknown()
        }),
        object$1({
          type: literal("server_tool_use"),
          id: string$1(),
          name: string$1(),
          input: record(string$1(), unknown()).nullish()
        }),
        object$1({
          type: literal("web_search_tool_result"),
          tool_use_id: string$1(),
          content: union([
            array(
              object$1({
                type: literal("web_search_result"),
                url: string$1(),
                title: string$1(),
                encrypted_content: string$1(),
                page_age: string$1().nullish()
              })
            ),
            object$1({
              type: literal("web_search_tool_result_error"),
              error_code: string$1()
            })
          ])
        }),
        object$1({
          type: literal("code_execution_tool_result"),
          tool_use_id: string$1(),
          content: union([
            object$1({
              type: literal("code_execution_result"),
              stdout: string$1(),
              stderr: string$1(),
              return_code: number$1()
            }),
            object$1({
              type: literal("code_execution_tool_result_error"),
              error_code: string$1()
            })
          ])
        })
      ])
    ),
    stop_reason: string$1().nullish(),
    usage: looseObject({
      input_tokens: number$1(),
      output_tokens: number$1(),
      cache_creation_input_tokens: number$1().nullish(),
      cache_read_input_tokens: number$1().nullish()
    })
  });
  var anthropicMessagesChunkSchema = discriminatedUnion("type", [
    object$1({
      type: literal("message_start"),
      message: object$1({
        id: string$1().nullish(),
        model: string$1().nullish(),
        usage: looseObject({
          input_tokens: number$1(),
          output_tokens: number$1(),
          cache_creation_input_tokens: number$1().nullish(),
          cache_read_input_tokens: number$1().nullish()
        })
      })
    }),
    object$1({
      type: literal("content_block_start"),
      index: number$1(),
      content_block: discriminatedUnion("type", [
        object$1({
          type: literal("text"),
          text: string$1()
        }),
        object$1({
          type: literal("thinking"),
          thinking: string$1()
        }),
        object$1({
          type: literal("tool_use"),
          id: string$1(),
          name: string$1()
        }),
        object$1({
          type: literal("redacted_thinking"),
          data: string$1()
        }),
        object$1({
          type: literal("server_tool_use"),
          id: string$1(),
          name: string$1(),
          input: record(string$1(), unknown()).nullish()
        }),
        object$1({
          type: literal("web_search_tool_result"),
          tool_use_id: string$1(),
          content: union([
            array(
              object$1({
                type: literal("web_search_result"),
                url: string$1(),
                title: string$1(),
                encrypted_content: string$1(),
                page_age: string$1().nullish()
              })
            ),
            object$1({
              type: literal("web_search_tool_result_error"),
              error_code: string$1()
            })
          ])
        }),
        object$1({
          type: literal("code_execution_tool_result"),
          tool_use_id: string$1(),
          content: union([
            object$1({
              type: literal("code_execution_result"),
              stdout: string$1(),
              stderr: string$1(),
              return_code: number$1()
            }),
            object$1({
              type: literal("code_execution_tool_result_error"),
              error_code: string$1()
            })
          ])
        })
      ])
    }),
    object$1({
      type: literal("content_block_delta"),
      index: number$1(),
      delta: discriminatedUnion("type", [
        object$1({
          type: literal("input_json_delta"),
          partial_json: string$1()
        }),
        object$1({
          type: literal("text_delta"),
          text: string$1()
        }),
        object$1({
          type: literal("thinking_delta"),
          thinking: string$1()
        }),
        object$1({
          type: literal("signature_delta"),
          signature: string$1()
        }),
        object$1({
          type: literal("citations_delta"),
          citation: citationSchema$1
        })
      ])
    }),
    object$1({
      type: literal("content_block_stop"),
      index: number$1()
    }),
    object$1({
      type: literal("error"),
      error: object$1({
        type: string$1(),
        message: string$1()
      })
    }),
    object$1({
      type: literal("message_delta"),
      delta: object$1({ stop_reason: string$1().nullish() }),
      usage: object$1({ output_tokens: number$1() })
    }),
    object$1({
      type: literal("message_stop")
    }),
    object$1({
      type: literal("ping")
    })
  ]);
  var anthropicReasoningMetadataSchema = object$1({
    signature: string$1().optional(),
    redactedData: string$1().optional()
  });
  var bash_20241022 = createProviderDefinedToolFactory({
    id: "anthropic.bash_20241022",
    name: "bash",
    inputSchema: z.object({
      command: z.string(),
      restart: z.boolean().optional()
    })
  });
  var bash_20250124 = createProviderDefinedToolFactory({
    id: "anthropic.bash_20250124",
    name: "bash",
    inputSchema: z.object({
      command: z.string(),
      restart: z.boolean().optional()
    })
  });
  var computer_20241022 = createProviderDefinedToolFactory({
    id: "anthropic.computer_20241022",
    name: "computer",
    inputSchema: object$1({
      action: _enum([
        "key",
        "type",
        "mouse_move",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "screenshot",
        "cursor_position"
      ]),
      coordinate: array(number$1().int()).optional(),
      text: string$1().optional()
    })
  });
  var computer_20250124 = createProviderDefinedToolFactory({
    id: "anthropic.computer_20250124",
    name: "computer",
    inputSchema: object$1({
      action: _enum([
        "key",
        "hold_key",
        "type",
        "cursor_position",
        "mouse_move",
        "left_mouse_down",
        "left_mouse_up",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "triple_click",
        "scroll",
        "wait",
        "screenshot"
      ]),
      coordinate: tuple([number$1().int(), number$1().int()]).optional(),
      duration: number$1().optional(),
      scroll_amount: number$1().optional(),
      scroll_direction: _enum(["up", "down", "left", "right"]).optional(),
      start_coordinate: tuple([number$1().int(), number$1().int()]).optional(),
      text: string$1().optional()
    })
  });
  var textEditor_20241022 = createProviderDefinedToolFactory({
    id: "anthropic.text_editor_20241022",
    name: "str_replace_editor",
    inputSchema: object$1({
      command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: string$1(),
      file_text: string$1().optional(),
      insert_line: number$1().int().optional(),
      new_str: string$1().optional(),
      old_str: string$1().optional(),
      view_range: array(number$1().int()).optional()
    })
  });
  var textEditor_20250124 = createProviderDefinedToolFactory({
    id: "anthropic.text_editor_20250124",
    name: "str_replace_editor",
    inputSchema: object$1({
      command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: string$1(),
      file_text: string$1().optional(),
      insert_line: number$1().int().optional(),
      new_str: string$1().optional(),
      old_str: string$1().optional(),
      view_range: array(number$1().int()).optional()
    })
  });
  var textEditor_20250429 = createProviderDefinedToolFactory({
    id: "anthropic.text_editor_20250429",
    name: "str_replace_based_edit_tool",
    inputSchema: object$1({
      command: _enum(["view", "create", "str_replace", "insert"]),
      path: string$1(),
      file_text: string$1().optional(),
      insert_line: number$1().int().optional(),
      new_str: string$1().optional(),
      old_str: string$1().optional(),
      view_range: array(number$1().int()).optional()
    })
  });

  // src/anthropic-tools.ts
  var anthropicTools = {
    /**
     * Creates a tool for running a bash command. Must have name "bash".
     *
     * Image results are supported.
     *
     * @param execute - The function to execute the tool. Optional.
     */
    bash_20241022,
    /**
     * Creates a tool for running a bash command. Must have name "bash".
     *
     * Image results are supported.
     *
     * @param execute - The function to execute the tool. Optional.
     */
    bash_20250124,
    /**
     * Creates a tool for editing text. Must have name "str_replace_editor".
     */
    textEditor_20241022,
    /**
     * Creates a tool for editing text. Must have name "str_replace_editor".
     */
    textEditor_20250124,
    /**
     * Creates a tool for editing text. Must have name "str_replace_based_edit_tool".
     * Note: This version does not support the "undo_edit" command.
     */
    textEditor_20250429,
    /**
     * Creates a tool for executing actions on a computer. Must have name "computer".
     *
     * Image results are supported.
     *
     * @param displayWidthPx - The width of the display being controlled by the model in pixels.
     * @param displayHeightPx - The height of the display being controlled by the model in pixels.
     * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
     */
    computer_20241022,
    /**
     * Creates a tool for executing actions on a computer. Must have name "computer".
     *
     * Image results are supported.
     *
     * @param displayWidthPx - The width of the display being controlled by the model in pixels.
     * @param displayHeightPx - The height of the display being controlled by the model in pixels.
     * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
     * @param execute - The function to execute the tool. Optional.
     */
    computer_20250124,
    /**
     * Creates a web search tool that gives Claude direct access to real-time web content.
     * Must have name "web_search".
     *
     * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
     * @param allowedDomains - Optional list of domains that Claude is allowed to search.
     * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
     * @param userLocation - Optional user location information to provide geographically relevant search results.
     */
    webSearch_20250305,
    /**
     * Creates a tool for executing Python code. Must have name "code_execution".
     */
    codeExecution_20250522
  };

  // src/anthropic-provider.ts
  function createAnthropic(options = {}) {
    var _a;
    const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://api.anthropic.com/v1";
    const getHeaders = () => ({
      "anthropic-version": "2023-06-01",
      "x-api-key": loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "ANTHROPIC_API_KEY",
        description: "Anthropic"
      }),
      ...options.headers
    });
    const createChatModel = (modelId) => {
      var _a2;
      return new AnthropicMessagesLanguageModel(modelId, {
        provider: "anthropic.messages",
        baseURL,
        headers: getHeaders,
        fetch: options.fetch,
        generateId: (_a2 = options.generateId) != null ? _a2 : generateId$1,
        supportedUrls: () => ({
          "image/*": [/^https?:\/\/.*$/]
        })
      });
    };
    const provider = function(modelId) {
      if (new.target) {
        throw new Error(
          "The Anthropic model function cannot be called with the new keyword."
        );
      }
      return createChatModel(modelId);
    };
    provider.languageModel = createChatModel;
    provider.chat = createChatModel;
    provider.messages = createChatModel;
    provider.textEmbeddingModel = (modelId) => {
      throw new NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
    };
    provider.imageModel = (modelId) => {
      throw new NoSuchModelError({ modelId, modelType: "imageModel" });
    };
    provider.tools = anthropicTools;
    return provider;
  }
  createAnthropic();

  // src/chat/openai-compatible-chat-language-model.ts
  object$1({
    /**
     * A unique identifier representing your end-user, which can help the provider to
     * monitor and detect abuse.
     */
    user: string$1().optional(),
    /**
     * Reasoning effort for reasoning models. Defaults to `medium`.
     */
    reasoningEffort: string$1().optional()
  });
  var openaiCompatibleErrorDataSchema = object$1({
    error: object$1({
      message: string$1(),
      // The additional information below is handled loosely to support
      // OpenAI-compatible providers that have slightly different error
      // responses:
      type: string$1().nullish(),
      param: any().nullish(),
      code: union([string$1(), number$1()]).nullish()
    })
  });
  var defaultOpenAICompatibleErrorStructure = {
    errorSchema: openaiCompatibleErrorDataSchema,
    errorToMessage: (data) => data.error.message
  };
  var openaiCompatibleTokenUsageSchema = object$1({
    prompt_tokens: number$1().nullish(),
    completion_tokens: number$1().nullish(),
    total_tokens: number$1().nullish(),
    prompt_tokens_details: object$1({
      cached_tokens: number$1().nullish()
    }).nullish(),
    completion_tokens_details: object$1({
      reasoning_tokens: number$1().nullish(),
      accepted_prediction_tokens: number$1().nullish(),
      rejected_prediction_tokens: number$1().nullish()
    }).nullish()
  }).nullish();
  object$1({
    id: string$1().nullish(),
    created: number$1().nullish(),
    model: string$1().nullish(),
    choices: array(
      object$1({
        message: object$1({
          role: literal("assistant").nullish(),
          content: string$1().nullish(),
          reasoning_content: string$1().nullish(),
          reasoning: string$1().nullish(),
          tool_calls: array(
            object$1({
              id: string$1().nullish(),
              function: object$1({
                name: string$1(),
                arguments: string$1()
              })
            })
          ).nullish()
        }),
        finish_reason: string$1().nullish()
      })
    ),
    usage: openaiCompatibleTokenUsageSchema
  });
  object$1({
    /**
     * Echo back the prompt in addition to the completion.
     */
    echo: boolean$1().optional(),
    /**
     * Modify the likelihood of specified tokens appearing in the completion.
     *
     * Accepts a JSON object that maps tokens (specified by their token ID in
     * the GPT tokenizer) to an associated bias value from -100 to 100.
     */
    logitBias: record(string$1(), number$1()).optional(),
    /**
     * The suffix that comes after a completion of inserted text.
     */
    suffix: string$1().optional(),
    /**
     * A unique identifier representing your end-user, which can help providers to
     * monitor and detect abuse.
     */
    user: string$1().optional()
  });
  var usageSchema = object$1({
    prompt_tokens: number$1(),
    completion_tokens: number$1(),
    total_tokens: number$1()
  });
  object$1({
    id: string$1().nullish(),
    created: number$1().nullish(),
    model: string$1().nullish(),
    choices: array(
      object$1({
        text: string$1(),
        finish_reason: string$1()
      })
    ),
    usage: usageSchema.nullish()
  });
  object$1({
    /**
     * The number of dimensions the resulting output embeddings should have.
     * Only supported in text-embedding-3 and later models.
     */
    dimensions: number$1().optional(),
    /**
     * A unique identifier representing your end-user, which can help providers to
     * monitor and detect abuse.
     */
    user: string$1().optional()
  });
  object$1({
    data: array(object$1({ embedding: array(number$1()) })),
    usage: object$1({ prompt_tokens: number$1() }).nullish(),
    providerMetadata: record(string$1(), record(string$1(), any())).optional()
  });
  var OpenAICompatibleImageModel = class {
    constructor(modelId, config) {
      this.modelId = modelId;
      this.config = config;
      this.specificationVersion = "v2";
      this.maxImagesPerCall = 10;
    }
    get provider() {
      return this.config.provider;
    }
    async doGenerate({
      prompt,
      n,
      size,
      aspectRatio,
      seed,
      providerOptions,
      headers,
      abortSignal
    }) {
      var _a, _b, _c, _d, _e;
      const warnings = [];
      if (aspectRatio != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "aspectRatio",
          details: "This model does not support aspect ratio. Use `size` instead."
        });
      }
      if (seed != null) {
        warnings.push({ type: "unsupported-setting", setting: "seed" });
      }
      const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
      const { value: response, responseHeaders } = await postJsonToApi$1({
        url: this.config.url({
          path: "/images/generations",
          modelId: this.modelId
        }),
        headers: combineHeaders$1(this.config.headers(), headers),
        body: {
          model: this.modelId,
          prompt,
          n,
          size,
          ...(_d = providerOptions.openai) != null ? _d : {},
          response_format: "b64_json"
        },
        failedResponseHandler: createJsonErrorResponseHandler$1(
          (_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure
        ),
        successfulResponseHandler: createJsonResponseHandler$1(
          openaiCompatibleImageResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response.data.map((item) => item.b64_json),
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    }
  };
  var openaiCompatibleImageResponseSchema = object$1({
    data: array(object$1({ b64_json: string$1() }))
  });

  // src/xai-provider.ts
  function convertToXaiChatMessages(prompt) {
    const messages = [];
    const warnings = [];
    for (const { role, content } of prompt) {
      switch (role) {
        case "system": {
          messages.push({ role: "system", content });
          break;
        }
        case "user": {
          if (content.length === 1 && content[0].type === "text") {
            messages.push({ role: "user", content: content[0].text });
            break;
          }
          messages.push({
            role: "user",
            content: content.map((part) => {
              switch (part.type) {
                case "text": {
                  return { type: "text", text: part.text };
                }
                case "file": {
                  if (part.mediaType.startsWith("image/")) {
                    const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                    return {
                      type: "image_url",
                      image_url: {
                        url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                      }
                    };
                  } else {
                    throw new UnsupportedFunctionalityError$1({
                      functionality: `file part media type ${part.mediaType}`
                    });
                  }
                }
              }
            })
          });
          break;
        }
        case "assistant": {
          let text = "";
          const toolCalls = [];
          for (const part of content) {
            switch (part.type) {
              case "text": {
                text += part.text;
                break;
              }
              case "tool-call": {
                toolCalls.push({
                  id: part.toolCallId,
                  type: "function",
                  function: {
                    name: part.toolName,
                    arguments: JSON.stringify(part.input)
                  }
                });
                break;
              }
            }
          }
          messages.push({
            role: "assistant",
            content: text,
            tool_calls: toolCalls.length > 0 ? toolCalls : void 0
          });
          break;
        }
        case "tool": {
          for (const toolResponse of content) {
            const output = toolResponse.output;
            let contentValue;
            switch (output.type) {
              case "text":
              case "error-text":
                contentValue = output.value;
                break;
              case "content":
              case "json":
              case "error-json":
                contentValue = JSON.stringify(output.value);
                break;
            }
            messages.push({
              role: "tool",
              tool_call_id: toolResponse.toolCallId,
              content: contentValue
            });
          }
          break;
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return { messages, warnings };
  }

  // src/get-response-metadata.ts
  function getResponseMetadata$1({
    id,
    model,
    created
  }) {
    return {
      id: id != null ? id : void 0,
      modelId: model != null ? model : void 0,
      timestamp: created != null ? new Date(created * 1e3) : void 0
    };
  }

  // src/map-xai-finish-reason.ts
  function mapXaiFinishReason(finishReason) {
    switch (finishReason) {
      case "stop":
        return "stop";
      case "length":
        return "length";
      case "tool_calls":
      case "function_call":
        return "tool-calls";
      case "content_filter":
        return "content-filter";
      default:
        return "unknown";
    }
  }
  var webSourceSchema = object$1({
    type: literal("web"),
    country: string$1().length(2).optional(),
    excludedWebsites: array(string$1()).max(5).optional(),
    allowedWebsites: array(string$1()).max(5).optional(),
    safeSearch: boolean$1().optional()
  });
  var xSourceSchema = object$1({
    type: literal("x"),
    xHandles: array(string$1()).optional()
  });
  var newsSourceSchema = object$1({
    type: literal("news"),
    country: string$1().length(2).optional(),
    excludedWebsites: array(string$1()).max(5).optional(),
    safeSearch: boolean$1().optional()
  });
  var rssSourceSchema = object$1({
    type: literal("rss"),
    links: array(string$1().url()).max(1)
    // currently only supports one RSS link
  });
  var searchSourceSchema = discriminatedUnion("type", [
    webSourceSchema,
    xSourceSchema,
    newsSourceSchema,
    rssSourceSchema
  ]);
  var xaiProviderOptions = object$1({
    /**
     * reasoning effort for reasoning models
     * only supported by grok-3-mini and grok-3-mini-fast models
     */
    reasoningEffort: _enum(["low", "high"]).optional(),
    searchParameters: object$1({
      /**
       * search mode preference
       * - "off": disables search completely
       * - "auto": model decides whether to search (default)
       * - "on": always enables search
       */
      mode: _enum(["off", "auto", "on"]),
      /**
       * whether to return citations in the response
       * defaults to true
       */
      returnCitations: boolean$1().optional(),
      /**
       * start date for search data (ISO8601 format: YYYY-MM-DD)
       */
      fromDate: string$1().optional(),
      /**
       * end date for search data (ISO8601 format: YYYY-MM-DD)
       */
      toDate: string$1().optional(),
      /**
       * maximum number of search results to consider
       * defaults to 20
       */
      maxSearchResults: number$1().min(1).max(50).optional(),
      /**
       * data sources to search from
       * defaults to ["web", "x"] if not specified
       */
      sources: array(searchSourceSchema).optional()
    }).optional()
  });
  var xaiErrorDataSchema = object$1({
    error: object$1({
      message: string$1(),
      type: string$1().nullish(),
      param: any().nullish(),
      code: union([string$1(), number$1()]).nullish()
    })
  });
  var xaiFailedResponseHandler = createJsonErrorResponseHandler$1({
    errorSchema: xaiErrorDataSchema,
    errorToMessage: (data) => data.error.message
  });
  function prepareTools$1({
    tools,
    toolChoice
  }) {
    tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
    const toolWarnings = [];
    if (tools == null) {
      return { tools: void 0, toolChoice: void 0, toolWarnings };
    }
    const xaiTools = [];
    for (const tool of tools) {
      if (tool.type === "provider-defined") {
        toolWarnings.push({ type: "unsupported-tool", tool });
      } else {
        xaiTools.push({
          type: "function",
          function: {
            name: tool.name,
            description: tool.description,
            parameters: tool.inputSchema
          }
        });
      }
    }
    if (toolChoice == null) {
      return { tools: xaiTools, toolChoice: void 0, toolWarnings };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto":
      case "none":
        return { tools: xaiTools, toolChoice: type, toolWarnings };
      case "required":
        return { tools: xaiTools, toolChoice: "required", toolWarnings };
      case "tool":
        return {
          tools: xaiTools,
          toolChoice: {
            type: "function",
            function: { name: toolChoice.toolName }
          },
          toolWarnings
        };
      default: {
        const _exhaustiveCheck = type;
        throw new UnsupportedFunctionalityError$1({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }

  // src/xai-chat-language-model.ts
  var XaiChatLanguageModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.supportedUrls = {
        "image/*": [/^https?:\/\/.*$/]
      };
      this.modelId = modelId;
      this.config = config;
    }
    get provider() {
      return this.config.provider;
    }
    async getArgs({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      seed,
      responseFormat,
      providerOptions,
      tools,
      toolChoice
    }) {
      var _a, _b, _c;
      const warnings = [];
      const options = (_a = await parseProviderOptions({
        provider: "xai",
        providerOptions,
        schema: xaiProviderOptions
      })) != null ? _a : {};
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if (frequencyPenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty"
        });
      }
      if (presencePenalty != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty"
        });
      }
      if (stopSequences != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "stopSequences"
        });
      }
      if (responseFormat != null && responseFormat.type === "json" && responseFormat.schema != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format schema is not supported"
        });
      }
      const { messages, warnings: messageWarnings } = convertToXaiChatMessages(prompt);
      warnings.push(...messageWarnings);
      const {
        tools: xaiTools,
        toolChoice: xaiToolChoice,
        toolWarnings
      } = prepareTools$1({
        tools,
        toolChoice
      });
      warnings.push(...toolWarnings);
      const baseArgs = {
        // model id
        model: this.modelId,
        // standard generation settings
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        seed,
        reasoning_effort: options.reasoningEffort,
        // response format
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            name: (_b = responseFormat.name) != null ? _b : "response",
            schema: responseFormat.schema,
            strict: true
          }
        } : { type: "json_object" } : void 0,
        // search parameters
        search_parameters: options.searchParameters ? {
          mode: options.searchParameters.mode,
          return_citations: options.searchParameters.returnCitations,
          from_date: options.searchParameters.fromDate,
          to_date: options.searchParameters.toDate,
          max_search_results: options.searchParameters.maxSearchResults,
          sources: (_c = options.searchParameters.sources) == null ? void 0 : _c.map((source) => ({
            type: source.type,
            ...source.type === "web" && {
              country: source.country,
              excluded_websites: source.excludedWebsites,
              allowed_websites: source.allowedWebsites,
              safe_search: source.safeSearch
            },
            ...source.type === "x" && {
              x_handles: source.xHandles
            },
            ...source.type === "news" && {
              country: source.country,
              excluded_websites: source.excludedWebsites,
              safe_search: source.safeSearch
            },
            ...source.type === "rss" && {
              links: source.links
            }
          }))
        } : void 0,
        // messages in xai format
        messages,
        // tools in xai format
        tools: xaiTools,
        tool_choice: xaiToolChoice
      };
      return {
        args: baseArgs,
        warnings
      };
    }
    async doGenerate(options) {
      var _a, _b, _c;
      const { args: body, warnings } = await this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url: `${(_a = this.config.baseURL) != null ? _a : "https://api.x.ai/v1"}/chat/completions`,
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: xaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          xaiChatResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      if (choice.message.content != null && choice.message.content.length > 0) {
        let text = choice.message.content;
        const lastMessage = body.messages[body.messages.length - 1];
        if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && text === lastMessage.content) {
          text = "";
        }
        if (text.length > 0) {
          content.push({ type: "text", text });
        }
      }
      if (choice.message.reasoning_content != null && choice.message.reasoning_content.length > 0) {
        content.push({
          type: "reasoning",
          text: choice.message.reasoning_content
        });
      }
      if (choice.message.tool_calls != null) {
        for (const toolCall of choice.message.tool_calls) {
          content.push({
            type: "tool-call",
            toolCallId: toolCall.id,
            toolName: toolCall.function.name,
            input: toolCall.function.arguments
          });
        }
      }
      if (response.citations != null) {
        for (const url of response.citations) {
          content.push({
            type: "source",
            sourceType: "url",
            id: this.config.generateId(),
            url
          });
        }
      }
      return {
        content,
        finishReason: mapXaiFinishReason(choice.finish_reason),
        usage: {
          inputTokens: response.usage.prompt_tokens,
          outputTokens: response.usage.completion_tokens,
          totalTokens: response.usage.total_tokens,
          reasoningTokens: (_c = (_b = response.usage.completion_tokens_details) == null ? void 0 : _b.reasoning_tokens) != null ? _c : void 0
        },
        request: { body },
        response: {
          ...getResponseMetadata$1(response),
          headers: responseHeaders,
          body: rawResponse
        },
        warnings
      };
    }
    async doStream(options) {
      var _a;
      const { args, warnings } = await this.getArgs(options);
      const body = {
        ...args,
        stream: true,
        stream_options: {
          include_usage: true
        }
      };
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: `${(_a = this.config.baseURL) != null ? _a : "https://api.x.ai/v1"}/chat/completions`,
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: xaiFailedResponseHandler,
        successfulResponseHandler: createEventSourceResponseHandler(xaiChatChunkSchema),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      let isFirstChunk = true;
      const contentBlocks = {};
      const lastReasoningDeltas = {};
      const self = this;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a2, _b;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isFirstChunk) {
                controller.enqueue({
                  type: "response-metadata",
                  ...getResponseMetadata$1(value)
                });
                isFirstChunk = false;
              }
              if (value.citations != null) {
                for (const url of value.citations) {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: self.config.generateId(),
                    url
                  });
                }
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                usage.totalTokens = value.usage.total_tokens;
                usage.reasoningTokens = (_b = (_a2 = value.usage.completion_tokens_details) == null ? void 0 : _a2.reasoning_tokens) != null ? _b : void 0;
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapXaiFinishReason(choice.finish_reason);
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              const choiceIndex = choice.index;
              if (delta.content != null && delta.content.length > 0) {
                const textContent = delta.content;
                const lastMessage = body.messages[body.messages.length - 1];
                if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && textContent === lastMessage.content) {
                  return;
                }
                const blockId = `text-${value.id || choiceIndex}`;
                if (contentBlocks[blockId] == null) {
                  contentBlocks[blockId] = { type: "text" };
                  controller.enqueue({
                    type: "text-start",
                    id: blockId
                  });
                }
                controller.enqueue({
                  type: "text-delta",
                  id: blockId,
                  delta: textContent
                });
              }
              if (delta.reasoning_content != null && delta.reasoning_content.length > 0) {
                const blockId = `reasoning-${value.id || choiceIndex}`;
                if (lastReasoningDeltas[blockId] === delta.reasoning_content) {
                  return;
                }
                lastReasoningDeltas[blockId] = delta.reasoning_content;
                if (contentBlocks[blockId] == null) {
                  contentBlocks[blockId] = { type: "reasoning" };
                  controller.enqueue({
                    type: "reasoning-start",
                    id: blockId
                  });
                }
                controller.enqueue({
                  type: "reasoning-delta",
                  id: blockId,
                  delta: delta.reasoning_content
                });
              }
              if (delta.tool_calls != null) {
                for (const toolCall of delta.tool_calls) {
                  const toolCallId = toolCall.id;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCallId,
                    toolName: toolCall.function.name
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCallId,
                    delta: toolCall.function.arguments
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCallId
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId,
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                }
              }
            },
            flush(controller) {
              for (const [blockId, block] of Object.entries(contentBlocks)) {
                controller.enqueue({
                  type: block.type === "text" ? "text-end" : "reasoning-end",
                  id: blockId
                });
              }
              controller.enqueue({ type: "finish", finishReason, usage });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    }
  };
  var xaiUsageSchema = object$1({
    prompt_tokens: number$1(),
    completion_tokens: number$1(),
    total_tokens: number$1(),
    completion_tokens_details: object$1({
      reasoning_tokens: number$1().nullish()
    }).nullish()
  });
  var xaiChatResponseSchema = object$1({
    id: string$1().nullish(),
    created: number$1().nullish(),
    model: string$1().nullish(),
    choices: array(
      object$1({
        message: object$1({
          role: literal("assistant"),
          content: string$1().nullish(),
          reasoning_content: string$1().nullish(),
          tool_calls: array(
            object$1({
              id: string$1(),
              type: literal("function"),
              function: object$1({
                name: string$1(),
                arguments: string$1()
              })
            })
          ).nullish()
        }),
        index: number$1(),
        finish_reason: string$1().nullish()
      })
    ),
    object: literal("chat.completion"),
    usage: xaiUsageSchema,
    citations: array(string$1().url()).nullish()
  });
  var xaiChatChunkSchema = object$1({
    id: string$1().nullish(),
    created: number$1().nullish(),
    model: string$1().nullish(),
    choices: array(
      object$1({
        delta: object$1({
          role: _enum(["assistant"]).optional(),
          content: string$1().nullish(),
          reasoning_content: string$1().nullish(),
          tool_calls: array(
            object$1({
              id: string$1(),
              type: literal("function"),
              function: object$1({
                name: string$1(),
                arguments: string$1()
              })
            })
          ).nullish()
        }),
        finish_reason: string$1().nullish(),
        index: number$1()
      })
    ),
    usage: xaiUsageSchema.nullish(),
    citations: array(string$1().url()).nullish()
  });

  // src/xai-provider.ts
  var xaiErrorStructure = {
    errorSchema: xaiErrorDataSchema,
    errorToMessage: (data) => data.error.message
  };
  function createXai(options = {}) {
    var _a;
    const baseURL = withoutTrailingSlash$1(
      (_a = options.baseURL) != null ? _a : "https://api.x.ai/v1"
    );
    const getHeaders = () => ({
      Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "XAI_API_KEY",
      description: "xAI API key"
    })}`,
      ...options.headers
    });
    const createLanguageModel = (modelId) => {
      return new XaiChatLanguageModel(modelId, {
        provider: "xai.chat",
        baseURL,
        headers: getHeaders,
        generateId: generateId$1,
        fetch: options.fetch
      });
    };
    const createImageModel = (modelId) => {
      return new OpenAICompatibleImageModel(modelId, {
        provider: "xai.image",
        url: ({ path }) => `${baseURL}${path}`,
        headers: getHeaders,
        fetch: options.fetch,
        errorStructure: xaiErrorStructure
      });
    };
    const provider = (modelId) => createLanguageModel(modelId);
    provider.languageModel = createLanguageModel;
    provider.chat = createLanguageModel;
    provider.textEmbeddingModel = (modelId) => {
      throw new NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
    };
    provider.imageModel = createImageModel;
    provider.image = createImageModel;
    return provider;
  }
  var xai = createXai();

  // src/perplexity-provider.ts
  function convertToPerplexityMessages(prompt) {
    const messages = [];
    for (const { role, content } of prompt) {
      switch (role) {
        case "system": {
          messages.push({ role: "system", content });
          break;
        }
        case "user":
        case "assistant": {
          const hasImage = content.some(
            (part) => part.type === "file" && part.mediaType.startsWith("image/")
          );
          const messageContent = content.map((part) => {
            var _a;
            switch (part.type) {
              case "text": {
                return {
                  type: "text",
                  text: part.text
                };
              }
              case "file": {
                return part.data instanceof URL ? {
                  type: "image_url",
                  image_url: {
                    url: part.data.toString()
                  }
                } : {
                  type: "image_url",
                  image_url: {
                    url: `data:${(_a = part.mediaType) != null ? _a : "image/jpeg"};base64,${typeof part.data === "string" ? part.data : convertUint8ArrayToBase64$1(part.data)}`
                  }
                };
              }
            }
          }).filter(Boolean);
          messages.push({
            role,
            content: hasImage ? messageContent : messageContent.filter((part) => part.type === "text").map((part) => part.text).join("")
          });
          break;
        }
        case "tool": {
          throw new UnsupportedFunctionalityError$1({
            functionality: "Tool messages"
          });
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return messages;
  }

  // src/map-perplexity-finish-reason.ts
  function mapPerplexityFinishReason(finishReason) {
    switch (finishReason) {
      case "stop":
      case "length":
        return finishReason;
      default:
        return "unknown";
    }
  }

  // src/perplexity-language-model.ts
  var PerplexityLanguageModel = class {
    constructor(modelId, config) {
      this.specificationVersion = "v2";
      this.provider = "perplexity";
      this.supportedUrls = {
        // No URLs are supported.
      };
      this.modelId = modelId;
      this.config = config;
    }
    getArgs({
      prompt,
      maxOutputTokens,
      temperature,
      topP,
      topK,
      frequencyPenalty,
      presencePenalty,
      stopSequences,
      responseFormat,
      seed,
      providerOptions
    }) {
      var _a;
      const warnings = [];
      if (topK != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "topK"
        });
      }
      if (stopSequences != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "stopSequences"
        });
      }
      if (seed != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "seed"
        });
      }
      return {
        args: {
          // model id:
          model: this.modelId,
          // standardized settings:
          frequency_penalty: frequencyPenalty,
          max_tokens: maxOutputTokens,
          presence_penalty: presencePenalty,
          temperature,
          top_k: topK,
          top_p: topP,
          // response format:
          response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? {
            type: "json_schema",
            json_schema: { schema: responseFormat.schema }
          } : void 0,
          // provider extensions
          ...(_a = providerOptions == null ? void 0 : providerOptions.perplexity) != null ? _a : {},
          // messages:
          messages: convertToPerplexityMessages(prompt)
        },
        warnings
      };
    }
    async doGenerate(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      const { args: body, warnings } = this.getArgs(options);
      const {
        responseHeaders,
        value: response,
        rawValue: rawResponse
      } = await postJsonToApi$1({
        url: `${this.config.baseURL}/chat/completions`,
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: createJsonErrorResponseHandler$1({
          errorSchema: perplexityErrorSchema,
          errorToMessage
        }),
        successfulResponseHandler: createJsonResponseHandler$1(
          perplexityResponseSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      const choice = response.choices[0];
      const content = [];
      const text = choice.message.content;
      if (text.length > 0) {
        content.push({ type: "text", text });
      }
      if (response.citations != null) {
        for (const url of response.citations) {
          content.push({
            type: "source",
            sourceType: "url",
            id: this.config.generateId(),
            url
          });
        }
      }
      return {
        content,
        finishReason: mapPerplexityFinishReason(choice.finish_reason),
        usage: {
          inputTokens: (_a = response.usage) == null ? void 0 : _a.prompt_tokens,
          outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
          totalTokens: (_d = (_c = response.usage) == null ? void 0 : _c.total_tokens) != null ? _d : void 0
        },
        request: { body },
        response: {
          ...getResponseMetadata(response),
          headers: responseHeaders,
          body: rawResponse
        },
        warnings,
        providerMetadata: {
          perplexity: {
            images: (_f = (_e = response.images) == null ? void 0 : _e.map((image) => ({
              imageUrl: image.image_url,
              originUrl: image.origin_url,
              height: image.height,
              width: image.width
            }))) != null ? _f : null,
            usage: {
              citationTokens: (_h = (_g = response.usage) == null ? void 0 : _g.citation_tokens) != null ? _h : null,
              numSearchQueries: (_j = (_i = response.usage) == null ? void 0 : _i.num_search_queries) != null ? _j : null
            }
          }
        }
      };
    }
    async doStream(options) {
      const { args, warnings } = this.getArgs(options);
      const body = { ...args, stream: true };
      const { responseHeaders, value: response } = await postJsonToApi$1({
        url: `${this.config.baseURL}/chat/completions`,
        headers: combineHeaders$1(this.config.headers(), options.headers),
        body,
        failedResponseHandler: createJsonErrorResponseHandler$1({
          errorSchema: perplexityErrorSchema,
          errorToMessage
        }),
        successfulResponseHandler: createEventSourceResponseHandler(
          perplexityChunkSchema
        ),
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      let finishReason = "unknown";
      const usage = {
        inputTokens: void 0,
        outputTokens: void 0,
        totalTokens: void 0
      };
      const providerMetadata = {
        perplexity: {
          usage: {
            citationTokens: null,
            numSearchQueries: null
          },
          images: null
        }
      };
      let isFirstChunk = true;
      let isActive = false;
      const self = this;
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              controller.enqueue({ type: "stream-start", warnings });
            },
            transform(chunk, controller) {
              var _a, _b, _c;
              if (options.includeRawChunks) {
                controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
              }
              if (!chunk.success) {
                controller.enqueue({ type: "error", error: chunk.error });
                return;
              }
              const value = chunk.value;
              if (isFirstChunk) {
                controller.enqueue({
                  type: "response-metadata",
                  ...getResponseMetadata(value)
                });
                (_a = value.citations) == null ? void 0 : _a.forEach((url) => {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: self.config.generateId(),
                    url
                  });
                });
                isFirstChunk = false;
              }
              if (value.usage != null) {
                usage.inputTokens = value.usage.prompt_tokens;
                usage.outputTokens = value.usage.completion_tokens;
                providerMetadata.perplexity.usage = {
                  citationTokens: (_b = value.usage.citation_tokens) != null ? _b : null,
                  numSearchQueries: (_c = value.usage.num_search_queries) != null ? _c : null
                };
              }
              if (value.images != null) {
                providerMetadata.perplexity.images = value.images.map((image) => ({
                  imageUrl: image.image_url,
                  originUrl: image.origin_url,
                  height: image.height,
                  width: image.width
                }));
              }
              const choice = value.choices[0];
              if ((choice == null ? void 0 : choice.finish_reason) != null) {
                finishReason = mapPerplexityFinishReason(choice.finish_reason);
              }
              if ((choice == null ? void 0 : choice.delta) == null) {
                return;
              }
              const delta = choice.delta;
              const textContent = delta.content;
              if (textContent != null) {
                if (!isActive) {
                  controller.enqueue({ type: "text-start", id: "0" });
                  isActive = true;
                }
                controller.enqueue({
                  type: "text-delta",
                  id: "0",
                  delta: textContent
                });
              }
            },
            flush(controller) {
              if (isActive) {
                controller.enqueue({ type: "text-end", id: "0" });
              }
              controller.enqueue({
                type: "finish",
                finishReason,
                usage,
                providerMetadata
              });
            }
          })
        ),
        request: { body },
        response: { headers: responseHeaders }
      };
    }
  };
  function getResponseMetadata({
    id,
    model,
    created
  }) {
    return {
      id,
      modelId: model,
      timestamp: new Date(created * 1e3)
    };
  }
  var perplexityUsageSchema = object$1({
    prompt_tokens: number$1(),
    completion_tokens: number$1(),
    total_tokens: number$1().nullish(),
    citation_tokens: number$1().nullish(),
    num_search_queries: number$1().nullish()
  });
  var perplexityImageSchema = object$1({
    image_url: string$1(),
    origin_url: string$1(),
    height: number$1(),
    width: number$1()
  });
  var perplexityResponseSchema = object$1({
    id: string$1(),
    created: number$1(),
    model: string$1(),
    choices: array(
      object$1({
        message: object$1({
          role: literal("assistant"),
          content: string$1()
        }),
        finish_reason: string$1().nullish()
      })
    ),
    citations: array(string$1()).nullish(),
    images: array(perplexityImageSchema).nullish(),
    usage: perplexityUsageSchema.nullish()
  });
  var perplexityChunkSchema = object$1({
    id: string$1(),
    created: number$1(),
    model: string$1(),
    choices: array(
      object$1({
        delta: object$1({
          role: literal("assistant"),
          content: string$1()
        }),
        finish_reason: string$1().nullish()
      })
    ),
    citations: array(string$1()).nullish(),
    images: array(perplexityImageSchema).nullish(),
    usage: perplexityUsageSchema.nullish()
  });
  var perplexityErrorSchema = object$1({
    error: object$1({
      code: number$1(),
      message: string$1().nullish(),
      type: string$1().nullish()
    })
  });
  var errorToMessage = (data) => {
    var _a, _b;
    return (_b = (_a = data.error.message) != null ? _a : data.error.type) != null ? _b : "unknown error";
  };

  // src/perplexity-provider.ts
  function createPerplexity(options = {}) {
    const getHeaders = () => ({
      Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "PERPLEXITY_API_KEY",
      description: "Perplexity"
    })}`,
      ...options.headers
    });
    const createLanguageModel = (modelId) => {
      var _a;
      return new PerplexityLanguageModel(modelId, {
        baseURL: withoutTrailingSlash$1(
          (_a = options.baseURL) != null ? _a : "https://api.perplexity.ai"
        ),
        headers: getHeaders,
        generateId: generateId$1,
        fetch: options.fetch
      });
    };
    const provider = (modelId) => createLanguageModel(modelId);
    provider.languageModel = createLanguageModel;
    provider.textEmbeddingModel = (modelId) => {
      throw new NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
    };
    provider.imageModel = (modelId) => {
      throw new NoSuchModelError({ modelId, modelType: "imageModel" });
    };
    return provider;
  }
  createPerplexity();

  // src/errors/ai-sdk-error.ts
  var marker = "vercel.ai.error";
  var symbol = Symbol.for(marker);
  var _a;
  var _AISDKError = class _AISDKError extends Error {
    /**
     * Creates an AI SDK Error.
     *
     * @param {Object} params - The parameters for creating the error.
     * @param {string} params.name - The name of the error.
     * @param {string} params.message - The error message.
     * @param {unknown} [params.cause] - The underlying cause of the error.
     */
    constructor({
      name: name14,
      message,
      cause
    }) {
      super(message);
      this[_a] = true;
      this.name = name14;
      this.cause = cause;
    }
    /**
     * Checks if the given error is an AI SDK Error.
     * @param {unknown} error - The error to check.
     * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
     */
    static isInstance(error) {
      return _AISDKError.hasMarker(error, marker);
    }
    static hasMarker(error, marker15) {
      const markerSymbol = Symbol.for(marker15);
      return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
    }
  };
  _a = symbol;
  var AISDKError = _AISDKError;

  // src/errors/api-call-error.ts
  var name = "AI_APICallError";
  var marker2 = `vercel.ai.error.${name}`;
  var symbol2 = Symbol.for(marker2);
  var _a2;
  var APICallError = class extends AISDKError {
    constructor({
      message,
      url,
      requestBodyValues,
      statusCode,
      responseHeaders,
      responseBody,
      cause,
      isRetryable = statusCode != null && (statusCode === 408 || // request timeout
      statusCode === 409 || // conflict
      statusCode === 429 || // too many requests
      statusCode >= 500),
      // server error
      data
    }) {
      super({ name, message, cause });
      this[_a2] = true;
      this.url = url;
      this.requestBodyValues = requestBodyValues;
      this.statusCode = statusCode;
      this.responseHeaders = responseHeaders;
      this.responseBody = responseBody;
      this.isRetryable = isRetryable;
      this.data = data;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker2);
    }
  };
  _a2 = symbol2;

  // src/errors/empty-response-body-error.ts
  var name2 = "AI_EmptyResponseBodyError";
  var marker3 = `vercel.ai.error.${name2}`;
  var symbol3 = Symbol.for(marker3);
  var _a3;
  var EmptyResponseBodyError = class extends AISDKError {
    // used in isInstance
    constructor({ message = "Empty response body" } = {}) {
      super({ name: name2, message });
      this[_a3] = true;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker3);
    }
  };
  _a3 = symbol3;

  // src/errors/get-error-message.ts
  function getErrorMessage(error) {
    if (error == null) {
      return "unknown error";
    }
    if (typeof error === "string") {
      return error;
    }
    if (error instanceof Error) {
      return error.message;
    }
    return JSON.stringify(error);
  }

  // src/errors/invalid-argument-error.ts
  var name3 = "AI_InvalidArgumentError";
  var marker4 = `vercel.ai.error.${name3}`;
  var symbol4 = Symbol.for(marker4);
  var _a4;
  var InvalidArgumentError = class extends AISDKError {
    constructor({
      message,
      cause,
      argument
    }) {
      super({ name: name3, message, cause });
      this[_a4] = true;
      this.argument = argument;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker4);
    }
  };
  _a4 = symbol4;

  // src/errors/json-parse-error.ts
  var name6 = "AI_JSONParseError";
  var marker7 = `vercel.ai.error.${name6}`;
  var symbol7 = Symbol.for(marker7);
  var _a7;
  var JSONParseError = class extends AISDKError {
    constructor({ text, cause }) {
      super({
        name: name6,
        message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
        cause
      });
      this[_a7] = true;
      this.text = text;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker7);
    }
  };
  _a7 = symbol7;

  // src/errors/too-many-embedding-values-for-call-error.ts
  var name11 = "AI_TooManyEmbeddingValuesForCallError";
  var marker12 = `vercel.ai.error.${name11}`;
  var symbol12 = Symbol.for(marker12);
  var _a12;
  var TooManyEmbeddingValuesForCallError = class extends AISDKError {
    constructor(options) {
      super({
        name: name11,
        message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
      });
      this[_a12] = true;
      this.provider = options.provider;
      this.modelId = options.modelId;
      this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
      this.values = options.values;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker12);
    }
  };
  _a12 = symbol12;

  // src/errors/type-validation-error.ts
  var name12 = "AI_TypeValidationError";
  var marker13 = `vercel.ai.error.${name12}`;
  var symbol13 = Symbol.for(marker13);
  var _a13;
  var _TypeValidationError = class _TypeValidationError extends AISDKError {
    constructor({ value, cause }) {
      super({
        name: name12,
        message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
        cause
      });
      this[_a13] = true;
      this.value = value;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker13);
    }
    /**
     * Wraps an error into a TypeValidationError.
     * If the cause is already a TypeValidationError with the same value, it returns the cause.
     * Otherwise, it creates a new TypeValidationError.
     *
     * @param {Object} params - The parameters for wrapping the error.
     * @param {unknown} params.value - The value that failed validation.
     * @param {unknown} params.cause - The original error or cause of the validation failure.
     * @returns {TypeValidationError} A TypeValidationError instance.
     */
    static wrap({
      value,
      cause
    }) {
      return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });
    }
  };
  _a13 = symbol13;
  var TypeValidationError = _TypeValidationError;

  // src/errors/unsupported-functionality-error.ts
  var name13 = "AI_UnsupportedFunctionalityError";
  var marker14 = `vercel.ai.error.${name13}`;
  var symbol14 = Symbol.for(marker14);
  var _a14;
  var UnsupportedFunctionalityError = class extends AISDKError {
    constructor({
      functionality,
      message = `'${functionality}' functionality not supported.`
    }) {
      super({ name: name13, message });
      this[_a14] = true;
      this.functionality = functionality;
    }
    static isInstance(error) {
      return AISDKError.hasMarker(error, marker14);
    }
  };
  _a14 = symbol14;

  let customAlphabet = (alphabet, defaultSize = 21) => {
    return (size = defaultSize) => {
      let id = '';
      let i = size | 0;
      while (i--) {
        id += alphabet[(Math.random() * alphabet.length) | 0];
      }
      return id
    }
  };

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var secureJsonParse = {exports: {}};

  var hasRequiredSecureJsonParse;

  function requireSecureJsonParse () {
  	if (hasRequiredSecureJsonParse) return secureJsonParse.exports;
  	hasRequiredSecureJsonParse = 1;

  	const hasBuffer = typeof Buffer !== 'undefined';
  	const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
  	const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;

  	function _parse (text, reviver, options) {
  	  // Normalize arguments
  	  if (options == null) {
  	    if (reviver !== null && typeof reviver === 'object') {
  	      options = reviver;
  	      reviver = undefined;
  	    }
  	  }

  	  if (hasBuffer && Buffer.isBuffer(text)) {
  	    text = text.toString();
  	  }

  	  // BOM checker
  	  if (text && text.charCodeAt(0) === 0xFEFF) {
  	    text = text.slice(1);
  	  }

  	  // Parse normally, allowing exceptions
  	  const obj = JSON.parse(text, reviver);

  	  // Ignore null and non-objects
  	  if (obj === null || typeof obj !== 'object') {
  	    return obj
  	  }

  	  const protoAction = (options && options.protoAction) || 'error';
  	  const constructorAction = (options && options.constructorAction) || 'error';

  	  // options: 'error' (default) / 'remove' / 'ignore'
  	  if (protoAction === 'ignore' && constructorAction === 'ignore') {
  	    return obj
  	  }

  	  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {
  	    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
  	      return obj
  	    }
  	  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {
  	    if (suspectProtoRx.test(text) === false) {
  	      return obj
  	    }
  	  } else {
  	    if (suspectConstructorRx.test(text) === false) {
  	      return obj
  	    }
  	  }

  	  // Scan result for proto keys
  	  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })
  	}

  	function filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {
  	  let next = [obj];

  	  while (next.length) {
  	    const nodes = next;
  	    next = [];

  	    for (const node of nodes) {
  	      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly
  	        if (safe === true) {
  	          return null
  	        } else if (protoAction === 'error') {
  	          throw new SyntaxError('Object contains forbidden prototype property')
  	        }

  	        delete node.__proto__; // eslint-disable-line no-proto
  	      }

  	      if (constructorAction !== 'ignore' &&
  	          Object.prototype.hasOwnProperty.call(node, 'constructor') &&
  	          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly
  	        if (safe === true) {
  	          return null
  	        } else if (constructorAction === 'error') {
  	          throw new SyntaxError('Object contains forbidden prototype property')
  	        }

  	        delete node.constructor;
  	      }

  	      for (const key in node) {
  	        const value = node[key];
  	        if (value && typeof value === 'object') {
  	          next.push(value);
  	        }
  	      }
  	    }
  	  }
  	  return obj
  	}

  	function parse (text, reviver, options) {
  	  const stackTraceLimit = Error.stackTraceLimit;
  	  Error.stackTraceLimit = 0;
  	  try {
  	    return _parse(text, reviver, options)
  	  } finally {
  	    Error.stackTraceLimit = stackTraceLimit;
  	  }
  	}

  	function safeParse (text, reviver) {
  	  const stackTraceLimit = Error.stackTraceLimit;
  	  Error.stackTraceLimit = 0;
  	  try {
  	    return _parse(text, reviver, { safe: true })
  	  } catch (_e) {
  	    return null
  	  } finally {
  	    Error.stackTraceLimit = stackTraceLimit;
  	  }
  	}

  	secureJsonParse.exports = parse;
  	secureJsonParse.exports.default = parse;
  	secureJsonParse.exports.parse = parse;
  	secureJsonParse.exports.safeParse = safeParse;
  	secureJsonParse.exports.scan = filter;
  	return secureJsonParse.exports;
  }

  var secureJsonParseExports = requireSecureJsonParse();
  var SecureJSON = /*@__PURE__*/getDefaultExportFromCjs(secureJsonParseExports);

  // src/combine-headers.ts
  function combineHeaders(...headers) {
    return headers.reduce(
      (combinedHeaders, currentHeaders) => ({
        ...combinedHeaders,
        ...currentHeaders != null ? currentHeaders : {}
      }),
      {}
    );
  }

  // src/extract-response-headers.ts
  function extractResponseHeaders(response) {
    const headers = {};
    response.headers.forEach((value, key) => {
      headers[key] = value;
    });
    return headers;
  }
  var createIdGenerator = ({
    prefix,
    size: defaultSize = 16,
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    separator = "-"
  } = {}) => {
    const generator = customAlphabet(alphabet, defaultSize);
    if (prefix == null) {
      return generator;
    }
    if (alphabet.includes(separator)) {
      throw new InvalidArgumentError({
        argument: "separator",
        message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
      });
    }
    return (size) => `${prefix}${separator}${generator(size)}`;
  };
  var generateId = createIdGenerator();

  // src/remove-undefined-entries.ts
  function removeUndefinedEntries(record) {
    return Object.fromEntries(
      Object.entries(record).filter(([_key, value]) => value != null)
    );
  }

  // src/is-abort-error.ts
  function isAbortError(error) {
    return error instanceof Error && (error.name === "AbortError" || error.name === "TimeoutError");
  }

  // src/validator.ts
  var validatorSymbol = Symbol.for("vercel.ai.validator");
  function validator(validate) {
    return { [validatorSymbol]: true, validate };
  }
  function isValidator(value) {
    return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
  }
  function asValidator(value) {
    return isValidator(value) ? value : zodValidator(value);
  }
  function zodValidator(zodSchema) {
    return validator((value) => {
      const result = zodSchema.safeParse(value);
      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
    });
  }

  // src/validate-types.ts
  function validateTypes({
    value,
    schema: inputSchema
  }) {
    const result = safeValidateTypes({ value, schema: inputSchema });
    if (!result.success) {
      throw TypeValidationError.wrap({ value, cause: result.error });
    }
    return result.value;
  }
  function safeValidateTypes({
    value,
    schema
  }) {
    const validator2 = asValidator(schema);
    try {
      if (validator2.validate == null) {
        return { success: true, value };
      }
      const result = validator2.validate(value);
      if (result.success) {
        return result;
      }
      return {
        success: false,
        error: TypeValidationError.wrap({ value, cause: result.error })
      };
    } catch (error) {
      return {
        success: false,
        error: TypeValidationError.wrap({ value, cause: error })
      };
    }
  }

  // src/parse-json.ts
  function parseJSON({
    text,
    schema
  }) {
    try {
      const value = SecureJSON.parse(text);
      if (schema == null) {
        return value;
      }
      return validateTypes({ value, schema });
    } catch (error) {
      if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {
        throw error;
      }
      throw new JSONParseError({ text, cause: error });
    }
  }
  function safeParseJSON({
    text,
    schema
  }) {
    try {
      const value = SecureJSON.parse(text);
      if (schema == null) {
        return { success: true, value, rawValue: value };
      }
      const validationResult = safeValidateTypes({ value, schema });
      return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
    } catch (error) {
      return {
        success: false,
        error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error })
      };
    }
  }
  var getOriginalFetch2 = () => globalThis.fetch;
  var postJsonToApi = async ({
    url,
    headers,
    body,
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch
  }) => postToApi({
    url,
    headers: {
      "Content-Type": "application/json",
      ...headers
    },
    body: {
      content: JSON.stringify(body),
      values: body
    },
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch
  });
  var postToApi = async ({
    url,
    headers = {},
    body,
    successfulResponseHandler,
    failedResponseHandler,
    abortSignal,
    fetch = getOriginalFetch2()
  }) => {
    try {
      const response = await fetch(url, {
        method: "POST",
        headers: removeUndefinedEntries(headers),
        body: body.content,
        signal: abortSignal
      });
      const responseHeaders = extractResponseHeaders(response);
      if (!response.ok) {
        let errorInformation;
        try {
          errorInformation = await failedResponseHandler({
            response,
            url,
            requestBodyValues: body.values
          });
        } catch (error) {
          if (isAbortError(error) || APICallError.isInstance(error)) {
            throw error;
          }
          throw new APICallError({
            message: "Failed to process error response",
            cause: error,
            statusCode: response.status,
            url,
            responseHeaders,
            requestBodyValues: body.values
          });
        }
        throw errorInformation.value;
      }
      try {
        return await successfulResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (error instanceof Error) {
          if (isAbortError(error) || APICallError.isInstance(error)) {
            throw error;
          }
        }
        throw new APICallError({
          message: "Failed to process successful response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
    } catch (error) {
      if (isAbortError(error)) {
        throw error;
      }
      if (error instanceof TypeError && error.message === "fetch failed") {
        const cause = error.cause;
        if (cause != null) {
          throw new APICallError({
            message: `Cannot connect to API: ${cause.message}`,
            cause,
            url,
            requestBodyValues: body.values,
            isRetryable: true
            // retry when network error
          });
        }
      }
      throw error;
    }
  };
  var createJsonErrorResponseHandler = ({
    errorSchema,
    errorToMessage,
    isRetryable
  }) => async ({ response, url, requestBodyValues }) => {
    const responseBody = await response.text();
    const responseHeaders = extractResponseHeaders(response);
    if (responseBody.trim() === "") {
      return {
        responseHeaders,
        value: new APICallError({
          message: response.statusText,
          url,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response)
        })
      };
    }
    try {
      const parsedError = parseJSON({
        text: responseBody,
        schema: errorSchema
      });
      return {
        responseHeaders,
        value: new APICallError({
          message: errorToMessage(parsedError),
          url,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          data: parsedError,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
        })
      };
    } catch (parseError) {
      return {
        responseHeaders,
        value: new APICallError({
          message: response.statusText,
          url,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response)
        })
      };
    }
  };
  var createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {
    const responseBody = await response.text();
    const parsedResult = safeParseJSON({
      text: responseBody,
      schema: responseSchema
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!parsedResult.success) {
      throw new APICallError({
        message: "Invalid JSON response",
        cause: parsedResult.error,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        url,
        requestBodyValues
      });
    }
    return {
      responseHeaders,
      value: parsedResult.value,
      rawValue: parsedResult.rawValue
    };
  };

  // src/uint8-utils.ts
  var { btoa: btoa$1} = globalThis;
  function convertUint8ArrayToBase64(array) {
    let latin1string = "";
    for (let i = 0; i < array.length; i++) {
      latin1string += String.fromCodePoint(array[i]);
    }
    return btoa$1(latin1string);
  }

  // src/without-trailing-slash.ts
  function withoutTrailingSlash(url) {
    return url == null ? void 0 : url.replace(/\/$/, "");
  }

  var dist = {};

  var options = {};

  var hasRequiredOptions;

  function requireOptions () {
  	if (hasRequiredOptions) return options;
  	hasRequiredOptions = 1;
  	(function (exports) {
  		/**
  		 * Sometimes you don't allow every type to be partially parsed.
  		 * For example, you may not want a partial number because it may increase its size gradually before it's complete.
  		 * In this case, you can use the `Allow` object to control what types you allow to be partially parsed.
  		 * @module
  		 */
  		Object.defineProperty(exports, "__esModule", { value: true });
  		exports.Allow = exports.ALL = exports.COLLECTION = exports.ATOM = exports.SPECIAL = exports.INF = exports._INFINITY = exports.INFINITY = exports.NAN = exports.BOOL = exports.NULL = exports.OBJ = exports.ARR = exports.NUM = exports.STR = void 0;
  		/**
  		 * allow partial strings like `"hello \u12` to be parsed as `"hello "`
  		 */
  		exports.STR = 0b000000001;
  		/**
  		 * allow partial numbers like `123.` to be parsed as `123`
  		 */
  		exports.NUM = 0b000000010;
  		/**
  		 * allow partial arrays like `[1, 2,` to be parsed as `[1, 2]`
  		 */
  		exports.ARR = 0b000000100;
  		/**
  		 * allow partial objects like `{"a": 1, "b":` to be parsed as `{"a": 1}`
  		 */
  		exports.OBJ = 0b000001000;
  		/**
  		 * allow `nu` to be parsed as `null`
  		 */
  		exports.NULL = 0b000010000;
  		/**
  		 * allow `tr` to be parsed as `true`, and `fa` to be parsed as `false`
  		 */
  		exports.BOOL = 0b000100000;
  		/**
  		 * allow `Na` to be parsed as `NaN`
  		 */
  		exports.NAN = 0b001000000;
  		/**
  		 * allow `Inf` to be parsed as `Infinity`
  		 */
  		exports.INFINITY = 0b010000000;
  		/**
  		 * allow `-Inf` to be parsed as `-Infinity`
  		 */
  		exports._INFINITY = 0b100000000;
  		exports.INF = exports.INFINITY | exports._INFINITY;
  		exports.SPECIAL = exports.NULL | exports.BOOL | exports.INF | exports.NAN;
  		exports.ATOM = exports.STR | exports.NUM | exports.SPECIAL;
  		exports.COLLECTION = exports.ARR | exports.OBJ;
  		exports.ALL = exports.ATOM | exports.COLLECTION;
  		/**
  		 * Control what types you allow to be partially parsed.
  		 * The default is to allow all types to be partially parsed, which in most casees is the best option.
  		 * @example
  		 * If you don't want to allow partial objects, you can use the following code:
  		 * ```ts
  		 * import { Allow, parse } from "partial-json";
  		 * parse(`[{"a": 1, "b": 2}, {"a": 3,`, Allow.ARR); // [ { a: 1, b: 2 } ]
  		 * ```
  		 * Or you can use `~` to disallow a type:
  		 * ```ts
  		 * parse(`[{"a": 1, "b": 2}, {"a": 3,`, ~Allow.OBJ); // [ { a: 1, b: 2 } ]
  		 * ```
  		 * @example
  		 * If you don't want to allow partial strings, you can use the following code:
  		 * ```ts
  		 * import { Allow, parse } from "partial-json";
  		 * parse(`["complete string", "incompl`, ~Allow.STR); // [ 'complete string' ]
  		 * ```
  		 */
  		exports.Allow = { STR: exports.STR, NUM: exports.NUM, ARR: exports.ARR, OBJ: exports.OBJ, NULL: exports.NULL, BOOL: exports.BOOL, NAN: exports.NAN, INFINITY: exports.INFINITY, _INFINITY: exports._INFINITY, INF: exports.INF, SPECIAL: exports.SPECIAL, ATOM: exports.ATOM, COLLECTION: exports.COLLECTION, ALL: exports.ALL };
  		exports.default = exports.Allow; 
  	} (options));
  	return options;
  }

  var hasRequiredDist;

  function requireDist () {
  	if (hasRequiredDist) return dist;
  	hasRequiredDist = 1;
  	(function (exports) {
  		var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  		    if (k2 === undefined) k2 = k;
  		    var desc = Object.getOwnPropertyDescriptor(m, k);
  		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
  		      desc = { enumerable: true, get: function() { return m[k]; } };
  		    }
  		    Object.defineProperty(o, k2, desc);
  		}) : (function(o, m, k, k2) {
  		    if (k2 === undefined) k2 = k;
  		    o[k2] = m[k];
  		}));
  		var __exportStar = (dist && dist.__exportStar) || function(m, exports) {
  		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  		};
  		Object.defineProperty(exports, "__esModule", { value: true });
  		exports.Allow = exports.MalformedJSON = exports.PartialJSON = exports.parseJSON = exports.parse = void 0;
  		const options_1 = requireOptions();
  		Object.defineProperty(exports, "Allow", { enumerable: true, get: function () { return options_1.Allow; } });
  		__exportStar(requireOptions(), exports);
  		class PartialJSON extends Error {
  		}
  		exports.PartialJSON = PartialJSON;
  		class MalformedJSON extends Error {
  		}
  		exports.MalformedJSON = MalformedJSON;
  		/**
  		 * Parse incomplete JSON
  		 * @param {string} jsonString Partial JSON to be parsed
  		 * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details
  		 * @returns The parsed JSON
  		 * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)
  		 * @throws {MalformedJSON} If the JSON is malformed
  		 */
  		function parseJSON(jsonString, allowPartial = options_1.Allow.ALL) {
  		    if (typeof jsonString !== "string") {
  		        throw new TypeError(`expecting str, got ${typeof jsonString}`);
  		    }
  		    if (!jsonString.trim()) {
  		        throw new Error(`${jsonString} is empty`);
  		    }
  		    return _parseJSON(jsonString.trim(), allowPartial);
  		}
  		exports.parseJSON = parseJSON;
  		const _parseJSON = (jsonString, allow) => {
  		    const length = jsonString.length;
  		    let index = 0;
  		    const markPartialJSON = (msg) => {
  		        throw new PartialJSON(`${msg} at position ${index}`);
  		    };
  		    const throwMalformedError = (msg) => {
  		        throw new MalformedJSON(`${msg} at position ${index}`);
  		    };
  		    const parseAny = () => {
  		        skipBlank();
  		        if (index >= length)
  		            markPartialJSON("Unexpected end of input");
  		        if (jsonString[index] === '"')
  		            return parseStr();
  		        if (jsonString[index] === "{")
  		            return parseObj();
  		        if (jsonString[index] === "[")
  		            return parseArr();
  		        if (jsonString.substring(index, index + 4) === "null" || (options_1.Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index)))) {
  		            index += 4;
  		            return null;
  		        }
  		        if (jsonString.substring(index, index + 4) === "true" || (options_1.Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index)))) {
  		            index += 4;
  		            return true;
  		        }
  		        if (jsonString.substring(index, index + 5) === "false" || (options_1.Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index)))) {
  		            index += 5;
  		            return false;
  		        }
  		        if (jsonString.substring(index, index + 8) === "Infinity" || (options_1.Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index)))) {
  		            index += 8;
  		            return Infinity;
  		        }
  		        if (jsonString.substring(index, index + 9) === "-Infinity" || (options_1.Allow._INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index)))) {
  		            index += 9;
  		            return -Infinity;
  		        }
  		        if (jsonString.substring(index, index + 3) === "NaN" || (options_1.Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index)))) {
  		            index += 3;
  		            return NaN;
  		        }
  		        return parseNum();
  		    };
  		    const parseStr = () => {
  		        const start = index;
  		        let escape = false;
  		        index++; // skip initial quote
  		        while (index < length && (jsonString[index] !== '"' || (escape && jsonString[index - 1] === "\\"))) {
  		            escape = jsonString[index] === "\\" ? !escape : false;
  		            index++;
  		        }
  		        if (jsonString.charAt(index) == '"') {
  		            try {
  		                return JSON.parse(jsonString.substring(start, ++index - Number(escape)));
  		            }
  		            catch (e) {
  		                throwMalformedError(String(e));
  		            }
  		        }
  		        else if (options_1.Allow.STR & allow) {
  		            try {
  		                return JSON.parse(jsonString.substring(start, index - Number(escape)) + '"');
  		            }
  		            catch (e) {
  		                // SyntaxError: Invalid escape sequence
  		                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
  		            }
  		        }
  		        markPartialJSON("Unterminated string literal");
  		    };
  		    const parseObj = () => {
  		        index++; // skip initial brace
  		        skipBlank();
  		        const obj = {};
  		        try {
  		            while (jsonString[index] !== "}") {
  		                skipBlank();
  		                if (index >= length && options_1.Allow.OBJ & allow)
  		                    return obj;
  		                const key = parseStr();
  		                skipBlank();
  		                index++; // skip colon
  		                try {
  		                    const value = parseAny();
  		                    obj[key] = value;
  		                }
  		                catch (e) {
  		                    if (options_1.Allow.OBJ & allow)
  		                        return obj;
  		                    else
  		                        throw e;
  		                }
  		                skipBlank();
  		                if (jsonString[index] === ",")
  		                    index++; // skip comma
  		            }
  		        }
  		        catch (e) {
  		            if (options_1.Allow.OBJ & allow)
  		                return obj;
  		            else
  		                markPartialJSON("Expected '}' at end of object");
  		        }
  		        index++; // skip final brace
  		        return obj;
  		    };
  		    const parseArr = () => {
  		        index++; // skip initial bracket
  		        const arr = [];
  		        try {
  		            while (jsonString[index] !== "]") {
  		                arr.push(parseAny());
  		                skipBlank();
  		                if (jsonString[index] === ",") {
  		                    index++; // skip comma
  		                }
  		            }
  		        }
  		        catch (e) {
  		            if (options_1.Allow.ARR & allow) {
  		                return arr;
  		            }
  		            markPartialJSON("Expected ']' at end of array");
  		        }
  		        index++; // skip final bracket
  		        return arr;
  		    };
  		    const parseNum = () => {
  		        if (index === 0) {
  		            if (jsonString === "-")
  		                throwMalformedError("Not sure what '-' is");
  		            try {
  		                return JSON.parse(jsonString);
  		            }
  		            catch (e) {
  		                if (options_1.Allow.NUM & allow)
  		                    try {
  		                        return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
  		                    }
  		                    catch (e) { }
  		                throwMalformedError(String(e));
  		            }
  		        }
  		        const start = index;
  		        if (jsonString[index] === "-")
  		            index++;
  		        while (jsonString[index] && ",]}".indexOf(jsonString[index]) === -1)
  		            index++;
  		        if (index == length && !(options_1.Allow.NUM & allow))
  		            markPartialJSON("Unterminated number literal");
  		        try {
  		            return JSON.parse(jsonString.substring(start, index));
  		        }
  		        catch (e) {
  		            if (jsonString.substring(start, index) === "-")
  		                markPartialJSON("Not sure what '-' is");
  		            try {
  		                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
  		            }
  		            catch (e) {
  		                throwMalformedError(String(e));
  		            }
  		        }
  		    };
  		    const skipBlank = () => {
  		        while (index < length && " \n\r\t".includes(jsonString[index])) {
  		            index++;
  		        }
  		    };
  		    return parseAny();
  		};
  		const parse = parseJSON;
  		exports.parse = parse; 
  	} (dist));
  	return dist;
  }

  var distExports = requireDist();

  // src/ollama-provider.ts
  function convertToOllamaChatMessages(prompt) {
    const messages = [];
    for (const { content, role } of prompt) {
      switch (role) {
        case "system": {
          messages.push({ content, role: "system" });
          break;
        }
        case "user": {
          messages.push({
            ...content.reduce(
              (previous, current) => {
                if (current.type === "text") {
                  previous.content += current.text;
                } else if (current.type === "image" && current.image instanceof URL) {
                  throw new UnsupportedFunctionalityError({
                    functionality: "Image URLs in user messages"
                  });
                } else if (current.type === "image" && current.image instanceof Uint8Array) {
                  previous.images = previous.images || [];
                  previous.images.push(convertUint8ArrayToBase64(current.image));
                }
                return previous;
              },
              { content: "" }
            ),
            role: "user"
          });
          break;
        }
        case "assistant": {
          const text = [];
          const toolCalls = [];
          for (const part of content) {
            switch (part.type) {
              case "text": {
                text.push(part.text);
                break;
              }
              case "tool-call": {
                toolCalls.push({
                  function: {
                    arguments: part.args,
                    name: part.toolName
                  },
                  id: part.toolCallId,
                  type: "function"
                });
                break;
              }
              default: {
                const _exhaustiveCheck = part;
                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);
              }
            }
          }
          messages.push({
            content: text.join(","),
            role: "assistant",
            tool_calls: toolCalls.length > 0 ? toolCalls : void 0
          });
          break;
        }
        case "tool": {
          messages.push(
            ...content.map((part) => ({
              // Non serialized contents are not accepted by ollama, triggering the following error:
              // "json: cannot unmarshal array into Go struct field ChatRequest.messages of type string"
              content: typeof part.result === "object" ? JSON.stringify(part.result) : `${part.result}`,
              role: "tool",
              tool_call_id: part.toolCallId
            }))
          );
          break;
        }
        default: {
          const _exhaustiveCheck = role;
          throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
        }
      }
    }
    return messages;
  }
  var InferToolCallsFromStream = class {
    constructor({
      tools,
      type
    }) {
      this._firstMessage = true;
      this._tools = tools;
      this._toolPartial = "";
      this._toolCalls = [];
      this._type = type;
      this._detectedToolCall = false;
    }
    get toolCalls() {
      return this._toolCalls;
    }
    get detectedToolCall() {
      return this._detectedToolCall;
    }
    parse({
      controller,
      delta
    }) {
      var _a;
      this.detectToolCall(delta);
      if (!this._detectedToolCall) {
        return false;
      }
      this._toolPartial += delta;
      let parsedFunctions = distExports.parse(this._toolPartial);
      if (!Array.isArray(parsedFunctions)) {
        parsedFunctions = [parsedFunctions];
      }
      for (const [index, parsedFunction] of parsedFunctions.entries()) {
        const parsedArguments = (_a = JSON.stringify(parsedFunction == null ? void 0 : parsedFunction.parameters)) != null ? _a : "";
        if (parsedArguments === "") {
          continue;
        }
        if (!this._toolCalls[index]) {
          this._toolCalls[index] = {
            function: {
              arguments: "",
              name: parsedFunction.name
            },
            id: generateId(),
            type: "function"
          };
        }
        const toolCall = this._toolCalls[index];
        toolCall.function.arguments = parsedArguments;
        controller.enqueue({
          argsTextDelta: delta,
          toolCallId: toolCall.id,
          toolCallType: "function",
          toolName: toolCall.function.name,
          type: "tool-call-delta"
        });
      }
      return true;
    }
    finish({
      controller
    }) {
      for (const toolCall of this.toolCalls) {
        controller.enqueue({
          args: toolCall.function.arguments,
          toolCallId: toolCall.id,
          toolCallType: "function",
          toolName: toolCall.function.name,
          type: "tool-call"
        });
      }
      return this.finishReason();
    }
    detectToolCall(delta) {
      if (!this._tools || this._tools.length === 0) {
        return;
      }
      if (this._firstMessage) {
        if (this._type === "object-tool") {
          this._detectedToolCall = true;
        } else if (this._type === "regular" && (delta.trim().startsWith("{") || delta.trim().startsWith("["))) {
          this._detectedToolCall = true;
        }
        this._firstMessage = false;
      }
    }
    finishReason() {
      if (!this.detectedToolCall) {
        return "stop";
      }
      return this._type === "object-tool" ? "stop" : "tool-calls";
    }
  };

  // src/map-ollama-finish-reason.ts
  function mapOllamaFinishReason({
    finishReason,
    hasToolCalls
  }) {
    switch (finishReason) {
      case "stop": {
        return hasToolCalls ? "tool-calls" : "stop";
      }
      default: {
        return "other";
      }
    }
  }
  var ollamaErrorDataSchema = object$1({
    error: object$1({
      code: string$1().nullable(),
      message: string$1(),
      param: any().nullable(),
      type: string$1()
    })
  });
  var ollamaFailedResponseHandler = createJsonErrorResponseHandler({
    errorSchema: ollamaErrorDataSchema,
    errorToMessage: (data) => data.error.message
  });
  function prepareTools({
    mode
  }) {
    var _a;
    const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;
    const toolWarnings = [];
    const toolChoice = mode.toolChoice;
    if (tools === void 0) {
      return {
        tools: void 0,
        toolWarnings
      };
    }
    const ollamaTools = [];
    for (const tool of tools) {
      if (tool.type === "provider-defined") {
        toolWarnings.push({ tool, type: "unsupported-tool" });
      } else {
        ollamaTools.push({
          function: {
            description: tool.description,
            name: tool.name,
            parameters: tool.parameters
          },
          type: "function"
        });
      }
    }
    if (toolChoice === void 0) {
      return {
        tools: ollamaTools,
        toolWarnings
      };
    }
    const type = toolChoice.type;
    switch (type) {
      case "auto": {
        return {
          tools: ollamaTools,
          toolWarnings
        };
      }
      case "none": {
        return {
          tools: void 0,
          toolWarnings
        };
      }
      default: {
        const _exhaustiveCheck = type;
        throw new UnsupportedFunctionalityError({
          functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }

  // src/utils/remove-undefined.ts
  function removeUndefined(object) {
    return Object.fromEntries(
      Object.entries(object).filter(([, v]) => v !== void 0)
    );
  }

  // src/utils/text-line-stream.ts
  var TextLineStream = class extends TransformStream {
    constructor() {
      super({
        flush: (controller) => {
          if (this.buffer.length === 0) return;
          controller.enqueue(this.buffer);
        },
        transform: (chunkText, controller) => {
          chunkText = this.buffer + chunkText;
          while (true) {
            const EOL = chunkText.indexOf("\n");
            if (EOL === -1) break;
            controller.enqueue(chunkText.slice(0, EOL));
            chunkText = chunkText.slice(EOL + 1);
          }
          this.buffer = chunkText;
        }
      });
      this.buffer = "";
    }
  };

  // src/utils/response-handler.ts
  var createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {
    const responseHeaders = extractResponseHeaders(response);
    if (response.body === null) {
      throw new EmptyResponseBodyError({});
    }
    return {
      responseHeaders,
      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TextLineStream()).pipeThrough(
        new TransformStream({
          transform(chunkText, controller) {
            controller.enqueue(
              safeParseJSON({
                schema: chunkSchema,
                text: chunkText
              })
            );
          }
        })
      )
    };
  };

  // src/ollama-chat-language-model.ts
  var OllamaChatLanguageModel = class {
    constructor(modelId, settings, config) {
      this.modelId = modelId;
      this.settings = settings;
      this.config = config;
      this.specificationVersion = "v1";
      this.defaultObjectGenerationMode = "json";
      this.supportsImageUrls = false;
    }
    get supportsStructuredOutputs() {
      var _a;
      return (_a = this.settings.structuredOutputs) != null ? _a : false;
    }
    get provider() {
      return this.config.provider;
    }
    getArguments({
      frequencyPenalty,
      maxTokens,
      mode,
      presencePenalty,
      prompt,
      responseFormat,
      seed,
      stopSequences,
      temperature,
      topK,
      topP
    }) {
      const type = mode.type;
      const warnings = [];
      if (responseFormat !== void 0 && responseFormat.type === "json" && responseFormat.schema !== void 0 && !this.supportsStructuredOutputs) {
        warnings.push({
          details: "JSON response format schema is only supported with structuredOutputs",
          setting: "responseFormat",
          type: "unsupported-setting"
        });
      }
      const baseArguments = {
        format: responseFormat == null ? void 0 : responseFormat.type,
        model: this.modelId,
        options: removeUndefined({
          f16_kv: this.settings.f16Kv,
          frequency_penalty: frequencyPenalty,
          low_vram: this.settings.lowVram,
          main_gpu: this.settings.mainGpu,
          min_p: this.settings.minP,
          mirostat: this.settings.mirostat,
          mirostat_eta: this.settings.mirostatEta,
          mirostat_tau: this.settings.mirostatTau,
          num_batch: this.settings.numBatch,
          num_ctx: this.settings.numCtx,
          num_gpu: this.settings.numGpu,
          num_keep: this.settings.numKeep,
          num_predict: maxTokens,
          num_thread: this.settings.numThread,
          numa: this.settings.numa,
          penalize_newline: this.settings.penalizeNewline,
          presence_penalty: presencePenalty,
          repeat_last_n: this.settings.repeatLastN,
          repeat_penalty: this.settings.repeatPenalty,
          seed,
          stop: stopSequences,
          temperature,
          tfs_z: this.settings.tfsZ,
          top_k: topK,
          top_p: topP,
          typical_p: this.settings.typicalP,
          use_mlock: this.settings.useMlock,
          use_mmap: this.settings.useMmap,
          vocab_only: this.settings.vocabOnly
        })
      };
      switch (type) {
        case "regular": {
          const { tools, toolWarnings } = prepareTools({
            mode
          });
          return {
            args: {
              ...baseArguments,
              messages: convertToOllamaChatMessages(prompt),
              tools
            },
            type,
            warnings: [...warnings, ...toolWarnings]
          };
        }
        case "object-json": {
          return {
            args: {
              ...baseArguments,
              format: this.supportsStructuredOutputs && mode.schema !== void 0 ? mode.schema : "json",
              messages: convertToOllamaChatMessages(prompt)
            },
            type,
            warnings
          };
        }
        case "object-tool": {
          return {
            args: {
              ...baseArguments,
              messages: convertToOllamaChatMessages(prompt),
              tool_choice: {
                function: { name: mode.tool.name },
                type: "function"
              },
              tools: [
                {
                  function: {
                    description: mode.tool.description,
                    name: mode.tool.name,
                    parameters: mode.tool.parameters
                  },
                  type: "function"
                }
              ]
            },
            type,
            warnings
          };
        }
        default: {
          const _exhaustiveCheck = type;
          throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
        }
      }
    }
    async doGenerate(options) {
      var _a, _b;
      const { args, warnings } = this.getArguments(options);
      const body = {
        ...args,
        stream: false
      };
      const { responseHeaders, value: response } = await postJsonToApi({
        abortSignal: options.abortSignal,
        body,
        failedResponseHandler: ollamaFailedResponseHandler,
        fetch: this.config.fetch,
        headers: combineHeaders(this.config.headers(), options.headers),
        successfulResponseHandler: createJsonResponseHandler(
          ollamaChatResponseSchema
        ),
        url: `${this.config.baseURL}/chat`
      });
      const { messages: rawPrompt, ...rawSettings } = body;
      const toolCalls = (_a = response.message.tool_calls) == null ? void 0 : _a.map((toolCall) => {
        var _a2;
        return {
          args: JSON.stringify(toolCall.function.arguments),
          toolCallId: (_a2 = toolCall.id) != null ? _a2 : generateId(),
          toolCallType: "function",
          toolName: toolCall.function.name
        };
      });
      return {
        finishReason: mapOllamaFinishReason({
          finishReason: response.done_reason,
          hasToolCalls: toolCalls !== void 0 && toolCalls.length > 0
        }),
        rawCall: { rawPrompt, rawSettings },
        rawResponse: { headers: responseHeaders },
        request: { body: JSON.stringify(body) },
        text: (_b = response.message.content) != null ? _b : void 0,
        toolCalls,
        usage: {
          completionTokens: response.eval_count || 0,
          promptTokens: response.prompt_eval_count || 0
        },
        warnings
      };
    }
    async doStream(options) {
      if (this.settings.simulateStreaming) {
        const result = await this.doGenerate(options);
        const simulatedStream = new ReadableStream({
          start(controller) {
            controller.enqueue({ type: "response-metadata", ...result.response });
            if (result.text) {
              controller.enqueue({
                textDelta: result.text,
                type: "text-delta"
              });
            }
            if (result.toolCalls) {
              for (const toolCall of result.toolCalls) {
                controller.enqueue({
                  argsTextDelta: toolCall.args,
                  toolCallId: toolCall.toolCallId,
                  toolCallType: "function",
                  toolName: toolCall.toolName,
                  type: "tool-call-delta"
                });
                controller.enqueue({
                  type: "tool-call",
                  ...toolCall
                });
              }
            }
            controller.enqueue({
              finishReason: result.finishReason,
              logprobs: result.logprobs,
              providerMetadata: result.providerMetadata,
              type: "finish",
              usage: result.usage
            });
            controller.close();
          }
        });
        return {
          rawCall: result.rawCall,
          rawResponse: result.rawResponse,
          stream: simulatedStream,
          warnings: result.warnings
        };
      }
      const { args: body, type, warnings } = this.getArguments(options);
      const { responseHeaders, value: response } = await postJsonToApi({
        abortSignal: options.abortSignal,
        body,
        failedResponseHandler: ollamaFailedResponseHandler,
        fetch: this.config.fetch,
        headers: combineHeaders(this.config.headers(), options.headers),
        successfulResponseHandler: createJsonStreamResponseHandler(
          ollamaChatStreamChunkSchema
        ),
        url: `${this.config.baseURL}/chat`
      });
      const { messages: rawPrompt, ...rawSettings } = body;
      const tools = options.mode.type === "regular" ? options.mode.tools : options.mode.type === "object-tool" ? [options.mode.tool] : void 0;
      const inferToolCallsFromStream = new InferToolCallsFromStream({
        tools,
        type
      });
      let finishReason = "other";
      let usage = {
        completionTokens: Number.NaN,
        promptTokens: Number.NaN
      };
      const { experimentalStreamTools = true } = this.settings;
      return {
        rawCall: { rawPrompt, rawSettings },
        rawResponse: { headers: responseHeaders },
        request: { body: JSON.stringify(body) },
        stream: response.pipeThrough(
          new TransformStream({
            async flush(controller) {
              controller.enqueue({
                finishReason,
                type: "finish",
                usage
              });
            },
            async transform(chunk, controller) {
              if (!chunk.success) {
                controller.enqueue({ error: chunk.error, type: "error" });
                return;
              }
              const value = chunk.value;
              if (value.done) {
                finishReason = inferToolCallsFromStream.finish({ controller });
                usage = {
                  completionTokens: value.eval_count,
                  promptTokens: value.prompt_eval_count || 0
                };
                return;
              }
              if (experimentalStreamTools) {
                const isToolCallStream = inferToolCallsFromStream.parse({
                  controller,
                  delta: value.message.content
                });
                if (isToolCallStream) {
                  return;
                }
              }
              if (value.message.content !== null) {
                controller.enqueue({
                  textDelta: value.message.content,
                  type: "text-delta"
                });
              }
            }
          })
        ),
        warnings
      };
    }
  };
  var ollamaChatResponseSchema = object$1({
    created_at: string$1(),
    done: literal(true),
    done_reason: string$1().optional().nullable(),
    eval_count: number$1(),
    eval_duration: number$1(),
    load_duration: number$1().optional(),
    message: object$1({
      content: string$1(),
      role: string$1(),
      tool_calls: array(
        object$1({
          function: object$1({
            arguments: record(any()),
            name: string$1()
          }),
          id: string$1().optional()
        })
      ).optional().nullable()
    }),
    model: string$1(),
    prompt_eval_count: number$1().optional(),
    prompt_eval_duration: number$1().optional(),
    total_duration: number$1()
  });
  var ollamaChatStreamChunkSchema = discriminatedUnion("done", [
    object$1({
      created_at: string$1(),
      done: literal(false),
      message: object$1({
        content: string$1(),
        role: string$1()
      }),
      model: string$1()
    }),
    object$1({
      created_at: string$1(),
      done: literal(true),
      eval_count: number$1(),
      eval_duration: number$1(),
      load_duration: number$1().optional(),
      model: string$1(),
      prompt_eval_count: number$1().optional(),
      prompt_eval_duration: number$1().optional(),
      total_duration: number$1()
    })
  ]);
  var OllamaEmbeddingModel = class {
    constructor(modelId, settings, config) {
      this.specificationVersion = "v1";
      this.modelId = modelId;
      this.settings = settings;
      this.config = config;
    }
    get provider() {
      return this.config.provider;
    }
    get maxEmbeddingsPerCall() {
      var _a;
      return (_a = this.settings.maxEmbeddingsPerCall) != null ? _a : 2048;
    }
    get supportsParallelCalls() {
      return false;
    }
    async doEmbed({
      abortSignal,
      values
    }) {
      if (values.length > this.maxEmbeddingsPerCall) {
        throw new TooManyEmbeddingValuesForCallError({
          maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
          modelId: this.modelId,
          provider: this.provider,
          values
        });
      }
      const { responseHeaders, value: response } = await postJsonToApi({
        abortSignal,
        body: {
          input: values,
          model: this.modelId
        },
        failedResponseHandler: ollamaFailedResponseHandler,
        fetch: this.config.fetch,
        headers: this.config.headers(),
        successfulResponseHandler: createJsonResponseHandler(
          ollamaTextEmbeddingResponseSchema
        ),
        url: `${this.config.baseURL}/embed`
      });
      return {
        embeddings: response.embeddings,
        rawResponse: { headers: responseHeaders },
        usage: response.prompt_eval_count ? { tokens: response.prompt_eval_count } : void 0
      };
    }
  };
  var ollamaTextEmbeddingResponseSchema = object$1({
    embeddings: array(array(number$1())),
    prompt_eval_count: number$1().nullable()
  });

  // src/ollama-provider.ts
  function createOllama(options = {}) {
    var _a;
    const baseURL = (_a = withoutTrailingSlash(options.baseURL)) != null ? _a : "http://127.0.0.1:11434/api";
    const getHeaders = () => ({
      ...options.headers
    });
    const createChatModel = (modelId, settings = {}) => new OllamaChatLanguageModel(modelId, settings, {
      baseURL,
      fetch: options.fetch,
      headers: getHeaders,
      provider: "ollama.chat"
    });
    const createEmbeddingModel = (modelId, settings = {}) => new OllamaEmbeddingModel(modelId, settings, {
      baseURL,
      fetch: options.fetch,
      headers: getHeaders,
      provider: "ollama.embedding"
    });
    const provider = function(modelId, settings) {
      if (new.target) {
        throw new Error(
          "The Ollama model function cannot be called with the new keyword."
        );
      }
      return createChatModel(modelId, settings);
    };
    provider.chat = createChatModel;
    provider.embedding = createEmbeddingModel;
    provider.languageModel = createChatModel;
    provider.textEmbedding = createEmbeddingModel;
    provider.textEmbeddingModel = createEmbeddingModel;
    return provider;
  }
  var ollama = createOllama();

  // Base object with shared logic for all providers
  const providerPrototype = {
    get apiKey() {
      return PREFS.getPref(this.apiPref);
    },
    set apiKey(v) {
      if (typeof v === "string") PREFS.setPref(this.apiPref, v);
    },
    get model() {
      return PREFS.getPref(this.modelPref);
    },
    set model(v) {
      if (this.AVAILABLE_MODELS.includes(v)) PREFS.setPref(this.modelPref, v);
    },
    getModel() {
      return this.create({ apiKey: this.apiKey })(this.model);
    },
  };

  const mistral = Object.assign(Object.create(providerPrototype), {
    name: "mistral",
    label: "Mistral AI",
    faviconUrl: "https://www.google.com/s2/favicons?sz=32&domain_url=https%3A%2F%2Fmistral.ai%2F",
    apiKeyUrl: "https://console.mistral.ai/api-keys/",
    AVAILABLE_MODELS: [
      "pixtral-large-latest",
      "mistral-large-latest",
      "mistral-medium-latest",
      "mistral-medium-2505",
      "mistral-small-latest",
      "magistral-small-2506",
      "magistral-medium-2506",
      "ministral-3b-latest",
      "ministral-8b-latest",
      "pixtral-12b-2409",
      "open-mistral-7b",
      "open-mixtral-8x7b",
      "open-mixtral-8x22b",
    ],
    AVAILABLE_MODELS_LABELS: {
      "pixtral-large-latest": "Pixtral Large (Latest)",
      "mistral-large-latest": "Mistral Large (Latest)",
      "mistral-medium-latest": "Mistral Medium (Latest)",
      "mistral-medium-2505": "Mistral Medium (2505)",
      "mistral-small-latest": "Mistral Small(Latest)",
      "magistral-small-2506": "Magistral Small (2506)",
      "magistral-medium-2506": "Magistral Medium (2506)",
      "ministral-3b-latest": "Ministral 3B (Latest)",
      "ministral-8b-latest": "Ministral 8B (Latest)",
      "pixtral-12b-2409": "Pixtral 12B (2409)",
      "open-mistral-7b": "Open Mistral 7B",
      "open-mixtral-8x7b": "Open Mixtral 8x7B",
      "open-mixtral-8x22b": "Open Mixtral 8x22B",
    },
    modelPref: PREFS.MISTRAL_MODEL,
    apiPref: PREFS.MISTRAL_API_KEY,
    create: createMistral,
  });

  const gemini = Object.assign(Object.create(providerPrototype), {
    name: "gemini",
    label: "Google Gemini",
    faviconUrl: "https://www.google.com/s2/favicons?sz=32&domain_url=https%3A%2F%2Fgemini.google.com",
    apiKeyUrl: "https://aistudio.google.com/app/apikey",
    AVAILABLE_MODELS: [
      "gemini-2.5-pro",
      "gemini-2.5-flash",
      "gemini-2.5-flash-lite",
      "gemini-2.5-flash-lite-preview-06-17",
      "gemini-2.0-flash",
      "gemini-1.5-pro",
      "gemini-1.5-pro-latest",
      "gemini-1.5-flash",
      "gemini-1.5-flash-latest",
      "gemini-1.5-flash-8b",
      "gemini-1.5-flash-8b-latest",
    ],
    AVAILABLE_MODELS_LABELS: {
      "gemini-2.5-pro": "Gemini 2.5 Pro",
      "gemini-2.5-flash": "Gemini 2.5 Flash",
      "gemini-2.5-flash-lite": "Gemini 2.5 Flash Lite",
      "gemini-2.5-flash-lite-preview-06-17": "Gemini 2.5 Flash Lite (preview)",
      "gemini-2.0-flash": "Gemini 2.0 Flash",
      "gemini-1.5-pro": "Gemini 1.5 Pro",
      "gemini-1.5-pro-latest": "Gemini 1.5 Pro Latest",
      "gemini-1.5-flash": "Gemini 1.5 Flash",
      "gemini-1.5-flash-latest": "Gemini 1.5 Flash Latest",
      "gemini-1.5-flash-8b": "Gemini 1.5 Flash 8B",
      "gemini-1.5-flash-8b-latest": "Gemini 1.5 Flash 8B Latest",
    },
    modelPref: PREFS.GEMINI_MODEL,
    apiPref: PREFS.GEMINI_API_KEY,
    create: createGoogleGenerativeAI,
  });

  const openai = Object.assign(Object.create(providerPrototype), {
    name: "openai",
    label: "OpenAI GPT",
    faviconUrl: "https://www.google.com/s2/favicons?sz=32&domain_url=chatgpt.com/",
    apiKeyUrl: "https://platform.openai.com/account/api-keys",
    AVAILABLE_MODELS: [
      "gpt-4.1",
      "gpt-4.1-mini",
      "gpt-4.1-nano",
      "gpt-4o",
      "gpt-4o-mini",
      "gpt-4-turbo",
      "gpt-4",
      "gpt-3.5-turbo",
      "o1",
      "o3-mini",
      "o3",
      "o4-mini",
      "gpt-5",
      "gpt-5-mini",
      "gpt-5-nano",
      "gpt-5-chat-latest",
    ],
    AVAILABLE_MODELS_LABELS: {
      "gpt-4.1": "GPT 4.1",
      "gpt-4.1-mini": "GPT 4.1 Mini",
      "gpt-4.1-nano": "GPT 4.1 Nano",
      "gpt-4o": "GPT 4o",
      "gpt-4o-mini": "GPT 4o Mini",
      "gpt-4-turbo": "GPT 4 Turbo",
      "gpt-4": "GPT 4",
      "gpt-3.5-turbo": "GPT 3.5 Turbo",
      o1: "O1",
      "o3-mini": "O3 Mini",
      o3: "O3",
      "o4-mini": "O4 Mini",
      "gpt-5": "GTP 5",
      "gpt-5-mini": "GPT 5 mini",
      "gpt-5-mini": "GPT 5 mini",
      "gpt-5-chat-latest": "GPT 5 latest",
    },
    modelPref: PREFS.OPENAI_MODEL,
    apiPref: PREFS.OPENAI_API_KEY,
    create: createOpenAI,
  });

  const claude = Object.assign(Object.create(providerPrototype), {
    name: "claude",
    label: "Anthropic Claude",
    faviconUrl: "https://www.google.com/s2/favicons?sz=32&domain_url=anthropic.com",
    apiKeyUrl: "https://console.anthropic.com/dashboard",
    AVAILABLE_MODELS: [
      "claude-4-opus",
      "claude-4-sonnet",
      "claude-4-haiku",
      "claude-3-opus",
      "claude-3-sonnet",
      "claude-3-haiku",
    ],
    AVAILABLE_MODELS_LABELS: {
      "claude-4-opus": "Claude 4 Opus",
      "claude-4-sonnet": "Claude 4 Sonnet",
      "claude-4-haiku": "Claude 4 Haiku",
      "claude-3-opus": "Claude 3 Opus",
      "claude-3-sonnet": "Claude 3 Sonnet",
      "claude-3-haiku": "Claude 3 Haiku",
    },
    modelPref: PREFS.CLAUDE_MODEL,
    apiPref: PREFS.CLAUDE_API_KEY,
    create: createAnthropic,
  });

  const grok = Object.assign(Object.create(providerPrototype), {
    name: "grok",
    label: "xAI Grok",
    faviconUrl: "https://www.google.com/s2/favicons?sz=32&domain_url=x.ai",
    apiKeyUrl: "https://x.ai/api",
    AVAILABLE_MODELS: [
      "grok-4",
      "grok-3",
      "grok-3-latest",
      "grok-3-fast",
      "grok-3-fast-latest",
      "grok-3-mini",
      "grok-3-mini-latest",
      "grok-3-mini-fast",
      "grok-3-mini-fast-latest",
      "grok-2",
      "grok-2-latest",
      "grok-2-1212",
      "grok-beta",
    ],
    AVAILABLE_MODELS_LABELS: {
      "grok-4": "Grok 4",
      "grok-3": "Grok 3",
      "grok-3-latest": "Grok 3 Latest",
      "grok-3-fast": "Grok 3 Fast",
      "grok-3-fast-latest": "Grok 3 Fast Latest",
      "grok-3-mini": "Grok 3 Mini",
      "grok-3-mini-latest": "Grok 3 Mini Latest",
      "grok-3-mini-fast": "Grok 3 Mini Fast",
      "grok-3-mini-fast-latest": "Grok 3 Mini Fast Latest",
      "grok-2": "Grok 2",
      "grok-2-latest": "Grok 2 Latest",
      "grok-2-1212": "Grok 2 1212",
      "grok-beta": "Grok Beta",
    },
    modelPref: PREFS.GROK_MODEL,
    apiPref: PREFS.GROK_API_KEY,
    create: xai,
  });

  const perplexity = Object.assign(Object.create(providerPrototype), {
    name: "perplexity",
    label: "Perplexity AI",
    faviconUrl: "https://www.google.com/s2/favicons?sz=32&domain_url=perplexity.ai",
    apiKeyUrl: "https://perplexity.ai",
    AVAILABLE_MODELS: [
      "sonar-deep-research",
      "sonar-reasoning-pro",
      "sonar-reasoning",
      "sonar-pro",
      "sonar",
    ],
    AVAILABLE_MODELS_LABELS: {
      "sonar-deep-research": "Sonar Deep Research",
      "sonar-reasoning-pro": "Sonar Reasoning Pro",
      "sonar-reasoning": "Sonar Reasoning",
      "sonar-pro": "Sonar Pro",
      sonar: "Sonar",
    },
    modelPref: PREFS.PERPLEXITY_MODEL,
    apiPref: PREFS.PERPLEXITY_API_KEY,
    create: createPerplexity,
  });

  const ollamaProvider = Object.assign(Object.create(providerPrototype), {
    name: "ollama",
    label: "Ollama (local)",
    faviconUrl: "https://www.google.com/s2/favicons?sz=32&domain_url=ollama.com/",
    apiKeyUrl: "",
    AVAILABLE_MODELS: [
      "deepseek-r1:8b",
      "deepseek-r1:1.5b",
      "deepseek-r1:7b",
      "deepseek-r1:14b",
      "deepseek-r1:32b",
      "deepseek-r1:70b",
      "mixtral:8x22b",
      "mixtral:8x7b",
      "qwen3:0.6b",
      "qwen3:1.7b",
      "qwen3:4b",
      "qwen3:8b",
      "qwen3:14b",
      "qwen3:32b",
      "qwen3:30b-a3b",
      "qwen3:235b-a22b",
      "llama4:scout",
      "llama4:maverick",
    ],
    AVAILABLE_MODELS_LABELS: {
      "deepseek-r1:8b": "DeepSeek R1 (8B parameters)",
      "deepseek-r1:1.5b": "DeepSeek R1 (1.5B parameters)",
      "deepseek-r1:7b": "DeepSeek R1 (7B parameters)",
      "deepseek-r1:14b": "DeepSeek R1 (14B parameters)",
      "deepseek-r1:32b": "DeepSeek R1 (32B parameters)",
      "deepseek-r1:70b": "DeepSeek R1 (70B parameters)",
      "mixtral:8x22b": "Mixtral (8x22B)",
      "mixtral:8x7b": "Mixtral (8x7B)",
      "qwen3:0.6b": "Qwen3 (0.6B parameters)",
      "qwen3:1.7b": "Qwen3 (1.7B parameters)",
      "qwen3:4b": "Qwen3 (4B parameters)",
      "qwen3:8b": "Qwen3 (8B parameters)",
      "qwen3:14b": "Qwen3 (14B parameters)",
      "qwen3:32b": "Qwen3 (32B parameters)",
      "qwen3:30b-a3b": "Qwen3 (30B mixture-of-experts model with 3B active parameters)",
      "qwen3:235b-a22b": "Qwen3 (235B mixture-of-experts model with 22B active parameters)",
      "llama4:scout": "Llama 4 Scout",
      "llama4:maverick": "Llama 4 Maverick",
    },
    modelPref: PREFS.OLLAMA_MODEL,
    apiPref: PREFS.OLLAMA_API_KEY,
    getModel() {
      return ollama(this.model);
    },
  });

  // Helper function to create Zod string parameters
  const createStringParameter = (description, isOptional = false) => {
    let schema = string$1().describe(description);
    return isOptional ? schema.optional() : schema;
  };

  // Helper function to create tools with consistent structure
  const createTool = (name, description, parameters, executeFn) => {
    const t = tool({
      description,
      inputSchema: object$1(parameters),
      execute: (args) => confirmAndExecute(name, executeFn, args),
    });
    // Attach the original execute function so we can bypass confirmation later
    Object.defineProperty(t, "executeFn", {
      value: executeFn,
      enumerable: false,
      configurable: true,
      writable: false,
    });
    return t;
  };

  // Confirmation wrapper
  async function confirmAndExecute(toolName, executeFn, args) {
    if (PREFS.conformation) {
      const confirmed = await browseBotFindbar.createToolConfirmationDialog([toolName]);
      if (!confirmed) {
        debugLog(`Tool execution for '${toolName}' cancelled by user.`);
        return { error: `Tool execution for '${toolName}' was cancelled by the user.` };
      }
    }
    return executeFn(args);
  }

  // â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  // â”‚                         SEARCH                          â”‚
  // â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
  async function getSearchURL(engineName, searchTerm) {
    try {
      const engine = await Services.search.getEngineByName(engineName);
      if (!engine) {
        debugError(`No search engine found with name: ${engineName}`);
        return null;
      }
      const submission = engine.getSubmission(searchTerm.trim());
      if (!submission) {
        debugError(`No submission found for term: ${searchTerm} and engine: ${engineName}`);
        return null;
      }
      return submission.uri.spec;
    } catch (e) {
      debugError(`Error getting search URL for engine "${engineName}".`, e);
      return null;
    }
  }

  async function search(args) {
    const { searchTerm, engineName, where } = args;
    const defaultEngineName = Services.search.defaultEngine.name;
    const searchEngineName = engineName || defaultEngineName;
    if (!searchTerm) return { error: "Search tool requires a searchTerm." };

    const url = await getSearchURL(searchEngineName, searchTerm);
    if (url) {
      return await openLink({ link: url, where });
    } else {
      return {
        error: `Could not find search engine named '${searchEngineName}'.`,
      };
    }
  }

  // â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  // â”‚                          TABS                           â”‚
  // â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
  async function openLink(args) {
    const { link, where = "new tab" } = args;
    if (!link) return { error: "openLink requires a link." };
    const whereNormalized = where?.toLowerCase()?.trim();
    try {
      switch (whereNormalized) {
        case "current tab":
          openTrustedLinkIn(link, "current");
          break;
        case "new tab":
          openTrustedLinkIn(link, "tab");
          break;
        case "new window":
          openTrustedLinkIn(link, "window");
          break;
        case "incognito":
        case "private":
          window.openTrustedLinkIn(link, "window", { private: true });
          break;
        case "glance":
          if (window.gZenGlanceManager) {
            const rect = gBrowser.selectedBrowser.getBoundingClientRect();
            window.gZenGlanceManager.openGlance({
              url: link,
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2,
              width: 10,
              height: 10,
            });
          } else {
            openTrustedLinkIn(link, "tab");
            return { result: `Glance not available. Opened in a new tab.` };
          }
          break;
        case "vsplit":
        case "hsplit":
          if (window.gZenViewSplitter) {
            const sep = whereNormalized === "vsplit" ? "vsep" : "hsep";
            const tab1 = gBrowser.selectedTab;
            await openTrustedLinkIn(link, "tab");
            const tab2 = gBrowser.selectedTab;
            gZenViewSplitter.splitTabs([tab1, tab2], sep, 1);
          } else return { error: "Split view is not available." };
          break;
        default:
          openTrustedLinkIn(link, "tab");
          return {
            result: `Unknown location "${where}". Opened in a new tab as fallback.`,
          };
      }
      return { result: `Successfully opened ${link} in ${where}.` };
    } catch (e) {
      debugError(`Failed to open link "${link}" in "${where}".`, e);
      return { error: `Failed to open link.` };
    }
  }

  async function newSplit(args) {
    const { link1, link2, type = "vertical" } = args;
    if (!window.gZenViewSplitter) return { error: "Split view function is not available." };
    if (!link1 || !link2) return { error: "newSplit requires two links." };
    try {
      const sep = type.toLowerCase() === "vertical" ? "vsep" : "hsep";
      await openTrustedLinkIn(link1, "tab");
      const tab1 = gBrowser.selectedTab;
      await openTrustedLinkIn(link2, "tab");
      const tab2 = gBrowser.selectedTab;
      gZenViewSplitter.splitTabs([tab1, tab2], sep, 1);
      return {
        result: `Successfully created ${type} split view with the provided links.`,
      };
    } catch (e) {
      debugError("Failed to create split view.", e);
      return { error: "Failed to create split view." };
    }
  }

  // â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  // â”‚                        BOOKMARKS                        â”‚
  // â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

  /**
   * Searches bookmarks based on a query.
   * @param {object} args - The arguments object.
   * @param {string} args.query - The search term for bookmarks.
   * @returns {Promise<object>} A promise that resolves with an object containing an array of bookmark results or an error.
   */
  async function searchBookmarks(args) {
    const { query } = args;
    if (!query) return { error: "searchBookmarks requires a query." };

    try {
      const searchParams = { query };
      const bookmarks = await PlacesUtils.bookmarks.search(searchParams);

      // Map to a simpler format to save tokens for the AI model
      const results = bookmarks.map((bookmark) => ({
        id: bookmark.guid,
        title: bookmark.title,
        url: bookmark?.url?.href,
        parentID: bookmark.parentGuid,
      }));

      debugLog(`Found ${results.length} bookmarks for query "${query}":`, results);
      return { bookmarks: results };
    } catch (e) {
      debugError(`Error searching bookmarks for query "${query}":`, e);
      return { error: `Failed to search bookmarks.` };
    }
  }

  /**
   * Reads all bookmarks.
   * @returns {Promise<object>} A promise that resolves with an object containing an array of all bookmark results or an error.
   */

  async function getAllBookmarks() {
    try {
      const bookmarks = await PlacesUtils.bookmarks.search({});

      const results = bookmarks.map((bookmark) => ({
        id: bookmark.guid,
        title: bookmark.title,
        url: bookmark?.url?.href,
        parentID: bookmark.parentGuid,
      }));

      debugLog(`Read ${results.length} total bookmarks.`);
      return { bookmarks: results };
    } catch (e) {
      debugError(`Error reading all bookmarks:`, e);
      return { error: `Failed to read all bookmarks.` };
    }
  }

  /**
   * Creates a new bookmark.
   * @param {object} args - The arguments object.
   * @param {string} args.url - The URL to bookmark.
   * @param {string} [args.title] - The title for the bookmark. If not provided, the URL is used.
   * @param {string} [args.parentID] - The GUID of the parent folder. Defaults to the "Other Bookmarks" folder.
   * @returns {Promise<object>} A promise that resolves with a success message or an error.
   */
  async function createBookmark(args) {
    const { url, title, parentID } = args;
    if (!url) return { error: "createBookmark requires a URL." };

    try {
      const bookmarkInfo = {
        parentGuid: parentID || PlacesUtils.bookmarks.toolbarGuid,
        url: new URL(url),
        title: title || url,
      };

      const bm = await PlacesUtils.bookmarks.insert(bookmarkInfo);

      debugLog(`Bookmark created successfully:`, JSON.stringify(bm));
      return { result: `Successfully bookmarked "${bm.title}".` };
    } catch (e) {
      debugError(`Error creating bookmark for URL "${url}":`, e);
      return { error: `Failed to create bookmark.` };
    }
  }

  /**
   * Creates a new bookmark folder.
   * @param {object} args - The arguments object.
   * @param {string} args.title - The title for the new folder.
   * @param {string} [args.parentID] - The GUID of the parent folder. Defaults to the "Other Bookmarks" folder.
   * @returns {Promise<object>} A promise that resolves with a success message or an error.
   */
  async function addBookmarkFolder(args) {
    const { title, parentID } = args;
    if (!title) return { error: "addBookmarkFolder requires a title." };

    try {
      const folderInfo = {
        parentGuid: parentID || PlacesUtils.bookmarks.toolbarGuid,
        type: PlacesUtils.bookmarks.TYPE_FOLDER,
        title: title,
      };

      const folder = await PlacesUtils.bookmarks.insert(folderInfo);

      debugLog(`Bookmark folder created successfully:`, JSON.stringify(folderInfo));
      return { result: `Successfully created folder "${folder.title}".` };
    } catch (e) {
      debugError(`Error creating bookmark folder "${title}":`, e);
      return { error: `Failed to create folder.` };
    }
  }

  /**
   * Updates an existing bookmark.
   * @param {object} args - The arguments object.
   * @param {string} args.id - The GUID of the bookmark to update.
   * @param {string} [args.url] - The new URL for the bookmark.
   * @param {string} [args.parentID] - parent id
   *
   * @param {string} [args.title] - The new title for the bookmark.
   * @returns {Promise<object>} A promise that resolves with a success message or an error.
   */
  async function updateBookmark(args) {
    const { id, url, title, parentID } = args;
    if (!id) return { error: "updateBookmark requires a bookmark id (guid)." };
    if (!url && !title && !parentID)
      return {
        error: "updateBookmark requires either a new url, title, or parentID.",
      };

    try {
      const oldBookmark = await PlacesUtils.bookmarks.fetch(id);
      if (!oldBookmark) {
        return { error: `No bookmark found with id "${id}".` };
      }

      const bm = await PlacesUtils.bookmarks.update({
        guid: id,
        url: url ? new URL(url) : oldBookmark.url,
        title: title || oldBookmark.title,
        parentGuid: parentID || oldBookmark.parentGuid,
      });

      debugLog(`Bookmark updated successfully:`, JSON.stringify(bm));
      return { result: `Successfully updated bookmark to "${bm.title}".` };
    } catch (e) {
      debugError(`Error updating bookmark with id "${id}":`, e);
      return { error: `Failed to update bookmark.` };
    }
  }

  /**
   * Deletes a bookmark.
   * @param {object} args - The arguments object.
   * @param {string} args.id - The GUID of the bookmark to delete.
   * @returns {Promise<object>} A promise that resolves with a success message or an error.
   */

  async function deleteBookmark(args) {
    const { id } = args;
    if (!id) return { error: "deleteBookmark requires a bookmark id (guid)." };
    try {
      await PlacesUtils.bookmarks.remove(id);
      debugLog(`Bookmark with id "${id}" deleted successfully.`);
      return { result: `Successfully deleted bookmark.` };
    } catch (e) {
      debugError(`Error deleting bookmark with id "${id}":`, e);
      return { error: `Failed to delete bookmark.` };
    }
  }

  // â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  // â”‚                         ELEMENTS                        â”‚
  // â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

  /**
   * Clicks an element on the page.
   * @param {object} args - The arguments object.
   * @param {string} args.selector - The CSS selector of the element to click.
   * @returns {Promise<object>} A promise that resolves with a success message or an error.
   */
  async function clickElement(args) {
    const { selector } = args;
    if (!selector) return { error: "clickElement requires a selector." };
    return messageManagerAPI.clickElement(selector);
  }

  /**
   * Fills a form input on the page.
   * @param {object} args - The arguments object.
   * @param {string} args.selector - The CSS selector of the input element to fill.
   * @param {string} args.value - The value to fill the input with.
   * @returns {Promise<object>} A promise that resolves with a success message or an error.
   */
  async function fillForm(args) {
    const { selector, value } = args;
    if (!selector) return { error: "fillForm requires a selector." };
    if (value === undefined) return { error: "fillForm requires a value." };
    return messageManagerAPI.fillForm(selector, value);
  }

  const toolSet = {
    search: createTool(
      "search",
      "Performs a web search using a specified search engine and opens the results.",
      {
        searchTerm: createStringParameter("The term to search for."),
        engineName: createStringParameter("The name of the search engine to use.", true),
        where: createStringParameter(
          "Where to open results. Options: 'current tab', 'new tab', 'new window', 'incognito', 'glance', 'vsplit', 'hsplit'. Default: 'new tab'.",
          true
        ),
      },
      search
    ),
    openLink: createTool(
      "openLink",
      "Opens a given URL in a specified location. Can also create a split view with the current tab.",
      {
        link: createStringParameter("The URL to open."),
        where: createStringParameter(
          "Where to open the link. Options: 'current tab', 'new tab', 'new window', 'incognito', 'glance', 'vsplit', 'hsplit'. Default: 'new tab'.",
          true
        ),
      },
      openLink
    ),
    newSplit: createTool(
      "newSplit",
      "Creates a split view by opening two new URLs in two new tabs, then arranging them side-by-side.",
      {
        link1: createStringParameter("The URL for the first new tab."),
        link2: createStringParameter("The URL for the second new tab."),
        type: createStringParameter(
          "The split type: 'horizontal' or 'vertical'. Defaults to 'vertical'.",
          true
        ),
      },
      newSplit
    ),
    getPageTextContent: createTool(
      "getPageTextContent",
      "Retrieves the text content of the current web page to answer questions if the initial context is insufficient.",
      {},
      messageManagerAPI.getPageTextContent.bind(messageManagerAPI)
    ),
    getHTMLContent: createTool(
      "getHTMLContent",
      "Retrieves the full HTML source of the current web page for detailed analysis. Use this tool very rarely, only when text content is insufficient.",
      {},
      messageManagerAPI.getHTMLContent.bind(messageManagerAPI)
    ),
    getYoutubeTranscript: createTool(
      "getYoutubeTranscript",
      "Retrives the transcript of the current youtube video. Only use if current page is a youtube video.",
      {},
      messageManagerAPI.getYoutubeTranscript.bind(messageManagerAPI)
    ),
    searchBookmarks: createTool(
      "searchBookmarks",
      "Searches bookmarks based on a query.",
      {
        query: createStringParameter("The search term for bookmarks."),
      },
      searchBookmarks
    ),
    getAllBookmarks: createTool("getAllBookmarks", "Retrieves all bookmarks.", {}, getAllBookmarks),
    createBookmark: createTool(
      "createBookmark",
      "Creates a new bookmark.",
      {
        url: createStringParameter("The URL to bookmark."),
        title: createStringParameter("The title for the bookmark.", true),
        parentID: createStringParameter("The GUID of the parent folder.", true),
      },
      createBookmark
    ),
    addBookmarkFolder: createTool(
      "addBookmarkFolder",
      "Creates a new bookmark folder.",
      {
        title: createStringParameter("The title for the new folder."),
        parentID: createStringParameter("The GUID of the parent folder.", true),
      },
      addBookmarkFolder
    ),
    updateBookmark: createTool(
      "updateBookmark",
      "Updates an existing bookmark.",
      {
        id: createStringParameter("The GUID of the bookmark to update."),
        url: createStringParameter("The new URL for the bookmark.", true),
        title: createStringParameter("The new title for the bookmark.", true),
        parentID: createStringParameter("The GUID of the parent folder.", true),
      },
      updateBookmark
    ),
    deleteBookmark: createTool(
      "deleteBookmark",
      "Deletes a bookmark.",
      {
        id: createStringParameter("The GUID of the bookmark to delete."),
      },
      deleteBookmark
    ),
    clickElement: createTool(
      "clickElement",
      "Clicks an element on the page.",
      {
        selector: createStringParameter("The CSS selector of the element to click."),
      },
      clickElement
    ),
    fillForm: createTool(
      "fillForm",
      "Fills a form input on the page.",
      {
        selector: createStringParameter("The CSS selector of the input element to fill."),
        value: createStringParameter("The value to fill the input with."),
      },
      fillForm
    ),
  };

  const getToolSystemPrompt = async () => {
    try {
      const searchEngines = await Services.search.getVisibleEngines();
      const engineNames = searchEngines.map((e) => e.name).join(", ");
      const defaultEngineName = Services.search.defaultEngine.name;
      return `
- When asked about your own abilities, describe the functions you can perform based on the tools listed below.

## GOD MODE ENABLED - TOOL USAGE:
You have access to browser functions. The user knows you have these abilities.
- **CRITICAL**: When you decide to call a tool, give short summary of what tool are you calling and why?
- Use tools when the user explicitly asks, or when it is the only logical way to fulfill their request (e.g., "search for...").

## Available Tools:
- \`search(searchTerm, engineName, where)\`: Performs a web search. Available engines: ${engineNames}. The default is '${defaultEngineName}'.
- \`openLink(link, where)\`: Opens a URL. Use this to open a single link or to create a split view with the *current* tab.
- \`newSplit(link1, link2, type)\`: Use this specifically for creating a split view with *two new tabs*.
- \`getPageTextContent()\` / \`getHTMLContent()\`: Use these to get updated page information if context is missing. Prefer \`getPageTextContent\`.
- \`searchBookmarks(query)\`: Searches your bookmarks for a specific query.
- \`getAllBookmarks()\`: Retrieves all of your bookmarks.
- \`createBookmark(url, title, parentID)\`: Creates a new bookmark.  The \`parentID\` is optional and should be the GUID of the parent folder. Defaults to the "Bookmarks Toolbar" folder which has GUID: \`PlacesUtils.bookmarks.toolbarGuid\`.
- \`addBookmarkFolder(title, parentID)\`: Creates a new bookmark folder. The \`parentID\` is optional and should be the GUID of the parent folder. Defaults to the "Bookmarks Toolbar" folder which has GUID: \`PlacesUtils.bookmarks.toolbarGuid\`.
- \`updateBookmark(id, url, title, parentID)\`: Updates an existing bookmark.  The \`id\` is the GUID of the bookmark.  You must provide the ID and either a new URL or a new title or new parentID (or any one or two).
- \`deleteBookmark(id)\`: Deletes a bookmark.  The \`id\` is the GUID of the bookmark.
- \`clickElement(selector)\`: Clicks an element on the page.
- \`fillForm(selector, value)\`: Fills a form input on the page.

## More instructions for Running tools
- While running tool like \`openLink\` and \`newSplit\` make sure URL is valid.
- User will provide URL and title of current of webpage. If you need more context, use the \`getPageTextContent\` or \`getHTMLContent\` tools.
- When the user asks you to "read the current page", use the \`getPageTextContent()\` or \`getHTMLContent\` tool.
- If the user asks you to open a link by its text (e.g., "click the 'About Us' link"), you must first use \`getHTMLContent()\` to find the link's full URL, then use \`openLink()\` to open it.

## Tool Call Examples:
Therse are just examples for you on how you can use tools calls, each example give you some concept, the concept is not specific to single tool.

### Use default value when user don't provides full information, If user don't provide default value you may ask and even give options if possible
#### Searching the Web: 
-   **User Prompt:** "search for firefox themes"
-   **Your Tool Call:** \`{"functionCall": {"name": "search", "args": {"searchTerm": "firefox themes", "engineName": "${defaultEngineName}"}}}\`

### Make sure you are calling tools with correct parameters.
#### Opening a Single Link:
-   **User Prompt:** "open github"
-   **Your Tool Call:** \`{"functionCall": {"name": "openLink", "args": {"link": "https://github.com", "where": "new tab"}}}\`

#### Creating a Split View with Two New Pages:
-   **User Prompt:** "show me youtube and twitch side by side"
-   **Your Tool Call:** \`{"functionCall": {"name": "newSplit", "args": {"link1": "https://youtube.com", "link2": "https://twitch.tv"}}}\`

### Use tools to get more context: If user ask anything whose answer is unknown to you and it can be obtained via tool call use it.
#### Reading the Current Page for Context
-   **User Prompt:** "summarize this page for me"
-   **Your Tool Call:** \`{"functionCall": {"name": "getPageTextContent", "args": {}}}\`

### Taking multiple steps; you might need for previous tool to compete and give you output before calling next tool
#### Finding and Clicking a Link on the Current Page
-   **User Prompt:** "click on the contact link"
-   **Your First Tool Call:** \`{"functionCall": {"name": "getHTMLContent", "args": {}}}\`
-   **Your Second Tool Call (after receiving HTML and finding the link):** \`{"functionCall": {"name": "openLink", "args": {"link": "https://example.com/contact-us"}}}\`

#### Finding and Editing a bookmark by folder name:
-   **User Prompt:** "Move bookmark titled 'Example' to folder 'MyFolder'"
-   **Your First Tool Call:** \`{"functionCall": {"name": "searchBookmarks", "args": {"query": "Example"}}}\`
-   **Your Second Tool Call:** \`{"functionCall": {"name": "searchBookmarks", "args": {"query": "MyFolder"}}}\`
-   **Your Third Tool Call (after receiving the bookmark and folder ids):** \`{"functionCall": {"name": "updateBookmark", "args": {"id": "xxxxxxxxxxxx", "parentID": "yyyyyyyyyyyy"}}}\`
Note that first and second tool clls can be made in parallel, but the third tool call needs output from the first and second tool calls so it must be made after first and second.

#### Filling a form:
-   **User Prompt:** "Fill the name with John and submit"
-   **Your First Tool Call:** \`{"functionCall": {"name": "getHTMLContent", "args": {}}}\`
-   **Your Second Tool Call:** \`{"functionCall": {"name": "fillForm", "args": {"selector": "#name", "value": "John"}}}\`
-   **Your Third Tool Call:** \`{"functionCall": {"name": "clickElement", "args": {"selector": "#submit-button"}}}\`

### Calling multiple tools at once.
#### Making 2 searches in split 
-   **User Prompt:** "Search for Japan in google and search for America in Youtube. Open them in vertical split."
-   **Your First Tool Call:** \`{"functionCall": {"name": "search", "args": {"searchTerm": "Japan", "engineName": "Google", "where": "new tab"}}}\`
-   **Your Second Tool Call:** \`{"functionCall": {"name": "search", "args": {"searchTerm": "America", "engineName": "Youtube", "where": "vsplit"}}}\`

*(Available search engines: ${engineNames}. Default is '${defaultEngineName}'.)*
`;
    } catch (error) {
      debugError("Error in getToolSystemPrompt:", error);
      return "";
    }
  };

  const citationSchema = object$1({
    answer: string$1().describe("The conversational answer to the user's query."),
    citations: array(
        object$1({
          id: number$1()
            .describe(
              "Unique identifier for the citation, corresponding to the marker in the answer text."
            ),
          source_quote: string$1()
            .describe(
              "The exact, verbatim quote from the source text that supports the information."
            ),
        })
      )
      .describe("An array of citation objects from the source text."),
  });

  class LLM {
    constructor() {
      this.history = [];
      this.systemInstruction = "";
      this.AVAILABLE_PROVIDERS = {
        claude: claude,
        gemini: gemini,
        grok: grok,
        mistral: mistral,
        ollama: ollamaProvider,
        openai: openai,
        perplexity: perplexity,
      };
    }
    get godMode() {
      return PREFS.godMode;
    }
    get streamEnabled() {
      return PREFS.streamEnabled;
    }
    get citationsEnabled() {
      return PREFS.citationsEnabled;
    }
    get maxToolCalls() {
      return PREFS.maxToolCalls;
    }
    get llmProvider() {
      return PREFS.llmProvider;
    }

    get currentProvider() {
      return (
        this.AVAILABLE_PROVIDERS[this.llmProvider || "gemini"] || this.AVAILABLE_PROVIDERS["gemini"]
      );
    }
    setProvider(providerName) {
      if (this.AVAILABLE_PROVIDERS[providerName]) {
        PREFS.llmProvider = providerName;
        debugLog(`Switched LLM provider to: ${providerName}`);
      } else {
        debugError(`Provider "${providerName}" not found.`);
      }
    }
    async updateSystemPrompt() {
      debugLog("Updating system prompt...");
      const promptText = await this.getSystemPrompt();
      this.systemInstruction = promptText;
    }
    async getSystemPrompt() {
      let systemPrompt = `You are a helpful AI assistant integrated into Zen Browser, a minimal and modern fork of Firefox. Your primary purpose is to answer user questions based on the content of the current webpage.

## Your Instructions:
- Be concise, accurate, and helpful.`;

      if (this.godMode) {
        systemPrompt += await getToolSystemPrompt();
      }

      if (this.citationsEnabled) {
        systemPrompt += `

## Citation Instructions
- **Output Format**: Your entire response **MUST** be a single, valid JSON object with two keys: \`"answer"\` and \`"citations"\`.
- **Answer**: The \`"answer"\` key holds the conversational text. Use Markdown Syntax for formatting like lists, bolding, etc.
- **Citations**: The \`"citations"\` key holds an array of citation objects.
- **When to Cite**: For any statement of fact that is directly supported by the provided page content, you **SHOULD** provide a citation. It is not mandatory for every sentence.
- **How to Cite**: In your \`"answer"\`, append a marker like \`[1]\`, \`[2]\`. Each marker must correspond to a citation object in the array.
- **CRITICAL RULES FOR CITATIONS**:
    1.  **source_quote**: This MUST be the **exact, verbatim, and short** text from the page content.
    2.  **Accuracy**: The \`"source_quote"\` field must be identical to the text on the page, including punctuation and casing.
    3.  **Multiple Citations**: If multiple sources support one sentence, format them like \`[1][2]\`, not \`[1,2]\`.
    4.  **Unique IDs**: Each citation object **must** have a unique \`"id"\` that matches its marker in the answer text.
    5.  **Short**: The source quote must be short no longer than one sentence and should not contain line brakes.
- **Do Not Cite**: Do not cite your own abilities, general greetings, or information not from the provided text. Make sure the text is from page text content not from page title or URL.
- **Tool Calls**: If you call a tool, you **must not** provide citations in the same turn.

### Citation Examples

Here are some examples demonstrating the correct JSON output format.

**Example 1: General Question with a List and Multiple Citations**
-   **User Prompt:** "What are the main benefits of using this library?"
-   **Your JSON Response:**
    \`\`\`json
    {
      "answer": "This library offers several key benefits:\n\n*   **High Performance**: It is designed to be fast and efficient for large-scale data processing [1].\n*   **Flexibility**: You can integrate it with various frontend frameworks [2].\n*   **Ease of Use**: The API is well-documented and simple to get started with [3].",
      "citations": [
        {
          "id": 1,
          "source_quote": "The new architecture provides significant performance gains, especially for large-scale data processing."
        },
        {
          "id": 2,
          "source_quote": "It is framework-agnostic, offering adapters for React, Vue, and Svelte."
        },
        {
          "id": 3,
          "source_quote": "Our extensive documentation and simple API make getting started a breeze."
        }
      ]
    }
    \`\`\`

**Example 2: A Sentence Supported by Two Different Sources**
-   **User Prompt:** "Tell me about the project's history."
-   **Your JSON Response:**
    \`\`\`json
    {
      "answer": "The project was initially created in 2021 [1] and later became open-source in 2022 [2].",
      "citations": [
        {
          "id": 1,
          "source_quote": "Development began on the initial prototype in early 2021."
        },
        {
          "id": 2,
          "source_quote": "We are proud to announce that as of September 2022, the project is fully open-source."
        }
      ]
    }
    \`\`\`

**Example 3: The WRONG way (What NOT to do)**
This is incorrect because it uses one citation \`[1]\` for three different facts. This is lazy and unhelpful.
-   **Your JSON Response (Incorrect):**
    \`\`\`json
    {
      "answer": "This project is a toolkit for loading custom JavaScript into the browser [1]. Its main features include a modern UI [1] and an API for managing hotkeys and notifications [1].",
      "citations": [
        {
          "id": 1,
          "source_quote": "...a toolkit for loading custom JavaScript... It has features like a modern UI... provides an API for hotkeys and notifications..."
        }
      ]
    }
    \`\`\`

**Example 4: The WRONG way (What NOT to do)**
This is incorrect because it uses one citation same id for all facts.
\`\`\`json
{
  "answer": "Novel is a Notion-style WYSIWYG editor with AI-powered autocompletion [1]. It is built with Tiptap and Vercel AI SDK [1]. You can install it using npm [1]. Features include a slash menu, bubble menu, AI autocomplete, and image uploads [1].",
  "citations": [
    {
      "id": 1,
      "source_quote": "Novel is a Notion-style WYSIWYG editor with AI-powered autocompletion."
    },
    {
      "id": 1,
      "source_quote": "Built with Tiptap + Vercel AI SDK."
    },
    {
      "id": 1,
      "source_quote": "Installation npm i novel"
    },
    {
      "id": 1,
      "source_quote": "Features Slash menu & bubble menu AI autocomplete (type ++ to activate, or select from slash menu) Image uploads (drag & drop / copy & paste, or select from slash menu)"
    }
  ]
}
\`\`\`

**Example 5: The correct format of previous example**
This example is correct, note that it contain unique \`id\`, and each in text citation match to each citation \`id\`.
\`\`\`json
{
  "answer": "Novel is a Notion-style WYSIWYG editor with AI-powered autocompletion [1]. It is built with Tiptap and Vercel AI SDK [2]. You can install it using npm [3]. Features include a slash menu, bubble menu, AI autocomplete, and image uploads [4].",
  "citations": [
    {
      "id": 1,
      "source_quote": "Novel is a Notion-style WYSIWYG editor with AI-powered autocompletion."
    },
    {
      "id": 2,
      "source_quote": "Built with Tiptap + Vercel AI SDK."
    },
    {
      "id": 3,
      "source_quote": "Installation npm i novel"
    },
    {
      "id": 4,
      "source_quote": "Features Slash menu & bubble menu AI autocomplete (type ++ to activate, or select from slash menu) Image uploads (drag & drop / copy & paste, or select from slash menu)"
    }
  ]
}
\`\`\`
`;
      }

      if (!this.godMode) {
        systemPrompt += `
- Strictly base all your answers on the webpage content provided below.
- If the user's question cannot be answered from the content, state that the information is not available on the page.

Here is the initial info about the current page:
`;
        const pageContext = await messageManagerAPI.getPageTextContent(!this.citationsEnabled);
        systemPrompt += JSON.stringify(pageContext);
      }
      // debugLog("Final System Prompt:", systemPrompt);
      return systemPrompt;
    }
    parseModelResponseText(responseText) {
      let answer = responseText;
      let citations = [];

      if (PREFS.citationsEnabled) {
        try {
          // Find the JSON part of the response
          const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/);
          const jsonString = jsonMatch ? jsonMatch[1] : responseText;
          const parsedContent = JSON.parse(jsonString);

          if (typeof parsedContent.answer === "string") {
            answer = parsedContent.answer;
            if (Array.isArray(parsedContent.citations)) {
              citations = parsedContent.citations;
            }
          } else {
            // Parsed JSON but 'answer' field is missing or not a string.
            debugLog("AI response JSON missing 'answer' field or not a string:", parsedContent);
          }
        } catch (e) {
          // JSON parsing failed, keep rawText as answer.
          debugError("Failed to parse AI message content as JSON:", e, "Raw Text:", responseText);
        }
      }
      return { answer, citations };
    }

    async sendMessage(prompt, abortSignal) {
      await this.updateSystemPrompt();

      this.history.push({ role: "user", content: prompt });
      debugLog("Current history before sending:", this.history);

      const model = this.currentProvider.getModel();
      debugLog(`Using provider: ${this.currentProvider.name}, model: ${this.currentProvider.model}`);
      // debugLog("System instruction for this call:", this.systemInstruction);

      // Citation Mode using generateObject (non-streaming)
      if (this.citationsEnabled) {
        const { object } = await generateObject({
          model,
          schema: citationSchema,
          system: this.systemInstruction,
          messages: this.history,
          abortSignal,
        });

        // Manually add the assistant's structured response to the history
        this.history.push({ role: "assistant", content: JSON.stringify(object) });

        if (browseBotFindbar?.findbar && this.persistChat) {
          browseBotFindbar.findbar.history = this.getHistory();
        }

        return object;
      }

      const commonConfig = {
        model,
        system: this.systemInstruction,
        messages: this.history,
        tools: this.godMode ? toolSet : undefined,
        maxSteps: this.godMode ? this.maxToolCalls : 1,
        abortSignal,
      };

      // Non-Citation Mode (Streaming or Non-Streaming)
      if (this.streamEnabled) {
        const self = this;
        return streamText({
          ...commonConfig,
          async onFinish({ response }) {
            llm.history.push(...response.messages);
            if (browseBotFindbar?.findbar && self.persistChat) {
              browseBotFindbar.findbar.history = llm.getHistory();
            }
          },
        });
      } else {
        const result = await generateText(commonConfig);
        this.history.push(...result.response.messages);
        if (browseBotFindbar?.findbar && this.persistChat) {
          browseBotFindbar.findbar.history = this.getHistory();
        }
        return result;
      }
    }
    getHistory() {
      return [...this.history];
    }
    clearData() {
      debugLog("Clearing LLM history and system prompt.");
      this.history = [];
      this.systemInstruction = "";
    }
    getLastMessage() {
      return this.history.length > 0 ? this.history[this.history.length - 1] : null;
    }
  }

  const llm = new LLM();
  window.browseBotFindabrLLM = llm;

  const parseElement = (elementString, type = "html") => {
    if (type === "xul") {
      return window.MozXULElement.parseXULToFragment(elementString).firstChild;
    }

    let element = new DOMParser().parseFromString(elementString, "text/html");
    if (element.body.children.length) element = element.body.firstChild;
    else element = element.head.firstChild;
    return element;
  };

  const escapeXmlAttribute = (str) => {
    if (typeof str !== "string") return str;
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&apos;");
  };

  const SettingsModal = {
    _modalElement: null,
    _currentPrefValues: {},

    _getSafeIdForProvider(providerName) {
      return providerName.replace(/\./g, "-");
    },

    createModalElement() {
      const settingsHtml = this._generateSettingsHtml();
      const container = parseElement(settingsHtml);
      this._modalElement = container;

      const providerOptionsXUL = Object.entries(llm.AVAILABLE_PROVIDERS)
        .map(
          ([name, provider]) =>
            `<menuitem
            value="${name}"
            label="${escapeXmlAttribute(provider.label)}"
            ${name === PREFS.llmProvider ? 'selected="true"' : ""}
            ${provider.faviconUrl ? `image="${escapeXmlAttribute(provider.faviconUrl)}"` : ""}
          />`
        )
        .join("");

      const menulistXul = `
      <menulist id="pref-llm-provider" data-pref="${PREFS.LLM_PROVIDER}" value="${PREFS.llmProvider}">
        <menupopup>
          ${providerOptionsXUL}
        </menupopup>
      </menulist>`;

      const providerSelectorXulElement = parseElement(menulistXul, "xul");
      const placeholder = this._modalElement.querySelector("#llm-provider-selector-placeholder");
      if (placeholder) {
        placeholder.replaceWith(providerSelectorXulElement);
      }

      const positionOptions = {
        "top-left": "Top Left",
        "top-right": "Top Right",
        "bottom-left": "Bottom Left",
        "bottom-right": "Bottom Right",
      };
      const positionOptionsXUL = Object.entries(positionOptions)
        .map(
          ([value, label]) =>
            `<menuitem
            value="${value}"
            label="${escapeXmlAttribute(label)}"
            ${value === PREFS.position ? 'selected="true"' : ""}
          />`
        )
        .join("");

      const positionMenulistXul = `
      <menulist id="pref-position" data-pref="${PREFS.POSITION}" value="${PREFS.position}">
        <menupopup>
          ${positionOptionsXUL}
        </menupopup>
      </menulist>`;
      const positionSelectorXulElement = parseElement(positionMenulistXul, "xul");
      const positionPlaceholder = this._modalElement.querySelector("#position-selector-placeholder");

      if (positionPlaceholder) {
        positionPlaceholder.replaceWith(positionSelectorXulElement);
      }

      for (const [name, provider] of Object.entries(llm.AVAILABLE_PROVIDERS)) {
        const modelPrefKey = provider.modelPref;
        const currentModel = provider.model;

        const modelOptionsXUL = provider.AVAILABLE_MODELS.map(
          (model) =>
            `<menuitem
              value="${model}"
              label="${escapeXmlAttribute(provider.AVAILABLE_MODELS_LABELS[model] || model)}"
              ${model === currentModel ? 'selected="true"' : ""}
            />`
        ).join("");

        const modelMenulistXul = `
          <menulist id="pref-${this._getSafeIdForProvider(name)}-model" data-pref="${modelPrefKey}" value="${currentModel}">
            <menupopup>
              ${modelOptionsXUL}
            </menupopup>
          </menulist>`;

        const modelPlaceholder = this._modalElement.querySelector(
          `#llm-model-selector-placeholder-${this._getSafeIdForProvider(name)}`
        );
        if (modelPlaceholder) {
          const modelSelectorXulElement = parseElement(modelMenulistXul, "xul");
          modelPlaceholder.replaceWith(modelSelectorXulElement);
        }
      }

      this._attachEventListeners();
      return container;
    },

    _attachEventListeners() {
      if (!this._modalElement) return;

      // Close button
      this._modalElement.querySelector("#close-settings").addEventListener("click", () => {
        this.hide();
      });

      // Save button
      this._modalElement.querySelector("#save-settings").addEventListener("click", () => {
        this.saveSettings();
        this.hide();
        if (browseBotFindbar.enabled) browseBotFindbar.show();
        else browseBotFindbar.destroy();
      });

      this._modalElement.addEventListener("click", (e) => {
        if (e.target === this._modalElement) {
          this.hide();
        }
      });

      this._modalElement.querySelectorAll(".accordion-header").forEach((header) => {
        header.addEventListener("click", () => {
          const section = header.closest(".settings-accordion");
          const isExpanded = section.dataset.expanded === "true";
          section.dataset.expanded = isExpanded ? "false" : "true";
        });
      });

      // Initialize and listen to changes on controls (store in _currentPrefValues)
      this._modalElement.querySelectorAll("[data-pref]").forEach((control) => {
        const prefKey = control.dataset.pref;

        // Initialize control value from PREFS
        if (control.type === "checkbox") {
          control.checked = PREFS.getPref(prefKey);
        } else if (control.tagName.toLowerCase() === "menulist") {
          control.value = PREFS.getPref(prefKey);
        } else {
          control.value = PREFS.getPref(prefKey);
        }

        this._currentPrefValues[prefKey] = PREFS.getPref(prefKey);

        // Store changes in _currentPrefValues
        if (control.tagName.toLowerCase() === "menulist") {
          control.addEventListener("command", (e) => {
            this._currentPrefValues[prefKey] = e.target.value;
            debugLog(
              `Settings form value for ${prefKey} changed to: ${this._currentPrefValues[prefKey]}`
            );
            if (prefKey === PREFS.LLM_PROVIDER) {
              this._updateProviderSpecificSettings(
                this._modalElement,
                this._currentPrefValues[prefKey]
              );
            }
          });
        } else {
          control.addEventListener("change", (e) => {
            if (control.type === "checkbox") {
              this._currentPrefValues[prefKey] = e.target.checked;
            } else if (control.type === "number") {
              try {
                this._currentPrefValues[prefKey] = Number(e.target.value);
              } catch (error) {
                this._currentPrefValues[prefKey] = 0;
              }
            } else {
              this._currentPrefValues[prefKey] = e.target.value;
            }
            debugLog(
              `Settings form value for ${prefKey} changed to: ${this._currentPrefValues[prefKey]}`
            );
          });
        }
      });

      // Attach event listeners for API key links
      this._modalElement.querySelectorAll(".get-api-key-link").forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          const url = e.target.dataset.url;
          if (url) {
            openTrustedLinkIn(url, "tab");
            this.hide();
          }
        });
      });

      // Initial update for provider-specific settings display
      this._updateProviderSpecificSettings(this._modalElement, PREFS.llmProvider);
    },

    saveSettings() {
      for (const prefKey in this._currentPrefValues) {
        if (Object.prototype.hasOwnProperty.call(this._currentPrefValues, prefKey)) {
          if (prefKey.endsWith("api-key")) {
            if (this._currentPrefValues[prefKey]) {
              const maskedKey = "*".repeat(this._currentPrefValues[prefKey].length);
              debugLog(`Saving pref ${prefKey} to: ${maskedKey}`);
            }
          } else {
            debugLog(`Saving pref ${prefKey} to: ${this._currentPrefValues[prefKey]}`);
          }
          try {
            PREFS.setPref(prefKey, this._currentPrefValues[prefKey]);
          } catch (e) {
            debugError(`Error Saving pref for ${prefKey} ${e}`);
          }
        }
      }
      // Special case: If API key is empty after saving, ensure findbar is collapsed
      if (!llm.currentProvider.apiKey) {
        browseBotFindbar.expanded = false;
      }
    },

    show() {
      this.createModalElement();
      this._modalElement.querySelectorAll("[data-pref]").forEach((control) => {
        const prefKey = control.dataset.pref;
        if (control.type === "checkbox") {
          control.checked = PREFS.getPref(prefKey);
        } else {
          // For XUL menulist, ensure its value is set correctly on show
          if (control.tagName.toLowerCase() === "menulist") {
            control.value = PREFS.getPref(prefKey);
          } else {
            control.value = PREFS.getPref(prefKey);
          }
        }
        this._currentPrefValues[prefKey] = PREFS.getPref(prefKey);
      });
      this._updateProviderSpecificSettings(this._modalElement, PREFS.llmProvider);

      document.documentElement.appendChild(this._modalElement);
    },

    hide() {
      if (this._modalElement && this._modalElement.parentNode) {
        this._modalElement.remove();
      }
    },

    // Helper to show/hide provider-specific settings sections and update model dropdowns
    _updateProviderSpecificSettings(container, selectedProviderName) {
      container.querySelectorAll(".provider-settings-group").forEach((group) => {
        group.style.display = "none";
      });

      // Use the safe ID for the selector
      const activeGroup = container.querySelector(
        `#${this._getSafeIdForProvider(selectedProviderName)}-settings-group`
      );
      if (activeGroup) {
        activeGroup.style.display = "block";

        // Dynamically update the model dropdown for the active provider
        const modelPrefKey = PREFS[`${selectedProviderName.toUpperCase()}_MODEL`];
        if (modelPrefKey) {
          // Use the safe ID for the model selector as well
          const modelSelect = activeGroup.querySelector(
            `#pref-${this._getSafeIdForProvider(selectedProviderName)}-model`
          );
          if (modelSelect) {
            modelSelect.value = this._currentPrefValues[modelPrefKey] || PREFS.getPref(modelPrefKey);
          }
        }
        // Update the "Get API Key" link's state for the active provider
        const provider = llm.AVAILABLE_PROVIDERS[selectedProviderName];
        const getApiKeyLink = activeGroup.querySelector(".get-api-key-link");
        if (getApiKeyLink) {
          if (provider.apiKeyUrl) {
            getApiKeyLink.style.display = "inline-block";
            getApiKeyLink.dataset.url = provider.apiKeyUrl;
          } else {
            getApiKeyLink.style.display = "none";
            delete getApiKeyLink.dataset.url;
          }
        }
      }
    },

    _generateCheckboxSettingHtml(label, prefConstant) {
      const prefId = `pref-${prefConstant.toLowerCase().replace(/_/g, "-")}`;
      return `
      <div class="setting-item">
        <label for="${prefId}">${label}</label>
        <input type="checkbox" id="${prefId}" data-pref="${prefConstant}" />
      </div>
    `;
    },

    _createCheckboxSectionHtml(
      title,
      settingsArray,
      expanded = true,
      contentBefore = "",
      contentAfter = ""
    ) {
      const settingsHtml = settingsArray
        .map((s) => this._generateCheckboxSettingHtml(s.label, s.pref))
        .join("");
      return `
    <section class="settings-section settings-accordion" data-expanded="${expanded}" >
      <h4 class="accordion-header">${title}</h4>
      <div class="accordion-content">
        ${contentBefore}
        ${settingsHtml}
        ${contentAfter}
      </div>
    </section>
  `;
    },

    _generateSettingsHtml() {
      const generalSettings = [
        { label: "Enable AI Findbar", pref: PREFS.ENABLED },
        { label: "Minimal Mode (similar to arc)", pref: PREFS.MINIMAL },
        { label: "Persist Chat (don't persist when browser closes)", pref: PREFS.PERSIST },
        { label: "Debug Mode (logs in console)", pref: PREFS.DEBUG_MODE },
        { label: "Enable Drag and Drop", pref: PREFS.DND_ENABLED },
        { label: "Pseudo Background (for transparent Browsers)", pref: PREFS.PSEUDO_BG },
      ];
      const positionSelectorPlaceholderHtml = `
      <div class="setting-item">
        <label for="pref-position">Position</label>
        <div id="position-selector-placeholder"></div>
      </div>
    `;
      const generalSectionHtml = this._createCheckboxSectionHtml(
        "General",
        generalSettings,
        true,
        "",
        positionSelectorPlaceholderHtml
      );

      const aiBehaviorSettings = [
        { label: "Enable Citations", pref: PREFS.CITATIONS_ENABLED },
        { label: "Stream Response", pref: PREFS.STREAM_ENABLED },
        { label: "God Mode (AI can use tool calls)", pref: PREFS.GOD_MODE },
        { label: "Conformation before tool call", pref: PREFS.CONFORMATION },
      ];
      const aiBehaviorWarningHtml = `
      <div id="citations-god-mode-warning" class="warning-message" >
        Warning: Enabling both Citations and God Mode may lead to unexpected behavior or errors.
      </div>
    `;
      const maxToolCallsHtml = `
  <div class="setting-item">
    <label for="pref-max-tool-calls">Max Tool Calls (Maximum number of messages to send AI back to back)</label>
    <input type="number" id="pref-max-tool-calls" data-pref="${PREFS.MAX_TOOL_CALLS}" />
  </div>
`;

      const aiBehaviorSectionHtml = this._createCheckboxSectionHtml(
        "AI Behavior",
        aiBehaviorSettings,
        true,
        aiBehaviorWarningHtml,
        maxToolCallsHtml
      );

      // Context Menu Settings
      const contextMenuSettings = [
        { label: "Enable Context Menu (right click menu)", pref: PREFS.CONTEXT_MENU_ENABLED },
        {
          label: "Auto Send from Context Menu",
          pref: PREFS.CONTEXT_MENU_AUTOSEND,
        },
      ];
      const contextMenuSectionHtml = this._createCheckboxSectionHtml(
        "Context Menu",
        contextMenuSettings
      );

      const browserFindbarSettings = [
        { label: "Find as you Type", pref: "accessibility.typeaheadfind" },
        {
          label: "Enable sound (when word not found)",
          pref: "accessibility.typeaheadfind.enablesound",
        },
        { label: "Entire Word", pref: "findbar.entireword" },
        { label: "Highlight All", pref: "findbar.highlightAll" },
      ];
      const browserSettingsHtml = this._createCheckboxSectionHtml(
        "Browser Findbar",
        browserFindbarSettings,
        false
      );

      let llmProviderSettingsHtml = "";
      for (const [name, provider] of Object.entries(llm.AVAILABLE_PROVIDERS)) {
        const apiPrefKey = PREFS[`${name.toUpperCase()}_API_KEY`];
        const modelPrefKey = PREFS[`${name.toUpperCase()}_MODEL`];

        const apiInputHtml = apiPrefKey
          ? `
        <div class="setting-item">
          <label for="pref-${this._getSafeIdForProvider(name)}-api-key">API Key</label>
          <input type="password" id="pref-${this._getSafeIdForProvider(name)}-api-key" data-pref="${apiPrefKey}" placeholder="Enter ${provider.label} API Key" />
        </div>
      `
          : "";

        // Placeholder for the XUL menulist, which will be inserted dynamically in createModalElement
        const modelSelectPlaceholderHtml = modelPrefKey
          ? `
        <div class="setting-item">
          <label for="pref-${this._getSafeIdForProvider(name)}-model">Model</label>
          <div id="llm-model-selector-placeholder-${this._getSafeIdForProvider(name)}"></div>
        </div>
      `
          : "";

        llmProviderSettingsHtml += `
        <div id="${this._getSafeIdForProvider(name)}-settings-group" class="provider-settings-group">
          <div class="provider-header-group">
            <h5>${provider.label}</h5>
            <button class="get-api-key-link" data-url="${provider.apiKeyUrl || ""}" style="display: ${provider.apiKeyUrl ? "inline-block" : "none"};">Get API Key</button>
          </div>
          ${apiInputHtml}
          ${modelSelectPlaceholderHtml}
        </div>
      `;
      }

      const llmProvidersSectionHtml = `
      <section class="settings-section settings-accordion" data-expanded="false">
        <h4 class="accordion-header">LLM Providers</h4>
        <div class="setting-item accordion-content" class="">
          <label for="pref-llm-provider">Select Provider</label>
          <div id="llm-provider-selector-placeholder"></div>
        </div>
        ${llmProviderSettingsHtml}
      </section>`;

      return `
      <div id="ai-settings-modal-overlay">
        <div class="browse-bot-settings-modal">
          <div class="ai-settings-header">
            <h3>Settings</h3>
            <div>
              <button id="close-settings" class="settings-close-btn">Close</button>
              <button id="save-settings" class="settings-save-btn">Save</button>
            </div>
          </div>
          <div class="ai-settings-content">
            ${generalSectionHtml}
            ${aiBehaviorSectionHtml}
            ${contextMenuSectionHtml}
            ${llmProvidersSectionHtml}
            ${browserSettingsHtml}
          </div>
        </div>
      </div>
    `;
    },
  };

  const urlBarToolSet = Object.fromEntries(
    Object.entries(toolSet).map(([name, tool]) => {
      const newTool = { ...tool };
      if (tool.executeFn) {
        newTool.execute = tool.executeFn;
      }
      return [name, newTool];
    })
  );
  class UrlBarLLM extends LLM {
    async getSystemPrompt() {
      let systemPrompt = `You are an AI integrated with Zen Browser URL bar, designed to assist users in browsing the web effectively. 

Your primary responsibilities include:
1. Making tool calls in each response based on user input.
2. If the user does not provide specific commands, perform a search using the provided terms. You are permitted to correct any grammar or spelling mistakes and refine user queries for better accuracy.
3. If a URL is provided, open it directly.

Your goal is to ensure a seamless and user-friendly browsing experience.`;
      systemPrompt += await getToolSystemPrompt();
      return systemPrompt;
    }

    async sendMessage(prompt) {
      const model = this.currentProvider.getModel();
      debugLog(`urlBarLLM: Sending prompt: "${prompt}"`);
      await generateText({
        model,
        system: this.systemInstruction,
        prompt,
        tools: urlBarToolSet,
        maxSteps: this.maxToolCalls,
      });
    }
  }

  const urlBarLLM = new UrlBarLLM();
  window.browseBotURLBarLLM = urlBarLLM;

  const urlbarAI = {
    _isAIMode: false,
    _originalPlaceholder: "",
    _initialized: false,

    init() {
      debugLog("urlbarAI: Initializing");
      if (this._initialized) {
        debugLog("urlbarAI: Already initialized.");
        return;
      }
      this._originalPlaceholder = gURLBar.inputField.getAttribute("placeholder");
      this.addAskButton();
      this.addListeners();
      this._initialized = true;
      debugLog("urlbarAI: Initialization complete");
    },

    _closeUrlBar() {
      try {
        if (window.gZenUIManager && typeof window.gZenUIManager.handleUrlbarClose === "function") {
          window.gZenUIManager.handleUrlbarClose(false, false);
          return;
        }

        gURLBar.selectionStart = gURLBar.selectionEnd = 0;
        gURLBar.blur();

        if (gURLBar.view.isOpen) {
          gURLBar.view.close();
        }
      } catch (e) {
        debugError("urlbarAI: Error in _closeUrlBar", e);
      }
    },

    toggleAIMode(forceState) {
      const newState = typeof forceState === "boolean" ? forceState : !this._isAIMode;
      if (newState === this._isAIMode) return;

      debugLog(`urlbarAI: Toggling AI mode. Current: ${this._isAIMode}, New: ${newState}`);
      this._isAIMode = newState;

      if (this._isAIMode) {
        gURLBar.setAttribute("ai-mode-active", "true");
        gURLBar.inputField.setAttribute("placeholder", "Command to AI");
        gURLBar.startQuery();
      } else {
        gURLBar.removeAttribute("ai-mode-active");
        gURLBar.inputField.setAttribute("placeholder", this._originalPlaceholder);
        this._closeUrlBar();
        gURLBar.value = "";
      }
      debugLog(`urlbarAI: AI mode is now ${this._isAIMode ? "ON" : "OFF"}`);
    },

    handleGlobalKeyDown(e) {
      if (e.ctrlKey && e.code === "Space" && !e.altKey && !e.shiftKey) {
        debugLog("urlbarAI: Ctrl+Space detected globally");
        e.preventDefault();
        e.stopPropagation();
        gURLBar.focus();
        setTimeout(() => this.toggleAIMode(), 0);
      }
    },

    handleUrlbarKeyDown(e) {
      if (e.key === "Enter" && this._isAIMode) {
        debugLog("urlbarAI: Enter key pressed in AI mode");
        let isNavigational = false;
        if (gURLBar.view.isOpen && gURLBar.view.selectedResult) {
          const type = gURLBar?.view?.selectedResult?.type;
          if (type !== 2) isNavigational = true;
        }

        if (isNavigational) {
          debugLog("urlbarAI: Selected item is navigational, letting default action proceed.");
          return;
        }

        e.preventDefault();
        e.stopPropagation();
        this.send();
      }
    },

    addListeners() {
      debugLog("urlbarAI: Adding event listeners");
      this._boundHandleGlobalKeyDown = this.handleGlobalKeyDown.bind(this);
      this._boundHandleUrlbarKeyDown = this.handleUrlbarKeyDown.bind(this);
      this._boundDisableAIMode = () => {
        if (this._isAIMode) {
          debugLog("urlbarAI: Disabling AI mode due to blur or popup hide");
          this.toggleAIMode(false);
        }
      };

      document.addEventListener("keydown", this._boundHandleGlobalKeyDown, true);
      gURLBar.inputField.addEventListener("keydown", this._boundHandleUrlbarKeyDown, true);
      gURLBar.inputField.addEventListener("blur", this._boundDisableAIMode);
      gURLBar.view.panel.addEventListener("popuphiding", this._boundDisableAIMode);
    },

    send() {
      const prompt = gURLBar.value.trim();
      if (prompt) {
        debugLog(`URLbar: Sending prompt: "${prompt}"`);
        urlBarLLM.sendMessage(prompt);
      }
      this.toggleAIMode(false);
    },

    addAskButton() {
      debugLog("urlbarAI: Adding 'Ask' button");
      if (document.getElementById("urlbar-ask-ai-button")) {
        debugLog("urlbarAI: 'Ask' button already exists.");
        return;
      }

      const buttonString = `
      <toolbarbutton id="urlbar-ask-ai-button" class="urlbar-icon"
        image="chrome://global/skin/icons/highlights.svg" tooltiptext="Ask AI"/>
    `;
      const button = parseElement(buttonString, "xul");

      button.addEventListener("click", () => setTimeout(() => this.send(), 100));

      const insertButton = (retryCount = 0) => {
        const inputContainer = document.querySelector("#urlbar .urlbar-input-container");
        if (inputContainer) {
          inputContainer.appendChild(button);
          debugLog("urlbarAI: 'Ask' button added successfully to .urlbar-input-container");
        } else if (retryCount < 10) {
          debugError(
            `Could not find #urlbar .urlbar-input-container to add the 'Ask' button. Retrying in 500ms... (attempt ${
            retryCount + 1
          })`
          );
          setTimeout(() => insertButton(retryCount + 1), 500);
        } else {
          debugError(
            "Could not find #urlbar .urlbar-input-container after multiple attempts. Giving up."
          );
        }
      };

      insertButton();
    },
  };

  if (typeof UC_API !== "undefined" && UC_API.Runtime) {
    UC_API.Runtime.startupFinished().then(() => urlbarAI.init());
  } else {
    if (gBrowserInit.delayedStartupFinished) {
      urlbarAI.init();
    } else {
      let observer = new MutationObserver(() => {
        if (gBrowserInit.delayedStartupFinished) {
          urlbarAI.init();
          observer.disconnect();
        }
      });
      observer.observe(document.documentElement, { childList: true, subtree: true });
    }
  }

  var markdownStylesInjected = false;
  const injectMarkdownStyles = async () => {
    try {
      const { markedStyles } = await import(
        'chrome://userscripts/content/engine/assets/imports/marked.js'
      );
      const styleTag = parseElement(`<style>${markedStyles}</style>`);
      document.head.appendChild(styleTag);
      markdownStylesInjected = true;
      return true;
    } catch (e) {
      debugError(e);
      return false;
    }
  };

  const sidebarWidthUpdate = function () {
    const mainWindow = document.getElementById("main-window");
    const toolbox = document.getElementById("navigator-toolbox");

    function updateSidebarWidthIfCompact() {
      const isCompact = mainWindow.getAttribute("zen-compact-mode") === "true";
      if (!isCompact) return;

      const value = getComputedStyle(toolbox).getPropertyValue("--zen-sidebar-width");
      if (value) {
        mainWindow.style.setProperty("--zen-sidebar-width", value.trim());
      }
    }

    // Set up a MutationObserver to watch attribute changes on #main-window
    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type === "attributes" && mutation.attributeName === "zen-compact-mode") {
          updateSidebarWidthIfCompact();
        }
      }
    });

    // Observe attribute changes
    observer.observe(mainWindow, {
      attributes: true,
      attributeFilter: ["zen-compact-mode"],
    });

    // Optional: run it once in case the attribute is already set at load
    updateSidebarWidthIfCompact();
  };

  sidebarWidthUpdate();

  const getSidebarWidth = () => {
    if (
      gZenCompactModeManager &&
      !gZenCompactModeManager?.preference &&
      !gZenCompactModeManager.sidebarIsOnRight
    ) {
      return gZenCompactModeManager.getAndApplySidebarWidth();
    } else return 0;
  };

  function parseMD(markdown) {
    const markedOptions = { breaks: true, gfm: true };
    if (!markdownStylesInjected) {
      injectMarkdownStyles();
    }
    const content = window.marked ? window.marked.parse(markdown, markedOptions) : markdown;
    let htmlContent = parseElement(`<div class="markdown-body">${content}</div>`);

    return htmlContent;
  }

  PREFS.setInitialPrefs();
  const browseBotFindbar = {
    findbar: null,
    expandButton: null,
    chatContainer: null,
    apiKeyContainer: null,
    _updateFindbar: null,
    _addKeymaps: null,
    _handleInputKeyPress: null,
    _handleFindFieldInput: null,
    _isExpanded: false,
    _updateContextMenuText: null,
    _godModeListener: null,
    _citationsListener: null,
    _contextMenuEnabledListener: null,
    _persistListener: null,
    _minimalListener: null,
    _dndListener: null,
    contextMenuItem: null,
    _matchesObserver: null,
    _isDragging: false,
    _startDrag: null,
    _stopDrag: null,
    _handleDrag: null,
    _initialContainerCoor: { x: null, y: null },
    _initialMouseCoor: { x: null, y: null },
    _startWidth: null,
    _resizeHandle: null,
    _isResizing: false,
    _startResize: null,
    _stopResize: null,
    _handleResize: null,
    _handleResizeEnd: null,
    _toolConfirmationDialog: null,
    _highlightTimeout: null,

    _updateFindbarDimensions() {
      if (!this.findbar) {
        document.documentElement.style.removeProperty("--findbar-width");
        document.documentElement.style.removeProperty("--findbar-height");
        document.documentElement.style.removeProperty("--findbar-x");
        document.documentElement.style.removeProperty("--findbar-y");
        return;
      }
      const rect = this.findbar.getBoundingClientRect();
      const _findbarDimension = { width: rect.width, height: rect.height };
      const _findbarCoors = { x: rect.left, y: rect.top };
      document.documentElement.style.setProperty("--findbar-width", `${_findbarDimension.width}px`);
      document.documentElement.style.setProperty("--findbar-height", `${_findbarDimension.height}px`);
      document.documentElement.style.setProperty("--findbar-x", `${_findbarCoors.x}px`);
      document.documentElement.style.setProperty("--findbar-y", `${_findbarCoors.y}px`);
    },
    _isStreaming: false,
    _abortController: null,

    get expanded() {
      return this._isExpanded;
    },
    set expanded(value) {
      const isChanged = value !== this._isExpanded;
      this._isExpanded = value;
      if (!this.findbar) return;
      this.findbar.expanded = value;

      if (value) {
        this.findbar.classList.add("ai-expanded");
        this.show();
        this.showAIInterface();
        if (isChanged) this.focusPrompt();
        const messagesContainer = this?.chatContainer?.querySelector("#chat-messages");
        if (messagesContainer) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
      } else {
        if (this._isStreaming) {
          this._abortController?.abort();
        }
        this.findbar.classList.remove("ai-expanded");
        this.removeAIInterface();
        if (isChanged && !this.minimal) this.focusInput();
      }
      setTimeout(() => this._updateFindbarDimensions(), 0);
    },
    toggleExpanded() {
      this.expanded = !this.expanded;
    },

    get enabled() {
      return PREFS.enabled;
    },
    set enabled(value) {
      if (typeof value === "boolean") PREFS.enabled = value;
    },
    toggleEnabled() {
      this.enabled = !this.enabled;
    },
    handleEnabledChange(enabled) {
      if (enabled.value) this.init();
      else this.destroy();
    },

    get minimal() {
      return PREFS.minimal;
    },
    set minimal(value) {
      if (typeof value === "boolean") PREFS.minimal = value;
    },

    handleMinimalPrefChange: function () {
      this.removeExpandButton();
      this.addExpandButton();
      this.removeAIInterface();
      this.showAIInterface();
    },

    createToolConfirmationDialog(toolNames) {
      return new Promise((resolve) => {
        const dialog = parseElement(`
        <div class="tool-confirmation-dialog">
          <div class="tool-confirmation-content">
            <p>Allow the following tools to run: ${toolNames?.join(", ")}?</p>
            <div class="buttons">
              <button class="not-again">Don't ask again</button>
              <div class="right-side-buttons">
                <button class="confirm-tool">Yes</button>
                <button class="cancel-tool">No</button>
              </div>
            </div>
          </div>
        </div>
      `);
        this._toolConfirmationDialog = dialog;

        const removeDilog = () => {
          dialog.remove();
          this._toolConfirmationDialog = null;
        };

        const confirmButton = dialog.querySelector(".confirm-tool");
        confirmButton.addEventListener("click", () => {
          removeDilog();
          resolve(true);
        });

        const cancelButton = dialog.querySelector(".cancel-tool");
        cancelButton.addEventListener("click", () => {
          removeDilog();
          resolve(false);
        });

        const notAgainButton = dialog.querySelector(".not-again");
        notAgainButton.addEventListener("click", () => {
          removeDilog();
          PREFS.conformation = false;
          resolve(true);
        });

        document.body.appendChild(dialog);
      });
    },

    updateFindbar() {
      SettingsModal.hide();
      this.removeExpandButton();
      this.removeAIInterface();
      this.disableResize();
      if (!PREFS.persistChat) {
        this.hide();
        this.expanded = false;
        this.clear();
      }
      gBrowser.getFindBar().then((findbar) => {
        this.findbar = findbar;
        this.addExpandButton();
        if (PREFS.persistChat) {
          if (this?.findbar?.history) {
            llm.history = this.findbar.history;
            if (
              this?.findbar?.aiStatus &&
              JSON.stringify(this.aiStatus) !== JSON.stringify(this.findbar.aiStatus)
            ) {
              llm.history = [];
              this.findbar.history = [];
            }
          } else llm.history = [];
          if (this?.findbar?.expanded && !this?.findbar?.hidden) {
            setTimeout(() => (this.expanded = true), 200);
          } else {
            this.hide();
            this.expanded = false;
          }
        } else {
          this.hide();
          this.expanded = false;
        }
        this.updateFindbarStatus();
        setTimeout(() => {
          if (PREFS.dndEnabled) this.enableResize();
          this._updateFindbarDimensions();
        }, 0);
        setTimeout(() => this.updateFoundMatchesDisplay(), 0);
        this.findbar._findField.removeEventListener("keypress", this._handleInputKeyPress);
        this.findbar._findField.addEventListener("keypress", this._handleInputKeyPress);
        this.findbar._findField.removeEventListener("input", this._handleFindFieldInput);
        this.findbar._findField.addEventListener("input", this._handleFindFieldInput);

        const originalOnFindbarOpen = this.findbar.browser.finder.onFindbarOpen;
        const originalOnFindbarClose = this.findbar.browser.finder.onFindbarClose;

        //making sure this only runs one time
        if (!findbar?.openOverWritten) {
          //update placeholder when findbar is opened
          findbar.browser.finder.onFindbarOpen = (...args) => {
            originalOnFindbarOpen.apply(findbar.browser.finder, args); //making sure original function is called
            if (this.enabled) {
              debugLog("Findbar is being opened");
              setTimeout(
                () => (this.findbar._findField.placeholder = "Press Alt + Enter to ask AI"),
                100
              );
              this._updateFindbarDimensions();
            }
          };
          findbar.browser.finder.onFindbarClose = (...args) => {
            originalOnFindbarClose.apply(findbar.browser.finder, args);
            if (this.enabled) {
              debugLog("Findbar is being closed");

              if (this._isStreaming) {
                this._abortController?.abort();
              }
            }
          };
          findbar.openOverWritten = true;
        }
      });
    },

    highlight(word) {
      if (!this.findbar) return;

      // clear any existing timeout before starting a new one
      if (this._highlightTimeout) clearTimeout(this._highlightTimeout);

      this.findbar._find(word);

      this._highlightTimeout = setTimeout(() => {
        this.findbar.browser.finder.highlight(false);
        this._highlightTimeout = null; // cleanup
      }, 2000);
    },

    show() {
      if (!this.findbar) return false;
      this.findbar.open();
      this.focusInput();
      setTimeout(() => this._updateFindbarDimensions(), 0);
      return true;
    },
    hide() {
      if (!this.findbar) return false;
      this.findbar.close();
      this.findbar.toggleHighlight(false);
      setTimeout(() => this._updateFindbarDimensions(), 0);
      return true;
    },
    toggleVisibility() {
      if (!this.findbar) return;
      if (this.findbar.hidden) this.show();
      else this.hide();
    },

    clear() {
      llm.clearData();
      if (this.findbar) {
        this.findbar.history = null;
      }
      const messages = this?.chatContainer?.querySelector("#chat-messages");
      if (messages) messages.innerHTML = "";
      this._updateFindbarDimensions();
    },

    aiStatus: {
      citationsEnabled: PREFS.citationsEnabled,
      godMode: PREFS.godMode,
    },
    updateFindbarStatus() {
      this.aiStatus = {
        godMode: PREFS.godMode,
        citationsEnabled: PREFS.citationsEnabled,
      };
      if (this.findbar) this.findbar.aiStatus = this.aiStatus;
    },

    createAPIKeyInterface() {
      const currentProviderName = llm.currentProvider.name;
      const menuItems = Object.entries(llm.AVAILABLE_PROVIDERS)
        .map(
          ([name, provider]) => `
                  <menuitem
                    value="${name}"
                    label="${escapeXmlAttribute(provider.label)}"
                    ${name === currentProviderName ? 'selected="true"' : ""}
                    ${provider.faviconUrl ? `image="${escapeXmlAttribute(provider.faviconUrl)}"` : ""}
                  />
                `
        )
        .join("");

      const menulistXul = `
        <menulist id="provider-selector" class="provider-selector" value="${currentProviderName}">
          <menupopup>
            ${menuItems}
          </menupopup>
        </menulist>`;

      const providerSelectorXulElement = parseElement(menulistXul, "xul");

      const html = `
        <div class="browse-bot-setup">
          <div class="ai-setup-content">
            <h3>AI Setup Required</h3>
            <p>To use AI features, you need to set up your API key and select a provider. If it is Ollama set any value to API key(don't keep it empty).</p>
            <div class="provider-selection-group">
              <label for="provider-selector">Select Provider:</label>
            </div>
            <div class="api-key-input-group">
              <input type="password" id="api-key" placeholder="Enter your API key" />
              <button id="save-api-key">Save</button>
            </div>
            <div class="api-key-links">
              <button id="get-api-key-link">Get API Key</button>
            </div>
          </div>
        </div>`;
      const container = parseElement(html);

      const providerSelectionGroup = container.querySelector(".provider-selection-group");
      // Insert the XUL menulist after the label within the group
      providerSelectionGroup.appendChild(providerSelectorXulElement);

      const providerSelector = container.querySelector("#provider-selector");
      const input = container.querySelector("#api-key");
      const saveBtn = container.querySelector("#save-api-key");
      const getApiKeyLink = container.querySelector("#get-api-key-link");

      // Initialize the input and link based on the currently selected provider
      input.value = llm.currentProvider.apiKey || "";
      getApiKeyLink.disabled = !llm.currentProvider.apiKeyUrl;
      getApiKeyLink.title = llm.currentProvider.apiKeyUrl
        ? "Get API Key"
        : "No API key link available for this provider.";

      // Use 'command' event for XUL menulist
      providerSelector.addEventListener("command", (e) => {
        const selectedProviderName = e.target.value;
        llm.setProvider(selectedProviderName); // This also updates PREFS.llmProvider internally
        input.value = llm.currentProvider.apiKey || "";
        getApiKeyLink.disabled = !llm.currentProvider.apiKeyUrl;
        getApiKeyLink.title = llm.currentProvider.apiKeyUrl
          ? "Get API Key"
          : "No API key link available for this provider.";
      });

      getApiKeyLink.addEventListener("click", () => {
        openTrustedLinkIn(llm.currentProvider.apiKeyUrl, "tab");
      });

      saveBtn.addEventListener("click", () => {
        const key = input.value.trim();
        if (key) {
          llm.currentProvider.apiKey = key; // This also updates PREFS.mistralApiKey/geminiApiKey internally
          this.showAIInterface(); // Refresh UI after saving key
        }
      });
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter") saveBtn.click();
      });
      return container;
    },

    async sendMessage(prompt) {
      if (!prompt || this._isStreaming) return;

      this.show();
      this.expanded = true;

      // Add user message to the UI immediately
      this.addChatMessage({ role: "user", content: prompt });
      const messagesContainer = this.chatContainer.querySelector("#chat-messages");

      this._abortController = new AbortController();
      this._toggleStreamingControls(true);

      let aiMessageDiv;

      try {
        const resultPromise = llm.sendMessage(prompt, this._abortController.signal);

        if (PREFS.citationsEnabled || !PREFS.streamEnabled) {
          const loadingIndicator = this.createLoadingIndicator();
          if (messagesContainer) {
            messagesContainer.appendChild(loadingIndicator);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }

          try {
            const result = await resultPromise;
            if (PREFS.citationsEnabled) {
              this.addChatMessage({ role: "assistant", content: result });
            } else {
              this.addChatMessage({ role: "assistant", content: result.text });
            }
          } finally {
            loadingIndicator.remove();
          }
        } else {
          aiMessageDiv = parseElement(
            `<div class="chat-message chat-message-ai">
  <div class="message-content">
    <div class="markdown-body"></div>
  </div>
</div>`
          );
          const contentDiv = aiMessageDiv.querySelector(".markdown-body");
          aiMessageDiv.appendChild(contentDiv);

          if (messagesContainer) {
            messagesContainer.appendChild(aiMessageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }

          const result = await resultPromise;
          let fullText = "";
          for await (const delta of result.textStream) {
            fullText += delta;
            contentDiv.innerHTML = parseMD(fullText).innerHTML;
            this._updateFindbarDimensions();
            if (messagesContainer) {
              messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
          }
        }
      } catch (e) {
        if (e.name !== "AbortError") {
          debugError("Error sending message:", e);
          if (aiMessageDiv) aiMessageDiv.remove();
          this.addChatMessage({ role: "error", content: `Error: ${e.message}` });
        } else {
          debugLog("Streaming aborted by user.");
          if (aiMessageDiv) aiMessageDiv.remove();
        }
      } finally {
        this._toggleStreamingControls(false);
        this._abortController = null;
      }
    },

    _toggleStreamingControls(isStreaming) {
      this._isStreaming = isStreaming;
      if (!this.chatContainer) return;

      const sendBtn = this.chatContainer.querySelector("#send-prompt");
      const stopBtn = this.chatContainer.querySelector("#stop-generation");
      const promptInput = this.chatContainer.querySelector("#ai-prompt");

      if (isStreaming) {
        sendBtn.style.display = "none";
        stopBtn.style.display = "flex";
        promptInput.disabled = true;
      } else {
        sendBtn.style.display = "flex";
        stopBtn.style.display = "none";
        promptInput.disabled = false;
        this.focusPrompt();
      }
    },

    createChatInterface() {
      const chatInputGroup = `<div class="ai-chat-input-group">
          <textarea id="ai-prompt" placeholder="Ask AI anything..." rows="2"></textarea>
          <button id="send-prompt" class="send-btn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path fill="currentColor" d="M17.991 6.01L5.399 10.563l4.195 2.428l3.699-3.7a1 1 0 0 1 1.414 1.415l-3.7 3.7l2.43 4.194L17.99 6.01Zm.323-2.244c1.195-.433 2.353.725 1.92 1.92l-5.282 14.605c-.434 1.198-2.07 1.344-2.709.241l-3.217-5.558l-5.558-3.217c-1.103-.639-.957-2.275.241-2.709z" />
            </svg>
          </button>
          <button id="stop-generation" class="stop-btn" style="display: none;">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                  <path fill="currentColor" d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2m2 6h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2" />
              </svg>
          </button>
        </div>`;

      const container = parseElement(`
        <div class="browse-bot-chat">
          <div class="ai-chat-header">
            <div class="findbar-drag-handle"></div>
          </div>
          <div class="ai-chat-messages" id="chat-messages"></div>
          ${chatInputGroup}
        </div>`);

      const chatHeader = container.querySelector(".ai-chat-header");

      const clearBtn = parseElement(
        `
        <toolbarbutton 
          id="clear-chat" 
          class="clear-chat-btn" 
          image="chrome://global/skin/icons/delete.svg" 
          tooltiptext="Clear Chat"
        />`,
        "xul"
      );

      const settingsBtn = parseElement(
        `
        <toolbarbutton 
          id="open-settings-btn" 
          class="settings-btn" 
          image="chrome://global/skin/icons/settings.svg" 
          tooltiptext="Settings"
        />`,
        "xul"
      );

      const collapseBtn = parseElement(
        `
        <toolbarbutton 
          id="findbar-collapse-btn" 
          class="findbar-collapse-btn" 
          image="chrome://browser/skin/zen-icons/unpin.svg" 
          tooltiptext="Collapse"
        />`,
        "xul"
      );

      chatHeader.appendChild(clearBtn);
      chatHeader.appendChild(settingsBtn);
      chatHeader.appendChild(collapseBtn);

      const chatMessages = container.querySelector("#chat-messages");
      const promptInput = container.querySelector("#ai-prompt");
      const sendBtn = container.querySelector("#send-prompt");
      const stopBtn = container.querySelector("#stop-generation");

      const handleSend = () => {
        const prompt = promptInput.value.trim();
        this.sendMessage(prompt);
        promptInput.value = ""; // Clear input after sending
      };

      sendBtn.addEventListener("click", handleSend);
      stopBtn.addEventListener("click", () => {
        this._abortController?.abort();
      });

      promptInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          handleSend();
        }
      });

      clearBtn.addEventListener("click", () => {
        this.clear();
        this.expanded = false;
      });

      settingsBtn.addEventListener("click", () => {
        SettingsModal.show();
      });

      collapseBtn.addEventListener("click", () => {
        this.expanded = false;
      });

      chatMessages.addEventListener("click", async (e) => {
        if (e.target.classList.contains("citation-link")) {
          const button = e.target;
          const citationId = button.dataset.citationId;
          const messageEl = button.closest(".chat-message[data-citations]");

          if (messageEl) {
            const citations = JSON.parse(messageEl.dataset.citations);
            const citation = citations.find((c) => c.id == citationId);
            if (citation && citation.source_quote) {
              debugLog(
                `Citation [${citationId}] clicked. Requesting highlight for:`,
                citation.source_quote
              );
              this.highlight(citation.source_quote);
            }
          }
        } else if (e.target?.href) {
          e.preventDefault();
          try {
            openTrustedLinkIn(e.target.href, "tab");
          } catch (e) {}
        }
      });

      return container;
    },

    createLoadingIndicator() {
      const messageDiv = parseElement(`<div class="chat-message chat-message-loading"></div>`);
      const contentDiv = parseElement(`<div class="message-content">Loading...</div>`);
      messageDiv.appendChild(contentDiv);
      return messageDiv;
    },

    addChatMessage(message) {
      const { role, content } = message;
      if (!this.chatContainer || content === undefined || content === null) return;

      const messagesContainer = this.chatContainer.querySelector("#chat-messages");
      if (!messagesContainer) return;

      let type;
      switch (role) {
        case "user":
          type = "user";
          break;
        case "assistant":
          type = "ai";
          break;
        case "error":
          type = "error";
          break;
        default:
          return; // Don't display other roles like 'tool'
      }

      const messageDiv = parseElement(`<div class="chat-message chat-message-${type}"></div>`);
      const contentDiv = parseElement(`<div class="message-content"></div>`);

      if (role === "assistant" && typeof content === "object" && content.answer !== undefined) {
        // Case 1: Live response from generateObject for citations
        const { answer, citations } = content;
        if (citations && citations.length > 0) {
          messageDiv.dataset.citations = JSON.stringify(citations);
        }
        const textToParse = answer.replace(
          /\[(\d+)\]/g,
          `<button class="citation-link" data-citation-id="$1">[$1]</button>`
        );
        contentDiv.appendChild(parseMD(textToParse));
      } else {
        // Case 2: String content (from user, stream, generateText, or history)
        const textContent = typeof content === "string" ? content : (content[0]?.text ?? "");

        if (role === "assistant" && PREFS.citationsEnabled) {
          // Sub-case: Rendering historical assistant message in citation mode.
          // It's a string that needs to be parsed into answer/citations.
          const { answer, citations } = llm.parseModelResponseText(textContent);
          if (citations && citations.length > 0) {
            messageDiv.dataset.citations = JSON.stringify(citations);
          }
          const textToParse = answer.replace(
            /\[(\d+)\]/g,
            `<button class="citation-link" data-citation-id="$1">[$1]</button>`
          );
          contentDiv.appendChild(parseMD(textToParse));
        } else {
          // Sub-case: Simple string content
          contentDiv.appendChild(parseMD(textContent));
        }
      }

      messageDiv.appendChild(contentDiv);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      this._updateFindbarDimensions();
    },

    showAIInterface() {
      if (!this.findbar) return;
      this.removeAIInterface();

      this.findbar.classList.remove("ai-settings-active");

      if (!llm.currentProvider.apiKey) {
        this.apiKeyContainer = this.createAPIKeyInterface();
        this.findbar.insertBefore(this.apiKeyContainer, this.findbar.firstChild);
      } else {
        this.chatContainer = this.createChatInterface();
        if (PREFS.dndEnabled) this.enableDND();

        // Re-render history using the new message format
        const history = llm.getHistory();
        for (const message of history) {
          this.addChatMessage(message);
        }

        this.findbar.insertBefore(this.chatContainer, this.findbar.firstChild);
      }
      this._updateFindbarDimensions();
    },

    focusInput() {
      if (this.findbar) setTimeout(() => this.findbar._findField.focus(), 10);
    },
    focusPrompt() {
      const promptInput = this.chatContainer?.querySelector("#ai-prompt");
      if (promptInput) setTimeout(() => promptInput.focus(), 10);
    },
    setPromptText(text) {
      const promptInput = this?.chatContainer?.querySelector("#ai-prompt");
      if (promptInput && text) promptInput.value = text;
    },
    async setPromptTextFromSelection() {
      let text = "";
      const selection = await messageManagerAPI.getSelectedText();
      if (!selection || !selection.hasSelection) text = this?.findbar?._findField?.value;
      else text = selection.selectedText;
      this.setPromptText(text);
    },

    removeAIInterface() {
      if (this.apiKeyContainer) {
        this.apiKeyContainer.remove();
        this.apiKeyContainer = null;
      }
      if (this.chatContainer) {
        this.chatContainer.remove();
        this.chatContainer = null;
      }
    },

    init() {
      if (!this.enabled) return;
      this.updateFindbar();
      this.addListeners();
      if (PREFS.contextMenuEnabled) {
        this.addContextMenuItem();
      }
    },
    destroy() {
      this.findbar = null;
      this._updateFindbarDimensions();
      this.expanded = false;
      try {
        this.removeListeners();
      } catch {}
      this.removeExpandButton();
      this.removeContextMenuItem();
      this.removeAIInterface();
      this._toolConfirmationDialog?.remove();
      this._toolConfirmationDialog = null;
      SettingsModal.hide();
    },

    addExpandButton() {
      if (!this.findbar) return false;

      // Always remove both buttons before adding the correct one
      this.removeExpandButton();

      if (this.minimal) {
        const container = this.findbar.querySelector(".findbar-container");
        if (container && !container.querySelector("#findbar-ask")) {
          const askBtn = parseElement(`<button id="findbar-ask" anonid="findbar-ask">Ask</button>`);
          askBtn.addEventListener("click", () => {
            const inpText = this.findbar._findField.value.trim();
            this.sendMessage(inpText);
            this.findbar._findField.value = "";
            this.focusInput();
          });
          container.appendChild(askBtn);
          this.askButton = askBtn;
        }
      } else {
        const button_id = "findbar-expand";
        const button = parseElement(
          `<button id="${button_id}" anonid="${button_id}">Expand</button>`
        );
        button.addEventListener("click", () => this.toggleExpanded());
        button.textContent = "Expand";
        this.findbar.appendChild(button);
        this.expandButton = button;
      }
      return true;
    },

    removeExpandButton() {
      if (this.askButton) {
        this.askButton.remove();
        this.askButton = null;
      }
      if (this.expandButton) {
        this.expandButton.remove();
        this.expandButton = null;
      }
      return true;
    },

    handleInputKeyPress: function (e) {
      if (e?.key === "Enter" && e?.altKey) {
        e.preventDefault();
        const inpText = this.findbar._findField.value.trim();
        this.sendMessage(inpText);
        this.findbar._findField.value = "";
        this.focusInput();
      }
    },

    addContextMenuItem(retryCount = 0) {
      if (this.contextMenuItem) return; // Already added
      if (!PREFS.contextMenuEnabled) return;

      const contextMenu = document.getElementById("contentAreaContextMenu");

      if (!contextMenu) {
        if (retryCount < 5) {
          debugLog(`Context menu not found, retrying... (attempt ${retryCount + 1}/5)`);
          setTimeout(() => this.addContextMenuItem(retryCount + 1), 200);
        } else {
          debugError("Failed to add context menu item after 5 attempts: Context menu not found.");
        }
        return;
      }

      const menuItem = document.createXULElement("menuitem");
      menuItem.id = "browse-bot-context-menu-item";
      menuItem.setAttribute("label", "Ask AI");
      menuItem.setAttribute("accesskey", "A");

      menuItem.addEventListener("command", this.handleContextMenuClick.bind(this));
      this.contextMenuItem = menuItem;

      const searchSelectItem = contextMenu.querySelector("#context-searchselect");

      if (searchSelectItem) {
        // Insert right after the searchselect item
        if (searchSelectItem.nextSibling) {
          contextMenu.insertBefore(menuItem, searchSelectItem.nextSibling);
        } else {
          contextMenu.appendChild(menuItem);
        }
      } else {
        // Fallback: insert after context-sep-redo separator
        const redoSeparator = contextMenu.querySelector("#context-sep-redo");
        if (redoSeparator) {
          if (redoSeparator.nextSibling) {
            contextMenu.insertBefore(menuItem, redoSeparator.nextSibling);
          } else {
            contextMenu.appendChild(menuItem);
          }
        } else {
          // Final fallback: don't add the menu item if neither element is found
          return;
        }
      }

      this._updateContextMenuText = this.updateContextMenuText.bind(this);
      contextMenu.addEventListener("popupshowing", this._updateContextMenuText);
    },

    removeContextMenuItem: function () {
      this?.contextMenuItem?.remove();
      this.contextMenuItem = null;
      document
        ?.getElementById("contentAreaContextMenu")
        ?.removeEventListener("popupshowing", this._updateContextMenuText);
    },
    handleContextMenuClick: async function () {
      const selection = await messageManagerAPI.getSelectedText();
      let finalMessage = "";
      if (!selection.hasSelection) {
        finalMessage = "Summarize current page";
      } else {
        finalMessage += "Explain this in context of current page\n";
        const selectedTextFormatted = selection?.selectedText
          ?.split("\n")
          ?.map((line) => line.trim())
          ?.filter((line) => line.length > 0)
          ?.map((line) => "> " + line)
          ?.join("\n");

        finalMessage += selectedTextFormatted;
      }
      this.expanded = true;
      if (PREFS.contextMenuAutoSend) {
        this.sendMessage(finalMessage);
        this.focusPrompt();
      } else {
        this.setPromptText(finalMessage);
        this.show();
        this.focusPrompt();
      }
    },

    handleContextMenuPrefChange: function (pref) {
      if (pref.value) this.addContextMenuItem();
      else this.removeContextMenuItem();
    },
    updateContextMenuText() {
      if (!PREFS.contextMenuEnabled || !this.contextMenuItem) return;
      const hasSelection = gContextMenu?.isTextSelected === true;
      this.contextMenuItem.label = hasSelection ? "Ask AI" : "Summarize with AI";
    },

    enableResize() {
      if (!this.findbar || this._resizeHandle) return;
      const resizeHandle = parseElement(`<div class="findbar-resize-handle"></div>`);
      this.findbar.appendChild(resizeHandle);
      this._resizeHandle = resizeHandle;
      this._startResize = this.startResize.bind(this);
      this._resizeHandle.addEventListener("mousedown", this._startResize);
    },

    startResize(e) {
      if (e.button !== 0 || !this.findbar) return;
      this._isResizing = true;
      this._initialMouseCoor = { x: e.clientX, y: e.clientY };
      const rect = this.findbar.getBoundingClientRect();
      this.startWidth = rect.width;
      this._handleResize = this.doResize.bind(this);
      this._stopResize = this.stopResize.bind(this);
      document.addEventListener("mousemove", this._handleResize);
      document.addEventListener("mouseup", this._stopResize);
    },

    doResize(e) {
      if (!this._isResizing || !this.findbar) return;
      const minWidth = 300;
      const maxWidth = 800;
      const directionFactor = PREFS.position.includes("right") ? -1 : 1;
      let newWidth = this.startWidth + (e.clientX - this._initialMouseCoor.x) * directionFactor;
      newWidth = Math.min(Math.max(newWidth, minWidth), maxWidth);
      this.findbar.style.width = `${newWidth}px`;
      this._updateFindbarDimensions();
    },

    stopResize() {
      this._isResizing = false;
      document.removeEventListener("mousemove", this._handleResize);
      document.removeEventListener("mouseup", this._stopResize);
      this._handleResize = null;
      this._stopResize = null;
      this._updateFindbarDimensions();
    },
    disableResize() {
      this._resizeHandle?.remove();
      this._resizeHandle = null;
      this.stopResize();
    },

    startDrag(e) {
      if (!this.chatContainer || e.button !== 0) return;
      this._isDragging = true;
      this._initialMouseCoor = { x: e.clientX, y: e.clientY };
      const rect = this.findbar.getBoundingClientRect();
      this._initialContainerCoor = { x: rect.left, y: rect.top };
      this._handleDrag = this.doDrag.bind(this);
      this._stopDrag = this.stopDrag.bind(this);
      document.addEventListener("mousemove", this._handleDrag);
      document.addEventListener("mouseup", this._stopDrag);
    },

    doDrag(e) {
      if (!this._isDragging) return;
      const minCoors = { x: 15, y: 35 };
      const rect = this.findbar.getBoundingClientRect();
      const maxCoors = {
        x: window.innerWidth - rect.width - 33,
        y: window.innerHeight - rect.height - 33,
      };
      const newCoors = {
        x: this._initialContainerCoor.x + (e.clientX - this._initialMouseCoor.x),
        y: this._initialContainerCoor.y + (e.clientY - this._initialMouseCoor.y),
      };

      newCoors.x -= getSidebarWidth();
      newCoors.x = Math.max(minCoors.x, Math.min(newCoors.x, maxCoors.x));
      newCoors.y = Math.max(minCoors.y, Math.min(newCoors.y, maxCoors.y));
      this._updateFindbarDimensions();

      this.findbar.style.setProperty("left", `${newCoors.x}px`, "important");
      this.findbar.style.setProperty("top", `${newCoors.y}px`, "important");
      this.findbar.style.setProperty("right", "unset", "important");
      this.findbar.style.setProperty("bottom", "unset", "important");
    },

    stopDrag() {
      this._isDragging = false;
      this.findbar.style.setProperty("transition", "all 0.3s ease", "important");
      this.snapToClosestCorner();
      this._initialMouseCoor = { x: null, y: null };
      this._initialContainerCoor = { x: null, y: null };
      document.removeEventListener("mouseup", this._stopDrag);
      document.removeEventListener("mousemove", this._handleDrag);
      this._handleDrag = null;
      this._stopDrag = null;
      setTimeout(() => this._updateFindbarDimensions(), 0);
      setTimeout(() => this.findbar.style.removeProperty("transition"), 400);
    },

    snapToClosestCorner() {
      if (!this.findbar || !PREFS.dndEnabled) return;

      const rect = this.findbar.getBoundingClientRect();
      const currentX = rect.left;
      const currentY = rect.top;
      const findbarWidth = rect.width;
      const findbarHeight = rect.height;

      const snapPoints = {
        "top-left": { x: 0, y: 0 },
        "top-right": { x: window.innerWidth - findbarWidth, y: 0 },
        "bottom-left": { x: 0, y: window.innerHeight - findbarHeight },
        "bottom-right": {
          x: window.innerWidth - findbarWidth,
          y: window.innerHeight - findbarHeight,
        },
      };

      let closestPointName = PREFS.position;
      let minDistance = Infinity;

      for (const name in snapPoints) {
        const p = snapPoints[name];
        const distance = Math.sqrt(Math.pow(currentX - p.x, 2) + Math.pow(currentY - p.y, 2));

        if (distance < minDistance) {
          minDistance = distance;
          closestPointName = name;
        }
      }

      // Update preference if position changed
      if (closestPointName !== PREFS.position) {
        PREFS.position = closestPointName;
      }
      this.findbar.style.removeProperty("left");
      this.findbar.style.removeProperty("top");
      this.findbar.style.removeProperty("bottom");
      this.findbar.style.removeProperty("right");
      // this.applyFindbarPosition(closestPointName);
    },
    enableDND() {
      if (!this.chatContainer) return;
      const handle = this.chatContainer.querySelector(".findbar-drag-handle");
      if (!handle) return;
      this._startDrag = this.startDrag.bind(this);
      handle.addEventListener("mousedown", this._startDrag);
    },
    disableDND() {
      this._isDragging = false;
      if (!this.chatContainer) return;
      const handle = this.chatContainer.querySelector(".findbar-drag-handle");
      if (!handle) return;
      handle.removeEventListener("mousedown", this._startDrag);
      document.removeEventListener("mouseup", this._stopDrag);
      document.removeEventListener("mousemove", this._handleDrag);
      this._startDrag = null;
      this._stopDrag = null;
    },

    addKeymaps: function (e) {
      if (e.key && e.key.toLowerCase() === "f" && e.ctrlKey && e.shiftKey && !e.altKey) {
        e.preventDefault();
        e.stopPropagation();
        this.expanded = true;
        this.show();
        this.focusPrompt();
        this.setPromptTextFromSelection();
      }
      if (e.key?.toLowerCase() === "escape") {
        if (SettingsModal._modalElement && SettingsModal._modalElement.parentNode) {
          e.preventDefault();
          e.stopPropagation();
          SettingsModal.hide();
        } else if (this._toolConfirmationDialog) {
          const cancelButton = this._toolConfirmationDialog.querySelector(".cancel-tool");
          cancelButton?.click();
        } else if (this.expanded) {
          e.preventDefault();
          e.stopPropagation();
          this.expanded = false;
          this.focusInput();
        }
      }
    },

    addListeners() {
      this._updateFindbar = this.updateFindbar.bind(this);
      this._addKeymaps = this.addKeymaps.bind(this);
      this._handleInputKeyPress = this.handleInputKeyPress.bind(this);
      this._handleFindFieldInput = this.updateFoundMatchesDisplay.bind(this);
      const _clearLLMData = () => {
        this.updateFindbarStatus();
        this.clear();
      };
      const _handleContextMenuPrefChange = this.handleContextMenuPrefChange.bind(this);
      const _handleMinimalPrefChange = this.handleMinimalPrefChange.bind(this);

      gBrowser.tabContainer.addEventListener("TabSelect", this._updateFindbar);
      document.addEventListener("keydown", this._addKeymaps);
      this._godModeListener = UC_API.Prefs.addListener(PREFS.GOD_MODE, _clearLLMData);
      this._citationsListener = UC_API.Prefs.addListener(PREFS.CITATIONS_ENABLED, _clearLLMData);
      this._minimalListener = UC_API.Prefs.addListener(PREFS.MINIMAL, _handleMinimalPrefChange);
      this._contextMenuEnabledListener = UC_API.Prefs.addListener(
        PREFS.CONTEXT_MENU_ENABLED,
        _handleContextMenuPrefChange
      );
      this._persistListener = UC_API.Prefs.addListener(PREFS.PERSIST, (pref) => {
        if (!this.findbar) return;
        if (pref.value) this.findbar.history = llm.history;
        else this.findbar.history = null;
      });
      this._dndListener = UC_API.Prefs.addListener(PREFS.DND_ENABLED, (pref) => {
        if (pref.value) {
          this.enableDND();
          this.enableResize();
        } else {
          this.disableDND();
          this.disableResize();
        }
      });
    },

    removeListeners() {
      if (this.findbar) {
        this.findbar._findField.removeEventListener("keypress", this._handleInputKeyPress);
        this.findbar._findField.removeEventListener("input", this._handleFindFieldInput);
      }
      gBrowser.tabContainer.removeEventListener("TabSelect", this._updateFindbar);
      document.removeEventListener("keydown", this._addKeymaps);
      UC_API.Prefs.removeListener(this._godModeListener);
      UC_API.Prefs.removeListener(this._citationsListener);
      UC_API.Prefs.removeListener(this._contextMenuEnabledListener);
      UC_API.Prefs.removeListener(this._minimalListener);
      UC_API.Prefs.removeListener(this._persistListener);
      UC_API.Prefs.removeListener(this._dndListener);
      this.disableDND();

      // Disconnect the MutationObserver when listeners are removed
      if (this._matchesObserver) {
        this._matchesObserver.disconnect();
        this._matchesObserver = null;
      }

      this._handleInputKeyPress = null;
      this._handleFindFieldInput = null;
      this._updateFindbar = null;
      this._addKeymaps = null;
      this._godModeListener = null;
      this._citationsListener = null;
      this._contextMenuEnabledListener = null;
      this._minimalListener = null;
      this._dndListener = null;
    },

    updateFoundMatchesDisplay(retry = 0) {
      if (!this.findbar) return;
      const matches = this.findbar.querySelector(".found-matches");
      const status = this.findbar.querySelector(".findbar-find-status");
      const wrapper = this.findbar.querySelector('hbox[anonid="findbar-textbox-wrapper"]');
      if (!wrapper) {
        if (retry < 10) setTimeout(() => this.updateFoundMatchesDisplay(retry + 1), 100);
        return;
      }
      if (matches && matches.parentElement !== wrapper) wrapper.appendChild(matches);
      if (status && status.parentElement !== wrapper) wrapper.appendChild(status);

      if (status && status.getAttribute("status") === "notfound") {
        status.setAttribute("value", "0/0");
        status.textContent = "0/0";
      }

      if (matches) {
        const labelChild = matches.querySelector("label");
        let labelValue = labelChild
          ? labelChild.getAttribute("value")
          : matches.getAttribute("value");
        let newLabel = "";
        if (labelValue) {
          let normalized = labelValue.replace(/(\d+)\s+of\s+(\d+)(?:\s+match(?:es)?)?/i, "$1/$2");
          newLabel = normalized === "1/1" ? "1/1" : normalized;
        }
        if (labelChild) {
          if (labelChild.getAttribute("value") !== newLabel)
            labelChild.setAttribute("value", newLabel);
          if (labelChild.textContent !== newLabel) labelChild.textContent = newLabel;
        } else {
          if (matches.getAttribute("value") !== newLabel) matches.setAttribute("value", newLabel);
          if (matches.textContent !== newLabel) matches.textContent = newLabel;
        }

        // Disconnect existing observer before creating a new one
        if (this._matchesObserver) this._matchesObserver.disconnect();

        const observer = new MutationObserver(() => this.updateFoundMatchesDisplay());
        observer.observe(matches, {
          attributes: true,
          attributeFilter: ["value"],
        });
        if (labelChild)
          observer.observe(labelChild, {
            attributes: true,
            attributeFilter: ["value"],
          });
        if (status)
          observer.observe(status, {
            attributes: true,
            attributeFilter: ["status", "value"],
          });
        this._matchesObserver = observer;
      }
    },
  };

  UC_API.Runtime.startupFinished().then(() => {
    browseBotFindbar.init();
    UC_API.Prefs.addListener(
      PREFS.ENABLED,
      browseBotFindbar.handleEnabledChange.bind(browseBotFindbar)
    );
    window.browseBotFindbar = browseBotFindbar;
  });

  exports.browseBotFindbar = browseBotFindbar;

}));
